tool-call,function_callng,mcp调用

所以说真正调用工具的是运行环境或者是agent sdk帮我做的，

automatic_function_calling是google sdk的一部分的

如何拿到tool-call的rawdata,大模型选取了tool以后的，在mcp的client当中直接call，接着填回去就可以了，手动干sdk的事情

# 1.隐式调用，自动工具执行

gemini
- automatic_function_caliing控制的

整个工具调用流程对开发者来说是黑河的，llm自动判断是否需要调用工具，自动选择合适的工具和参数，自动执行工具并且整合结果的，开发者只需要提供工具列表，直接获得最终的自然语音回答

隐式是更新的技术，

## 缺陷：

结构化输出有时候又问题，

将现有的api套一层mcp的皮的时候，由于现有的api的返回已经是格式化的输出了，其实我们可能不需要llm帮助我们整理和生成json的，这部分完全可以用普通的代码，先付服务里的代码来进行处理的

但是隐式调用的时候，看不到llm的调用过程，没办法拿到mcp的raw data的


# 显示调用的，精准控制的手动解析模式的

显示调用模式需要开发者手动处理工具的各个环节，需要早系统提示当中明确告诉llm如何格式化工具调用的请求，手动解析llm回答当中的工具调用指令，然后执行对应的工具，最后把结果整合到最终的回答当中，

古法调用mcp的方法，隐式调用只是把这部分的llm处理的，不过实际上现在实际开发离使用的是显示调用，不完全是古法的

# 半自动显示调用

在mcp client当中，对于用户的查询，给llm工具列表之后，要求不是自己的调用工具，而是返回需要调用的工具的名称

接下来，需要让client手动调用mcp server，由于这部分数据很可能就是普通的api返回的格式化好的json data，可以把这个和llm的应答一起封装起来返回

适应常见，多轮对话，比单词对话麻烦不少，mcphost最好不是什么都管的完全通用的chat客户端，更加适合固定的服务，

有了raw data以后，完全自由处理数据，数据处理和ui显示等代码直接复用以前的服务里的部分就可以了，兼容没有自动工具调用的llm。
