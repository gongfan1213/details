# 数据持久化与状态管理系统

## 功能概述

BluePlan Research的数据持久化与状态管理系统负责管理用户会话、对话历史、配置信息、Token统计等数据的存储和检索。系统支持多种存储后端、数据备份恢复、状态同步等功能，确保数据的可靠性和一致性。

## 技术方案支撑

### 1. 多存储后端支持

#### Redis存储管理
```python
# utils/redis_client.py
import aioredis
import json
import pickle
from typing import Any, Optional, Dict, List

class RedisManager:
    def __init__(self, redis_url: str):
        self.redis_url = redis_url
        self.redis_pool = None
        self.init_pool()
    
    async def init_pool(self):
        """初始化连接池"""
        self.redis_pool = aioredis.from_url(
            self.redis_url,
            encoding="utf-8",
            decode_responses=True,
            max_connections=20
        )
    
    async def set_data(self, key: str, value: Any, expire: int = None):
        """设置数据"""
        try:
            if isinstance(value, (dict, list)):
                serialized_value = json.dumps(value, ensure_ascii=False)
            else:
                serialized_value = str(value)
            
            await self.redis_pool.set(key, serialized_value)
            
            if expire:
                await self.redis_pool.expire(key, expire)
                
        except Exception as e:
            print(f"Redis设置数据失败: {e}")
            raise
    
    async def get_data(self, key: str) -> Optional[Any]:
        """获取数据"""
        try:
            value = await self.redis_pool.get(key)
            if value is None:
                return None
            
            # 尝试JSON反序列化
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                return value
                
        except Exception as e:
            print(f"Redis获取数据失败: {e}")
            return None
    
    async def delete_data(self, key: str):
        """删除数据"""
        try:
            await self.redis_pool.delete(key)
        except Exception as e:
            print(f"Redis删除数据失败: {e}")
    
    async def exists(self, key: str) -> bool:
        """检查键是否存在"""
        try:
            return await self.redis_pool.exists(key) > 0
        except Exception as e:
            print(f"Redis检查键存在失败: {e}")
            return False
    
    async def set_hash(self, key: str, field: str, value: Any):
        """设置哈希字段"""
        try:
            if isinstance(value, (dict, list)):
                serialized_value = json.dumps(value, ensure_ascii=False)
            else:
                serialized_value = str(value)
            
            await self.redis_pool.hset(key, field, serialized_value)
        except Exception as e:
            print(f"Redis设置哈希字段失败: {e}")
    
    async def get_hash(self, key: str, field: str) -> Optional[Any]:
        """获取哈希字段"""
        try:
            value = await self.redis_pool.hget(key, field)
            if value is None:
                return None
            
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                return value
        except Exception as e:
            print(f"Redis获取哈希字段失败: {e}")
            return None
    
    async def get_all_hash(self, key: str) -> Dict[str, Any]:
        """获取所有哈希字段"""
        try:
            hash_data = await self.redis_pool.hgetall(key)
            result = {}
            
            for field, value in hash_data.items():
                try:
                    result[field] = json.loads(value)
                except json.JSONDecodeError:
                    result[field] = value
            
            return result
        except Exception as e:
            print(f"Redis获取所有哈希字段失败: {e}")
            return {}
```

#### 文件系统存储
```python
# utils/file_storage.py
import os
import json
import pickle
from pathlib import Path
from typing import Any, Optional, Dict, List

class FileStorageManager:
    def __init__(self, base_path: str = "data"):
        self.base_path = Path(base_path)
        self.base_path.mkdir(exist_ok=True)
    
    def get_file_path(self, category: str, key: str) -> Path:
        """获取文件路径"""
        category_path = self.base_path / category
        category_path.mkdir(exist_ok=True)
        return category_path / f"{key}.json"
    
    def save_data(self, category: str, key: str, data: Any):
        """保存数据到文件"""
        try:
            file_path = self.get_file_path(category, key)
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            print(f"保存文件失败: {e}")
            raise
    
    def load_data(self, category: str, key: str) -> Optional[Any]:
        """从文件加载数据"""
        try:
            file_path = self.get_file_path(category, key)
            
            if not file_path.exists():
                return None
            
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
                
        except Exception as e:
            print(f"加载文件失败: {e}")
            return None
    
    def delete_data(self, category: str, key: str):
        """删除文件数据"""
        try:
            file_path = self.get_file_path(category, key)
            
            if file_path.exists():
                file_path.unlink()
                
        except Exception as e:
            print(f"删除文件失败: {e}")
    
    def list_keys(self, category: str) -> List[str]:
        """列出分类下的所有键"""
        try:
            category_path = self.base_path / category
            
            if not category_path.exists():
                return []
            
            keys = []
            for file_path in category_path.glob("*.json"):
                keys.append(file_path.stem)
            
            return keys
        except Exception as e:
            print(f"列出键失败: {e}")
            return []
    
    def exists(self, category: str, key: str) -> bool:
        """检查数据是否存在"""
        file_path = self.get_file_path(category, key)
        return file_path.exists()
```

### 2. 会话状态管理

#### 会话管理器
```python
# utils/session_manager.py
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
import uuid

class SessionManager:
    def __init__(self, storage_manager):
        self.storage = storage_manager
        self.session_timeout = 3600  # 1小时超时
    
    async def create_session(self, user_id: str, session_data: Dict[str, Any] = None) -> str:
        """创建新会话"""
        session_id = str(uuid.uuid4())
        
        session_info = {
            "session_id": session_id,
            "user_id": user_id,
            "created_at": datetime.now().isoformat(),
            "last_activity": datetime.now().isoformat(),
            "data": session_data or {},
            "status": "active"
        }
        
        # 保存会话信息
        await self.storage.set_data(
            f"session:{session_id}",
            session_info,
            expire=self.session_timeout
        )
        
        # 更新用户会话列表
        await self.add_user_session(user_id, session_id)
        
        return session_id
    
    async def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话信息"""
        session_data = await self.storage.get_data(f"session:{session_id}")
        
        if session_data:
            # 更新最后活动时间
            session_data["last_activity"] = datetime.now().isoformat()
            await self.storage.set_data(
                f"session:{session_id}",
                session_data,
                expire=self.session_timeout
            )
        
        return session_data
    
    async def update_session(self, session_id: str, updates: Dict[str, Any]):
        """更新会话信息"""
        session_data = await self.get_session(session_id)
        
        if session_data:
            session_data.update(updates)
            session_data["last_activity"] = datetime.now().isoformat()
            
            await self.storage.set_data(
                f"session:{session_id}",
                session_data,
                expire=self.session_timeout
            )
    
    async def delete_session(self, session_id: str):
        """删除会话"""
        session_data = await self.get_session(session_id)
        
        if session_data:
            user_id = session_data["user_id"]
            
            # 删除会话数据
            await self.storage.delete_data(f"session:{session_id}")
            
            # 从用户会话列表中移除
            await self.remove_user_session(user_id, session_id)
    
    async def add_user_session(self, user_id: str, session_id: str):
        """添加用户会话"""
        user_sessions_key = f"user_sessions:{user_id}"
        user_sessions = await self.storage.get_data(user_sessions_key) or []
        
        if session_id not in user_sessions:
            user_sessions.append(session_id)
            await self.storage.set_data(user_sessions_key, user_sessions)
    
    async def remove_user_session(self, user_id: str, session_id: str):
        """移除用户会话"""
        user_sessions_key = f"user_sessions:{user_id}"
        user_sessions = await self.storage.get_data(user_sessions_key) or []
        
        if session_id in user_sessions:
            user_sessions.remove(session_id)
            await self.storage.set_data(user_sessions_key, user_sessions)
    
    async def get_user_sessions(self, user_id: str) -> List[Dict[str, Any]]:
        """获取用户的所有会话"""
        user_sessions_key = f"user_sessions:{user_id}"
        session_ids = await self.storage.get_data(user_sessions_key) or []
        
        sessions = []
        for session_id in session_ids:
            session_data = await self.get_session(session_id)
            if session_data:
                sessions.append(session_data)
        
        return sessions
    
    async def cleanup_expired_sessions(self):
        """清理过期会话"""
        # 这里可以实现定期清理过期会话的逻辑
        pass
```

### 3. 对话历史管理

#### 对话历史管理器
```python
# utils/conversation_manager.py
from datetime import datetime
from typing import Dict, Any, List, Optional

class ConversationManager:
    def __init__(self, storage_manager):
        self.storage = storage_manager
        self.max_history_length = 100  # 最大历史记录数
    
    async def add_message(self, session_id: str, message: Dict[str, Any]):
        """添加消息到对话历史"""
        conversation_key = f"conversation:{session_id}"
        
        # 获取现有对话历史
        conversation = await self.storage.get_data(conversation_key) or []
        
        # 添加新消息
        message["timestamp"] = datetime.now().isoformat()
        message["message_id"] = len(conversation) + 1
        
        conversation.append(message)
        
        # 限制历史记录长度
        if len(conversation) > self.max_history_length:
            conversation = conversation[-self.max_history_length:]
        
        # 保存更新后的对话历史
        await self.storage.set_data(conversation_key, conversation)
    
    async def get_conversation(self, session_id: str, limit: int = None) -> List[Dict[str, Any]]:
        """获取对话历史"""
        conversation_key = f"conversation:{session_id}"
        conversation = await self.storage.get_data(conversation_key) or []
        
        if limit:
            conversation = conversation[-limit:]
        
        return conversation
    
    async def clear_conversation(self, session_id: str):
        """清空对话历史"""
        conversation_key = f"conversation:{session_id}"
        await self.storage.delete_data(conversation_key)
    
    async def search_conversation(self, session_id: str, query: str) -> List[Dict[str, Any]]:
        """搜索对话历史"""
        conversation = await self.get_conversation(session_id)
        
        results = []
        for message in conversation:
            content = message.get("content", "")
            if query.lower() in content.lower():
                results.append(message)
        
        return results
    
    async def get_conversation_summary(self, session_id: str) -> Dict[str, Any]:
        """获取对话摘要"""
        conversation = await self.get_conversation(session_id)
        
        if not conversation:
            return {
                "message_count": 0,
                "start_time": None,
                "end_time": None,
                "duration": 0
            }
        
        start_time = datetime.fromisoformat(conversation[0]["timestamp"])
        end_time = datetime.fromisoformat(conversation[-1]["timestamp"])
        duration = (end_time - start_time).total_seconds()
        
        return {
            "message_count": len(conversation),
            "start_time": conversation[0]["timestamp"],
            "end_time": conversation[-1]["timestamp"],
            "duration": duration
        }
```

## 业务功能实现

### 1. Token统计管理

#### Token累加器
```python
# utils/token_accumulator.py
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
import json

class TokenAccumulator:
    def __init__(self, storage_manager):
        self.storage = storage_manager
    
    async def add_token_usage(self, user_id: str, session_id: str, 
                            tokens_used: int, model: str = "unknown"):
        """添加Token使用记录"""
        # 记录详细使用情况
        usage_record = {
            "user_id": user_id,
            "session_id": session_id,
            "tokens_used": tokens_used,
            "model": model,
            "timestamp": datetime.now().isoformat()
        }
        
        # 保存详细记录
        await self.save_usage_record(usage_record)
        
        # 更新用户统计
        await self.update_user_stats(user_id, tokens_used, model)
        
        # 更新会话统计
        await self.update_session_stats(session_id, tokens_used, model)
        
        # 更新全局统计
        await self.update_global_stats(tokens_used, model)
    
    async def save_usage_record(self, record: Dict[str, Any]):
        """保存使用记录"""
        record_id = f"{record['user_id']}:{record['session_id']}:{record['timestamp']}"
        await self.storage.set_data(f"token_usage:{record_id}", record)
    
    async def update_user_stats(self, user_id: str, tokens_used: int, model: str):
        """更新用户统计"""
        today = datetime.now().strftime("%Y-%m-%d")
        user_stats_key = f"user_token_stats:{user_id}:{today}"
        
        stats = await self.storage.get_data(user_stats_key) or {
            "total_tokens": 0,
            "model_usage": {},
            "session_count": 0
        }
        
        stats["total_tokens"] += tokens_used
        stats["model_usage"][model] = stats["model_usage"].get(model, 0) + tokens_used
        
        await self.storage.set_data(user_stats_key, stats, expire=86400*30)  # 30天过期
    
    async def update_session_stats(self, session_id: str, tokens_used: int, model: str):
        """更新会话统计"""
        session_stats_key = f"session_token_stats:{session_id}"
        
        stats = await self.storage.get_data(session_stats_key) or {
            "total_tokens": 0,
            "model_usage": {}
        }
        
        stats["total_tokens"] += tokens_used
        stats["model_usage"][model] = stats["model_usage"].get(model, 0) + tokens_used
        
        await self.storage.set_data(session_stats_key, stats)
    
    async def update_global_stats(self, tokens_used: int, model: str):
        """更新全局统计"""
        today = datetime.now().strftime("%Y-%m-%d")
        global_stats_key = f"global_token_stats:{today}"
        
        stats = await self.storage.get_data(global_stats_key) or {
            "total_tokens": 0,
            "model_usage": {},
            "user_count": 0
        }
        
        stats["total_tokens"] += tokens_used
        stats["model_usage"][model] = stats["model_usage"].get(model, 0) + tokens_used
        
        await self.storage.set_data(global_stats_key, stats, expire=86400*30)
    
    async def get_daily_token_stats(self, days: int = 7) -> List[Dict[str, Any]]:
        """获取每日Token统计"""
        stats = []
        
        for i in range(days):
            date = (datetime.now() - timedelta(days=i)).strftime("%Y-%m-%d")
            global_stats_key = f"global_token_stats:{date}"
            
            daily_stats = await self.storage.get_data(global_stats_key)
            if daily_stats:
                daily_stats["date"] = date
                stats.append(daily_stats)
        
        return stats
    
    async def get_monthly_token_stats(self, months: int = 3) -> List[Dict[str, Any]]:
        """获取月度Token统计"""
        stats = []
        
        for i in range(months):
            date = (datetime.now() - timedelta(days=30*i)).strftime("%Y-%m")
            monthly_stats = await self.aggregate_monthly_stats(date)
            
            if monthly_stats:
                monthly_stats["month"] = date
                stats.append(monthly_stats)
        
        return stats
    
    async def get_daily_user_token_ranking(self, target_date: str = None, 
                                         top_n: int = 10) -> List[Dict[str, Any]]:
        """获取用户Token排行榜"""
        if target_date is None:
            target_date = datetime.now().strftime("%Y-%m-%d")
        
        # 获取所有用户当天的统计
        user_stats = []
        
        # 这里需要实现获取所有用户统计的逻辑
        # 由于Redis没有直接的方法获取所有匹配的键，可能需要使用其他策略
        
        # 按Token使用量排序
        user_stats.sort(key=lambda x: x["total_tokens"], reverse=True)
        
        return user_stats[:top_n]
    
    async def get_token_dashboard_data(self) -> Dict[str, Any]:
        """获取Token统计仪表盘数据"""
        today = datetime.now().strftime("%Y-%m-%d")
        yesterday = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
        
        today_stats = await self.storage.get_data(f"global_token_stats:{today}") or {}
        yesterday_stats = await self.storage.get_data(f"global_token_stats:{yesterday}") or {}
        
        today_tokens = today_stats.get("total_tokens", 0)
        yesterday_tokens = yesterday_stats.get("total_tokens", 0)
        
        growth_rate = 0
        if yesterday_tokens > 0:
            growth_rate = ((today_tokens - yesterday_tokens) / yesterday_tokens) * 100
        
        return {
            "today_tokens": today_tokens,
            "yesterday_tokens": yesterday_tokens,
            "growth_rate": growth_rate,
            "model_usage": today_stats.get("model_usage", {}),
            "user_count": today_stats.get("user_count", 0)
        }
```

### 2. 配置持久化

#### 配置持久化管理器
```python
# utils/config_persistence.py
from typing import Dict, Any, Optional
import json

class ConfigPersistenceManager:
    def __init__(self, storage_manager):
        self.storage = storage_manager
        self.config_prefix = "config:"
    
    async def save_config(self, config_name: str, config_data: Dict[str, Any]):
        """保存配置"""
        config_key = f"{self.config_prefix}{config_name}"
        await self.storage.set_data(config_key, config_data)
    
    async def load_config(self, config_name: str) -> Optional[Dict[str, Any]]:
        """加载配置"""
        config_key = f"{self.config_prefix}{config_name}"
        return await self.storage.get_data(config_key)
    
    async def delete_config(self, config_name: str):
        """删除配置"""
        config_key = f"{self.config_prefix}{config_name}"
        await self.storage.delete_data(config_key)
    
    async def list_configs(self) -> List[str]:
        """列出所有配置"""
        # 这里需要实现获取所有配置名的逻辑
        # 可能需要使用其他策略来获取所有配置
        return []
    
    async def backup_configs(self, backup_name: str):
        """备份所有配置"""
        configs = {}
        
        # 获取所有配置
        config_names = await self.list_configs()
        for config_name in config_names:
            config_data = await self.load_config(config_name)
            if config_data:
                configs[config_name] = config_data
        
        # 保存备份
        backup_key = f"config_backup:{backup_name}"
        await self.storage.set_data(backup_key, configs)
    
    async def restore_configs(self, backup_name: str):
        """恢复配置备份"""
        backup_key = f"config_backup:{backup_name}"
        backup_data = await self.storage.get_data(backup_key)
        
        if backup_data:
            for config_name, config_data in backup_data.items():
                await self.save_config(config_name, config_data)
```

### 3. 数据备份与恢复

#### 备份管理器
```python
# utils/backup_manager.py
from datetime import datetime
from typing import Dict, Any, List
import json
import gzip

class BackupManager:
    def __init__(self, storage_manager, file_storage_manager):
        self.storage = storage_manager
        self.file_storage = file_storage_manager
    
    async def create_backup(self, backup_name: str = None) -> str:
        """创建数据备份"""
        if backup_name is None:
            backup_name = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # 收集所有数据
        backup_data = await self.collect_all_data()
        
        # 压缩数据
        compressed_data = gzip.compress(json.dumps(backup_data, ensure_ascii=False).encode())
        
        # 保存备份文件
        backup_file = f"backups/{backup_name}.json.gz"
        self.file_storage.save_data("backups", backup_name, {
            "backup_name": backup_name,
            "created_at": datetime.now().isoformat(),
            "data_size": len(compressed_data),
            "data": compressed_data.decode('latin1')  # 保存为字符串
        })
        
        return backup_name
    
    async def restore_backup(self, backup_name: str):
        """恢复数据备份"""
        backup_info = self.file_storage.load_data("backups", backup_name)
        
        if not backup_info:
            raise ValueError(f"备份 {backup_name} 不存在")
        
        # 解压数据
        compressed_data = backup_info["data"].encode('latin1')
        backup_data = json.loads(gzip.decompress(compressed_data).decode())
        
        # 恢复数据
        await self.restore_data(backup_data)
    
    async def list_backups(self) -> List[Dict[str, Any]]:
        """列出所有备份"""
        backup_names = self.file_storage.list_keys("backups")
        backups = []
        
        for backup_name in backup_names:
            backup_info = self.file_storage.load_data("backups", backup_name)
            if backup_info:
                backups.append({
                    "name": backup_name,
                    "created_at": backup_info["created_at"],
                    "data_size": backup_info["data_size"]
                })
        
        return backups
    
    async def delete_backup(self, backup_name: str):
        """删除备份"""
        self.file_storage.delete_data("backups", backup_name)
    
    async def collect_all_data(self) -> Dict[str, Any]:
        """收集所有数据"""
        # 这里需要实现收集所有数据的逻辑
        # 包括会话、对话历史、配置、Token统计等
        return {}
    
    async def restore_data(self, backup_data: Dict[str, Any]):
        """恢复数据"""
        # 这里需要实现恢复数据的逻辑
        pass
```

## 常见问题与解决方案

### 1. 数据一致性问题

#### 问题描述
多实例部署时可能出现数据不一致的问题。

#### 解决方案
- **分布式锁**: 使用分布式锁确保数据一致性
- **事务管理**: 实现事务管理机制
- **数据同步**: 定期数据同步
- **冲突解决**: 实现冲突解决策略

### 2. 存储性能问题

#### 问题描述
大量数据可能导致存储性能下降。

#### 解决方案
- **数据分片**: 实现数据分片存储
- **缓存优化**: 优化缓存策略
- **索引优化**: 优化数据索引
- **压缩存储**: 使用数据压缩

### 3. 数据安全问题

#### 问题描述
敏感数据可能面临安全风险。

#### 解决方案
- **数据加密**: 对敏感数据进行加密
- **访问控制**: 严格的访问权限控制
- **审计日志**: 完整的数据访问审计
- **备份加密**: 备份数据加密存储

## 系统设计优势

### 1. 高可靠性
- **数据备份**: 定期数据备份
- **故障恢复**: 自动故障恢复
- **数据验证**: 数据完整性验证
- **冗余存储**: 数据冗余存储

### 2. 高性能
- **缓存机制**: 智能缓存机制
- **异步处理**: 异步数据处理
- **批量操作**: 支持批量操作
- **连接池**: 连接池管理

### 3. 易扩展性
- **多存储后端**: 支持多种存储后端
- **插件机制**: 支持存储插件
- **水平扩展**: 支持水平扩展
- **模块化设计**: 模块化设计

## 可扩展性设计

### 1. 存储后端扩展
```python
# 新增存储后端
class DatabaseStorageManager:
    def __init__(self, database_url):
        self.db = Database(database_url)
    
    async def set_data(self, key: str, value: Any):
        """设置数据到数据库"""
        # 实现数据库存储逻辑
        pass
    
    async def get_data(self, key: str) -> Optional[Any]:
        """从数据库获取数据"""
        # 实现数据库读取逻辑
        pass
```

### 2. 数据格式扩展
- **二进制存储**: 支持二进制数据存储
- **压缩存储**: 支持数据压缩存储
- **加密存储**: 支持数据加密存储
- **自定义格式**: 支持自定义数据格式

### 3. 功能扩展
- **数据迁移**: 支持数据迁移功能
- **数据同步**: 支持数据同步功能
- **数据分析**: 支持数据分析功能
- **数据清理**: 支持数据清理功能

## 高可用性保障

### 1. 数据备份
- **自动备份**: 定期自动备份
- **增量备份**: 支持增量备份
- **异地备份**: 支持异地备份
- **备份验证**: 备份数据验证

### 2. 故障恢复
- **快速恢复**: 快速数据恢复
- **点恢复**: 支持时间点恢复
- **部分恢复**: 支持部分数据恢复
- **恢复测试**: 定期恢复测试

### 3. 监控告警
- **存储监控**: 存储状态监控
- **性能监控**: 存储性能监控
- **容量监控**: 存储容量监控
- **异常告警**: 存储异常告警

## 通用性设计

### 1. 标准化接口
- **统一API**: 统一的存储API
- **数据格式**: 标准化的数据格式
- **错误处理**: 统一的错误处理
- **配置管理**: 统一的配置管理

### 2. 跨平台支持
- **多操作系统**: 支持多种操作系统
- **容器化**: 支持容器化部署
- **云平台**: 支持多种云平台
- **混合环境**: 支持混合环境

### 3. 集成能力
- **第三方集成**: 支持第三方系统集成
- **API开放**: 提供开放的API接口
- **插件机制**: 支持插件扩展
- **事件通知**: 支持事件通知

## 总结

数据持久化与状态管理系统是BluePlan Research的重要基础设施，通过多存储后端支持、完善的会话管理、Token统计等功能，确保数据的可靠性和一致性。系统具备强大的扩展性和高可用性，能够满足复杂业务场景的各种数据存储需求。
