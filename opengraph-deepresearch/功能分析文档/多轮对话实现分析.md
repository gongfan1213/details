# BluePlan Research å¤šè½®å¯¹è¯å®ç°åˆ†æ

## ç³»ç»Ÿæ¦‚è¿°

BluePlan Researchçš„å¤šè½®å¯¹è¯ç³»ç»ŸåŸºäºä¸Šä¸‹æ–‡ç®¡ç†ã€ä¼šè¯çŠ¶æ€ç»´æŠ¤å’Œæµå¼å“åº”æŠ€æœ¯ï¼Œå®ç°äº†æ™ºèƒ½ã€è¿è´¯çš„å¤šè½®å¯¹è¯ä½“éªŒã€‚ç³»ç»Ÿæ”¯æŒä¼šè¯æŒä¹…åŒ–ã€ä¸Šä¸‹æ–‡ä¼ é€’ã€å®æ—¶æµå¼å“åº”å’Œæ™ºèƒ½çŠ¶æ€æ¢å¤ï¼Œä¸ºç”¨æˆ·æä¾›è‡ªç„¶ã€æµç•…çš„å¯¹è¯äº¤äº’ã€‚

## æŠ€æœ¯æ¶æ„

### 1. å¤šè½®å¯¹è¯æ¶æ„è®¾è®¡

#### æ•´ä½“æ¶æ„
```python
class MultiTurnDialogueSystem:
    """
    å¤šè½®å¯¹è¯ç³»ç»Ÿæ¶æ„
    
    æ ¸å¿ƒç»„ä»¶ï¼š
    1. ä¸Šä¸‹æ–‡ç®¡ç†å™¨ - ç»´æŠ¤ä¼šè¯çŠ¶æ€å’Œå¯¹è¯å†å²
    2. ä¼šè¯ç®¡ç†å™¨ - ç®¡ç†ç”¨æˆ·ä¼šè¯ç”Ÿå‘½å‘¨æœŸ
    3. æµå¼å“åº”å™¨ - å®æ—¶æ¨é€å¯¹è¯å†…å®¹
    4. çŠ¶æ€æ¢å¤å™¨ - å¤„ç†æ–­çº¿é‡è¿å’ŒçŠ¶æ€æ¢å¤
    """
    
    def __init__(self):
        self.context_manager = ContextManager()
        self.session_manager = SessionManager()
        self.streaming_responder = StreamingResponder()
        self.state_recovery = StateRecovery()
```

#### ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†
```python
class SessionLifecycle:
    """ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†"""
    
    def __init__(self):
        self.session_states = {
            "created": "ä¼šè¯åˆ›å»º",
            "active": "æ´»è·ƒçŠ¶æ€", 
            "paused": "æš‚åœçŠ¶æ€",
            "completed": "å®ŒæˆçŠ¶æ€",
            "expired": "è¿‡æœŸçŠ¶æ€"
        }
    
    async def create_session(self, user_id: str, session_id: str) -> Dict[str, Any]:
        """åˆ›å»ºæ–°ä¼šè¯"""
        session_data = {
            "user_id": user_id,
            "session_id": session_id,
            "state": "created",
            "created_at": datetime.now().isoformat(),
            "last_activity": datetime.now().isoformat(),
            "conversation_history": [],
            "context_data": {}
        }
        
        # ä¿å­˜åˆ°å­˜å‚¨
        await self.save_session(session_data)
        return session_data
    
    async def update_session_activity(self, session_id: str):
        """æ›´æ–°ä¼šè¯æ´»åŠ¨æ—¶é—´"""
        session = await self.get_session(session_id)
        if session:
            session["last_activity"] = datetime.now().isoformat()
            session["state"] = "active"
            await self.save_session(session)
```

### 2. ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ

#### Nova3ä¸Šä¸‹æ–‡ç®¡ç†å™¨
```python
@dataclass
class ContextState:
    """ä¸Šä¸‹æ–‡çŠ¶æ€æ•°æ®ç»“æ„"""
    session_id: str
    user_id: str
    thread_id: str
    current_step: int
    total_steps: int
    global_context: Dict[str, Any]  # å…¨å±€ä¸Šä¸‹æ–‡
    agent_contexts: Dict[str, Any]  # å„agentçš„ä¸Šä¸‹æ–‡
    shared_memory: Dict[str, Any]   # å…±äº«å†…å­˜
    conversation_history: List[Dict[str, Any]]  # å¯¹è¯å†å²
    research_findings: Dict[str, Any]  # ç ”ç©¶å‘ç°
    created_at: str
    updated_at: str

class ContextManager:
    """å¤šæ™ºèƒ½ä½“ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    
    def __init__(self):
        self.logger = BluePlanLogger("context_manager")
        self.redis_client = None
        self._context_cache: Dict[str, ContextState] = {}
    
    async def create_context(self, user_id: str, session_id: str, initial_query: str) -> ContextState:
        """åˆ›å»ºæ–°çš„ä¸Šä¸‹æ–‡çŠ¶æ€"""
        thread_id = str(uuid.uuid4())
        
        context_state = ContextState(
            session_id=session_id,
            user_id=user_id,
            thread_id=thread_id,
            current_step=0,
            total_steps=1,
            global_context={
                "initial_query": initial_query,
                "session_start_time": datetime.now().isoformat(),
                "workflow_type": "nova3_research"
            },
            agent_contexts={},
            shared_memory={},
            conversation_history=[{
                "role": "user",
                "content": initial_query,
                "timestamp": datetime.now().isoformat()
            }],
            research_findings={},
            created_at=datetime.now().isoformat(),
            updated_at=datetime.now().isoformat()
        )
        
        # ä¿å­˜åˆ°Rediså’Œç¼“å­˜
        await self._save_context(context_state)
        self._context_cache[f"{user_id}:{session_id}"] = context_state
        
        return context_state
    
    async def add_conversation_message(self, user_id: str, session_id: str, role: str, content: str, agent_source: Optional[str] = None) -> bool:
        """æ·»åŠ å¯¹è¯æ¶ˆæ¯åˆ°å†å²è®°å½•"""
        context_state = await self.get_context(user_id, session_id)
        if not context_state:
            return False
        
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat(),
            "agent_source": agent_source,
            "step": context_state.current_step
        }
        
        context_state.conversation_history.append(message)
        await self._save_context(context_state)
        self._context_cache[f"{user_id}:{session_id}"] = context_state
        
        return True
```

#### Loomiä¸Šä¸‹æ–‡ç®¡ç†å™¨
```python
@dataclass
class LoomiContextState:
    """Loomiä¸Šä¸‹æ–‡çŠ¶æ€æ•°æ®ç»“æ„"""
    session_id: str
    user_id: str
    thread_id: str
    
    # Loomiç‰¹æœ‰çš„ä¸Šä¸‹æ–‡ç»“æ„
    user_message_queue: List[Dict[str, Any]]  # ç”¨æˆ·æ¶ˆæ¯é˜Ÿåˆ—
    orchestrator_calls: List[Dict[str, Any]]  # orchestratorè°ƒç”¨è®°å½•
    created_notes: List[Dict[str, Any]]  # åˆ›å»ºçš„notes
    
    # é€šç”¨ä¸Šä¸‹æ–‡
    global_context: Dict[str, Any]  # å…¨å±€ä¸Šä¸‹æ–‡
    agent_contexts: Dict[str, Any]  # å„agentçš„ä¸Šä¸‹æ–‡
    shared_memory: Dict[str, Any]   # å…±äº«å†…å­˜
    conversation_history: List[Dict[str, Any]]  # å¯¹è¯å†å²
    
    created_at: str
    updated_at: str

class LoomiContextManager:
    """Loomiå¤šæ™ºèƒ½ä½“ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    
    async def create_context(self, user_id: str, session_id: str, initial_query: str) -> LoomiContextState:
        """åˆ›å»ºæ–°çš„ä¸Šä¸‹æ–‡çŠ¶æ€ï¼ˆæ”¯æŒæŒä¹…åŒ–ï¼‰"""
        # é¦–å…ˆå°è¯•ä»æ•°æ®åº“æ¢å¤ç°æœ‰ä¸Šä¸‹æ–‡
        existing_context = await self._load_context_from_db(user_id, session_id)
        if existing_context:
            # å°†æ–°çš„æŸ¥è¯¢æ·»åŠ åˆ°æ¶ˆæ¯é˜Ÿåˆ—
            existing_context.user_message_queue.append({
                "content": initial_query,
                "timestamp": datetime.now().isoformat(),
                "is_new": True,
                "message_id": str(uuid.uuid4())
            })
            # åŒæ—¶æ·»åŠ åˆ°å¯¹è¯å†å²
            existing_context.conversation_history.append({
                "role": "user",
                "content": initial_query,
                "timestamp": datetime.now().isoformat()
            })
            await self._save_context(existing_context)
            return existing_context
        
        # åˆ›å»ºæ–°ä¸Šä¸‹æ–‡
        thread_id = str(uuid.uuid4())
        context_state = LoomiContextState(
            session_id=session_id,
            user_id=user_id,
            thread_id=thread_id,
            user_message_queue=[{
                "content": initial_query,
                "timestamp": datetime.now().isoformat(),
                "is_new": True,
                "message_id": str(uuid.uuid4())
            }],
            orchestrator_calls=[],
            created_notes=[],
            global_context={
                "initial_query": initial_query,
                "session_start_time": datetime.now().isoformat(),
                "workflow_type": "loomi_content_creation"
            },
            agent_contexts={},
            shared_memory={},
            conversation_history=[{
                "role": "user",
                "content": initial_query,
                "timestamp": datetime.now().isoformat()
            }],
            created_at=datetime.now().isoformat(),
            updated_at=datetime.now().isoformat()
        )
        
        await self._save_context(context_state)
        return context_state
```

### 3. ä¸Šä¸‹æ–‡æ„å»ºå™¨

#### LoomiContextBuilder
```python
class LoomiContextBuilder:
    """Loomiä¸Šä¸‹æ–‡æ„å»ºå™¨"""
    
    async def build_concierge_context(self, user_id: str, session_id: str, current_user_message: str, user_selections: Optional[List[str]] = None) -> str:
        """ä¸ºConciergeæ„å»ºä¸Šä¸‹æ–‡"""
        parts = []
        
        try:
            # ğŸ¯ ã€æ™ºèƒ½agentå¼•ç”¨ã€‘å¦‚æœuser_selectionsæœ‰å†…å®¹ä¸”æ¶ˆæ¯ä¸ä»¥@å¼€å¤´ï¼Œè‡ªåŠ¨æ·»åŠ å¼•ç”¨
            if "@" not in current_user_message and user_selections and current_user_message and not current_user_message.strip().startswith('@'):
                current_user_message = f"@{user_selections[0]},{current_user_message}"
            
            # 1. [chat_history] - å¯¹è¯å†å²ï¼Œä½¿ç”¨ç¼–å·æ ¼å¼
            parts.append("[chat_history]")
            
            # è·å–å¯¹è¯å†å²
            context_state = await loomi_context_manager.get_context(user_id, session_id)
            if context_state and context_state.conversation_history:
                # æ£€æŸ¥å½“å‰æ¶ˆæ¯æ˜¯å¦æ˜¯æ–°çš„ï¼ˆè¿˜æœªè®°å½•åœ¨å¯¹è¯å†å²ä¸­ï¼‰
                last_message = context_state.conversation_history[-1] if context_state.conversation_history else None
                is_new_message = True
                if last_message and last_message.get("role") == "user" and last_message.get("content", "").strip() == current_user_message.strip():
                    is_new_message = False
                
                # æ ¼å¼åŒ–å¯¹è¯å†å²ä¸ºç¼–å·æ ¼å¼
                for i, msg in enumerate(context_state.conversation_history, 1):
                    role = msg.get("role", "")
                    content = msg.get("content", "")
                    
                    if role == "user":
                        parts.append(f"#{i} **ç”¨æˆ·**: {content}")
                    elif role == "websearch":
                        parts.append(f"#{i} websearch:")
                        parts.append(content)
                    else:
                        parts.append(f"#{i} Loomiï¼ˆä½ ï¼‰: {content}")
                
                # å¦‚æœå½“å‰æ¶ˆæ¯æ˜¯æ–°çš„ï¼Œæ·»åŠ åˆ°æœ«å°¾å¹¶æ ‡è®°(æ–°)
                if is_new_message:
                    next_num = len(context_state.conversation_history) + 1
                    parts.append(f"#{next_num} **(æ–°) ç”¨æˆ·**: {current_user_message}")
            else:
                # é¦–æ¬¡å¯¹è¯ï¼Œå½“å‰æ¶ˆæ¯æ˜¯æ–°çš„
                parts.append(f"#1 **(æ–°) ç”¨æˆ·**: {current_user_message}")
            
            # 2. [notes] - å·²åˆ›å»ºçš„notes
            parts.append("\n[notes]")
            if context_state and context_state.created_notes:
                for i, note in enumerate(context_state.created_notes, 1):
                    note_name = note.get("name", f"note_{i}")
                    note_content = note.get("context", "")
                    parts.append(f"@{note_name}: {note_content}")
            else:
                parts.append("æš‚æ— å·²åˆ›å»ºçš„notes")
            
            # 3. [instructions] - ç³»ç»ŸæŒ‡ä»¤
            parts.append("\n[instructions]")
            parts.append("ä½ æ˜¯Loomiï¼Œä¸€ä¸ªä¸“ä¸šçš„ç¤¾äº¤åª’ä½“å†…å®¹åˆ›ä½œåŠ©æ‰‹ã€‚")
            parts.append("è¯·æ ¹æ®ç”¨æˆ·çš„è¯·æ±‚ï¼Œåˆ›å»ºç›¸åº”çš„notesæˆ–æ‰§è¡Œç›¸å…³æ“ä½œã€‚")
            
            return "\n".join(parts)
            
        except Exception as e:
            self.logger.error(f"æ„å»ºConciergeä¸Šä¸‹æ–‡å¤±è´¥: {e}")
            return f"ç”¨æˆ·æ¶ˆæ¯: {current_user_message}"
```

## æµå¼å“åº”å®ç°

### 1. Server-Sent Events (SSE) æ¶æ„

#### SSEæœåŠ¡å™¨å®ç°
```python
from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse
import asyncio
import json

class SSEServer:
    def __init__(self):
        self.app = FastAPI()
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.post("/novachat")
        async def novachat_stream(request: Request):
            """Nova3æ¨¡å¼çš„æµå¼èŠå¤©æ¥å£"""
            return StreamingResponse(
                self.generate_nova3_stream(request),
                media_type="text/event-stream",
                headers={
                    "Cache-Control": "no-cache",
                    "Connection": "keep-alive",
                    "Access-Control-Allow-Origin": "*",
                    "Access-Control-Allow-Headers": "*"
                }
            )
        
        @self.app.post("/loomichat")
        async def loomichat_stream(request: Request):
            """Loomiæ¨¡å¼çš„æµå¼èŠå¤©æ¥å£"""
            return StreamingResponse(
                self.generate_loomi_stream(request),
                media_type="text/event-stream"
            )
```

#### Nova3æµå¼å“åº”ç”Ÿæˆå™¨
```python
async def novachat_stream_generator(request: ChatRequest) -> AsyncGenerator[str, None]:
    """Nova3èŠå¤©æµå¼å“åº”ç”Ÿæˆå™¨"""
    try:
        # å‘é€å¼€å§‹äº‹ä»¶
        start_event = StreamEvent(
            event_type=EventType.SYSTEM,
            agent_source="Nova3",
            payload=EventPayload(content_type=None, data="Nova3 æ™ºèƒ½ç¼–æ’ç³»ç»Ÿå·²è¿æ¥ï¼Œå¼€å§‹åˆ†ææ‚¨çš„éœ€æ±‚...")
        )
        yield f"{start_event.model_dump_json()}\n\n"
        
        # ä½¿ç”¨ä¼šè¯çº§agentå®ä¾‹ï¼Œé¿å…å…¨å±€çŠ¶æ€æ··ä¹±
        nova3 = await session_agent_manager.get_nova3_supervisor(request.user_id, request.session_id)
        
        # æ„å»ºè¯·æ±‚æ•°æ®
        nova3_request: Dict[str, Any] = {
            "query": request.request_data.query,
            "user_id": request.user_id,
            "session_id": request.session_id,
            "timestamp": datetime.now().isoformat()
        }
        
        # æ·»åŠ sessionä¿¡æ¯åˆ°context
        context = {
            "user_id": request.user_id,
            "session_id": request.session_id,
            "timestamp": datetime.now().isoformat()
        }
        
        async for event in nova3.process_request(nova3_request, context):
            # ç¡®ä¿äº‹ä»¶æ ¼å¼ç¬¦åˆæµå¼åè®®
            if isinstance(event, dict):
                # è½¬æ¢ä¸ºStreamEventæ ¼å¼
                stream_event = StreamEvent(
                    event_type=EventType(event.get("event_type", "system")),
                    agent_source=event.get("agent_source", "Nova3"),
                    timestamp=event.get("timestamp", datetime.now().isoformat()),
                    payload=EventPayload(
                        content_type=event.get("payload", {}).get("content_type"),
                        data=event.get("payload", {}).get("data", ""),
                        metadata=event.get("payload", {}).get("metadata", {})
                    )
                )
                yield f"{stream_event.model_dump_json()}\n\n"
            else:
                # å¦‚æœå·²ç»æ˜¯StreamEventå¯¹è±¡
                yield f"{event.model_dump_json()}\n\n"
        
        # æµå¼è¾“å‡ºç»“æŸï¼Œå‘é€DONEæ ‡è®°
        yield "[DONE]\n\n"
            
    except Exception as e:
        # å‘é€é”™è¯¯äº‹ä»¶
        error_event = StreamEvent(
            event_type=EventType.ERROR,
            agent_source="Nova3",
            payload=EventPayload(content_type=None, data=f"å¤„ç†å¤±è´¥: {str(e)}")
        )
        yield f"{error_event.model_dump_json()}\n\n"
        yield "[DONE]\n\n"
```

#### Loomiæµå¼å“åº”ç”Ÿæˆå™¨
```python
async def loomichat_stream_generator(request: ChatRequest) -> AsyncGenerator[str, None]:
    """LoomièŠå¤©æµå¼å“åº”ç”Ÿæˆå™¨"""
    try:
        # è®°å½•æµå¼å¤„ç†å¼€å§‹æ—¥å¿—
        query = request.request_data.query.strip() if request.request_data.query else ""
        auto_mode = getattr(request.request_data, 'auto', False)
        
        # å‘é€å¼€å§‹äº‹ä»¶
        start_event = StreamEvent(
            event_type=EventType.SYSTEM,
            agent_source="Loomi",
            payload=EventPayload(content_type=None, data="Loomi æ™ºèƒ½æ¥å¾…å‘˜å·²è¿æ¥ï¼Œå¼€å§‹åˆ†ææ‚¨çš„éœ€æ±‚...")
        )
        yield f"{start_event.model_dump_json()}\n\n"
        
        # ä½¿ç”¨ä¼šè¯çº§agentå®ä¾‹ï¼Œé¿å…å…¨å±€çŠ¶æ€æ··ä¹±
        loomi_concierge = await session_agent_manager.get_loomi_concierge(request.user_id, request.session_id)
        
        # æ„å»ºConciergeè¯·æ±‚
        concierge_request = {
            "user_id": request.user_id,
            "session_id": request.session_id,
            "query": query,
            "auto_mode": auto_mode,
            "user_selections": getattr(request.request_data, 'user_selections', []),
            "timestamp": datetime.now().isoformat()
        }
        
        # æµå¼å¤„ç†
        async for event in loomi_concierge.process_request(concierge_request):
            # æ£€æŸ¥äº‹ä»¶ç±»å‹ï¼šStreamEventå¯¹è±¡æˆ–å­—ç¬¦ä¸²
            if isinstance(event, str):
                # å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œç›´æ¥yield
                yield event
            else:
                # å¦‚æœæ˜¯StreamEventå¯¹è±¡ï¼Œè°ƒç”¨model_dump_json()
                yield f"{event.model_dump_json()}\n\n"
        
        # å‘é€å®Œæˆäº‹ä»¶
        end_event = StreamEvent(
            event_type=EventType.SYSTEM,
            agent_source="Loomi",
            payload=EventPayload(content_type=None, data="Loomi å¤„ç†å®Œæˆ")
        )
        yield f"{end_event.model_dump_json()}\n\n"
        yield "[DONE]\n\n"
        
    except Exception as e:
        # å‘é€é”™è¯¯äº‹ä»¶
        error_event = StreamEvent(
            event_type=EventType.ERROR,
            agent_source="Loomi",
            payload=EventPayload(content_type=None, data=f"Loomiå¤„ç†å¤±è´¥: {str(e)}")
        )
        yield f"{error_event.model_dump_json()}\n\n"
        yield "[DONE]\n\n"
```

### 2. äº‹ä»¶ç±»å‹å®šä¹‰

#### æ ‡å‡†äº‹ä»¶ç»“æ„
```python
@dataclass
class StreamEvent:
    """æµå¼äº‹ä»¶ç»“æ„"""
    event_type: EventType
    agent_source: str
    timestamp: str
    payload: EventPayload

@dataclass
class EventPayload:
    """äº‹ä»¶è½½è·"""
    content_type: Optional[str]
    data: str
    metadata: Optional[Dict[str, Any]] = None

class EventType(str, Enum):
    """äº‹ä»¶ç±»å‹æšä¸¾"""
    SYSTEM = "system"           # ç³»ç»Ÿäº‹ä»¶
    LLM_CHUNK = "llm_chunk"     # LLMæµå¼è¾“å‡º
    AGENT_ACTION = "agent_action"  # AgentåŠ¨ä½œ
    TOOL_CALL = "tool_call"     # å·¥å…·è°ƒç”¨
    ERROR = "error"             # é”™è¯¯äº‹ä»¶
    COMPLETE = "complete"       # å®Œæˆäº‹ä»¶
```

## å¤šè½®å¯¹è¯æµç¨‹

### 1. å¯¹è¯åˆå§‹åŒ–æµç¨‹

#### ä¼šè¯åˆ›å»º
```python
async def initialize_conversation(user_id: str, session_id: str, initial_query: str) -> Dict[str, Any]:
    """åˆå§‹åŒ–å¯¹è¯ä¼šè¯"""
    try:
        # 1. åˆ›å»ºä¼šè¯
        session_data = await session_manager.create_session(user_id, session_id)
        
        # 2. åˆ›å»ºä¸Šä¸‹æ–‡
        context_state = await context_manager.create_context(
            user_id=user_id,
            session_id=session_id,
            initial_query=initial_query
        )
        
        # 3. åˆå§‹åŒ–Agentå®ä¾‹
        agent_instance = await agent_manager.get_agent_instance(user_id, session_id)
        
        # 4. è¿”å›åˆå§‹åŒ–ç»“æœ
        return {
            "session_id": session_id,
            "thread_id": context_state.thread_id,
            "status": "initialized",
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"å¯¹è¯åˆå§‹åŒ–å¤±è´¥: {e}")
        raise
```

### 2. å¯¹è¯æ¶ˆæ¯å¤„ç†æµç¨‹

#### æ¶ˆæ¯æ¥æ”¶å’Œå¤„ç†
```python
async def process_conversation_message(user_id: str, session_id: str, message: str) -> AsyncGenerator[StreamEvent, None]:
    """å¤„ç†å¯¹è¯æ¶ˆæ¯"""
    try:
        # 1. è·å–æˆ–æ¢å¤ä¸Šä¸‹æ–‡
        context_state = await context_manager.get_context(user_id, session_id)
        if not context_state:
            # åˆ›å»ºæ–°ä¸Šä¸‹æ–‡
            context_state = await context_manager.create_context(
                user_id=user_id,
                session_id=session_id,
                initial_query=message
            )
            yield StreamEvent(
                event_type=EventType.SYSTEM,
                agent_source="System",
                payload=EventPayload(content_type=None, data="æ–°ä¼šè¯å·²åˆ›å»º")
            )
        else:
            # æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°å†å²
            await context_manager.add_conversation_message(
                user_id=user_id,
                session_id=session_id,
                role="user",
                content=message
            )
        
        # 2. è·å–Agentå®ä¾‹
        agent = await agent_manager.get_agent_instance(user_id, session_id)
        
        # 3. æ„å»ºè¯·æ±‚æ•°æ®
        request_data = {
            "query": message,
            "user_id": user_id,
            "session_id": session_id,
            "context": context_state,
            "timestamp": datetime.now().isoformat()
        }
        
        # 4. æµå¼å¤„ç†è¯·æ±‚
        async for event in agent.process_request(request_data):
            yield event
            
            # å¦‚æœæ˜¯Agentå›å¤ï¼Œæ·»åŠ åˆ°å¯¹è¯å†å²
            if event.event_type == EventType.AGENT_ACTION and event.payload.content_type == "response":
                await context_manager.add_conversation_message(
                    user_id=user_id,
                    session_id=session_id,
                    role="assistant",
                    content=event.payload.data,
                    agent_source=event.agent_source
                )
        
        # 5. å‘é€å®Œæˆäº‹ä»¶
        yield StreamEvent(
            event_type=EventType.COMPLETE,
            agent_source="System",
            payload=EventPayload(content_type=None, data="æ¶ˆæ¯å¤„ç†å®Œæˆ")
        )
        
    except Exception as e:
        # å‘é€é”™è¯¯äº‹ä»¶
        yield StreamEvent(
            event_type=EventType.ERROR,
            agent_source="System",
            payload=EventPayload(content_type=None, data=f"å¤„ç†å¤±è´¥: {str(e)}")
        )
```

### 3. ä¸Šä¸‹æ–‡ä¼ é€’æœºåˆ¶

#### æ™ºèƒ½ä¸Šä¸‹æ–‡ä¼ é€’
```python
class ContextPassingManager:
    """ä¸Šä¸‹æ–‡ä¼ é€’ç®¡ç†å™¨"""
    
    async def build_context_for_agent(self, agent_name: str, context_state: ContextState, current_query: str) -> str:
        """ä¸ºç‰¹å®šAgentæ„å»ºä¸Šä¸‹æ–‡"""
        if agent_name == "concierge":
            return await self._build_concierge_context(context_state, current_query)
        elif agent_name == "orchestrator":
            return await self._build_orchestrator_context(context_state, current_query)
        elif agent_name == "supervisor":
            return await self._build_supervisor_context(context_state, current_query)
        else:
            return await self._build_generic_context(context_state, current_query)
    
    async def _build_concierge_context(self, context_state: ContextState, current_query: str) -> str:
        """æ„å»ºConciergeä¸Šä¸‹æ–‡"""
        parts = []
        
        # 1. å¯¹è¯å†å²
        parts.append("[chat_history]")
        for i, msg in enumerate(context_state.conversation_history, 1):
            role = msg.get("role", "")
            content = msg.get("content", "")
            if role == "user":
                parts.append(f"#{i} **ç”¨æˆ·**: {content}")
            else:
                parts.append(f"#{i} **åŠ©æ‰‹**: {content}")
        
        # 2. å½“å‰æŸ¥è¯¢
        parts.append(f"\n[å½“å‰æŸ¥è¯¢]")
        parts.append(f"ç”¨æˆ·: {current_query}")
        
        # 3. ç³»ç»ŸæŒ‡ä»¤
        parts.append(f"\n[æŒ‡ä»¤]")
        parts.append("ä½ æ˜¯Loomiçš„æ™ºèƒ½æ¥å¾…å‘˜ï¼Œè¯·ç†è§£ç”¨æˆ·éœ€æ±‚å¹¶åˆ›å»ºç›¸åº”çš„notesã€‚")
        
        return "\n".join(parts)
```

## çŠ¶æ€æ¢å¤æœºåˆ¶

### 1. æ–­çº¿é‡è¿å¤„ç†

#### ä¼šè¯çŠ¶æ€æ£€æŸ¥
```python
async def check_session_status(user_id: str, session_id: str) -> Dict[str, Any]:
    """æ£€æŸ¥ä¼šè¯çŠ¶æ€"""
    try:
        # 1. æ£€æŸ¥ä¼šè¯æ˜¯å¦å­˜åœ¨
        session = await session_manager.get_session(session_id)
        if not session:
            return {
                "status": "not_found",
                "message": "ä¼šè¯ä¸å­˜åœ¨"
            }
        
        # 2. æ£€æŸ¥ä¼šè¯æ˜¯å¦è¿‡æœŸ
        last_activity = datetime.fromisoformat(session["last_activity"])
        if datetime.now() - last_activity > timedelta(hours=24):
            return {
                "status": "expired",
                "message": "ä¼šè¯å·²è¿‡æœŸ"
            }
        
        # 3. æ£€æŸ¥ä¸Šä¸‹æ–‡çŠ¶æ€
        context_state = await context_manager.get_context(user_id, session_id)
        if not context_state:
            return {
                "status": "context_missing",
                "message": "ä¸Šä¸‹æ–‡ä¸¢å¤±"
            }
        
        # 4. è¿”å›ä¼šè¯çŠ¶æ€
        return {
            "status": "active",
            "session": session,
            "context": context_state,
            "message": "ä¼šè¯æ­£å¸¸"
        }
        
    except Exception as e:
        logger.error(f"æ£€æŸ¥ä¼šè¯çŠ¶æ€å¤±è´¥: {e}")
        return {
            "status": "error",
            "message": f"æ£€æŸ¥å¤±è´¥: {str(e)}"
        }
```

### 2. çŠ¶æ€æ¢å¤æµç¨‹

#### æ™ºèƒ½çŠ¶æ€æ¢å¤
```python
async def recover_conversation_state(user_id: str, session_id: str) -> Dict[str, Any]:
    """æ¢å¤å¯¹è¯çŠ¶æ€"""
    try:
        # 1. æ£€æŸ¥ä¼šè¯çŠ¶æ€
        session_status = await check_session_status(user_id, session_id)
        
        if session_status["status"] != "active":
            # ä¼šè¯ä¸å¯æ¢å¤ï¼Œåˆ›å»ºæ–°ä¼šè¯
            return await initialize_conversation(user_id, session_id, "")
        
        # 2. æ¢å¤ä¸Šä¸‹æ–‡
        context_state = session_status["context"]
        
        # 3. æ¢å¤Agentå®ä¾‹
        agent = await agent_manager.get_agent_instance(user_id, session_id)
        
        # 4. æ„å»ºæ¢å¤ä¿¡æ¯
        recovery_info = {
            "session_id": session_id,
            "thread_id": context_state.thread_id,
            "conversation_history": context_state.conversation_history,
            "current_step": context_state.current_step,
            "total_steps": context_state.total_steps,
            "status": "recovered",
            "timestamp": datetime.now().isoformat()
        }
        
        # 5. å‘é€æ¢å¤äº‹ä»¶
        yield StreamEvent(
            event_type=EventType.SYSTEM,
            agent_source="System",
            payload=EventPayload(
                content_type="recovery",
                data="ä¼šè¯çŠ¶æ€å·²æ¢å¤",
                metadata=recovery_info
            )
        )
        
        return recovery_info
        
    except Exception as e:
        logger.error(f"æ¢å¤å¯¹è¯çŠ¶æ€å¤±è´¥: {e}")
        raise
```

## å¤šè½®å¯¹è¯ä¼˜åŒ–

### 1. ä¸Šä¸‹æ–‡å‹ç¼©

#### æ™ºèƒ½ä¸Šä¸‹æ–‡å‹ç¼©
```python
class ContextCompressor:
    """ä¸Šä¸‹æ–‡å‹ç¼©å™¨"""
    
    def __init__(self, max_history_length: int = 50):
        self.max_history_length = max_history_length
    
    async def compress_conversation_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """å‹ç¼©å¯¹è¯å†å²"""
        if len(history) <= self.max_history_length:
            return history
        
        # ä¿ç•™æœ€æ–°çš„æ¶ˆæ¯
        recent_messages = history[-self.max_history_length:]
        
        # å¦‚æœæœ‰é‡è¦æ¶ˆæ¯ï¼ˆå¦‚ç³»ç»Ÿæ¶ˆæ¯ã€é”™è¯¯æ¶ˆæ¯ï¼‰ï¼Œä¼˜å…ˆä¿ç•™
        important_messages = [msg for msg in history if msg.get("role") in ["system", "error"]]
        
        # åˆå¹¶é‡è¦æ¶ˆæ¯å’Œæœ€æ–°æ¶ˆæ¯
        compressed_history = important_messages + recent_messages
        
        # å»é‡
        seen = set()
        unique_history = []
        for msg in compressed_history:
            msg_key = f"{msg.get('role')}:{msg.get('content', '')[:100]}"
            if msg_key not in seen:
                seen.add(msg_key)
                unique_history.append(msg)
        
        return unique_history
```

### 2. ä¼šè¯ç®¡ç†ä¼˜åŒ–

#### ä¼šè¯æ¸…ç†ç­–ç•¥
```python
class SessionCleanupManager:
    """ä¼šè¯æ¸…ç†ç®¡ç†å™¨"""
    
    def __init__(self):
        self.cleanup_interval = 3600  # 1å°æ—¶æ¸…ç†ä¸€æ¬¡
        self.session_ttl = 86400 * 7  # 7å¤©TTL
    
    async def cleanup_expired_sessions(self):
        """æ¸…ç†è¿‡æœŸä¼šè¯"""
        try:
            # è·å–æ‰€æœ‰ä¼šè¯
            all_sessions = await session_manager.get_all_sessions()
            
            current_time = datetime.now()
            expired_sessions = []
            
            for session in all_sessions:
                last_activity = datetime.fromisoformat(session["last_activity"])
                if current_time - last_activity > timedelta(seconds=self.session_ttl):
                    expired_sessions.append(session["session_id"])
            
            # æ‰¹é‡æ¸…ç†è¿‡æœŸä¼šè¯
            for session_id in expired_sessions:
                await self.cleanup_session(session_id)
            
            logger.info(f"æ¸…ç†äº† {len(expired_sessions)} ä¸ªè¿‡æœŸä¼šè¯")
            
        except Exception as e:
            logger.error(f"æ¸…ç†è¿‡æœŸä¼šè¯å¤±è´¥: {e}")
    
    async def cleanup_session(self, session_id: str):
        """æ¸…ç†å•ä¸ªä¼šè¯"""
        try:
            # 1. åˆ é™¤ä¼šè¯æ•°æ®
            await session_manager.delete_session(session_id)
            
            # 2. åˆ é™¤ä¸Šä¸‹æ–‡æ•°æ®
            await context_manager.delete_context(session_id)
            
            # 3. æ¸…ç†Agentå®ä¾‹
            await agent_manager.cleanup_agent_instance(session_id)
            
            logger.info(f"ä¼šè¯ {session_id} æ¸…ç†å®Œæˆ")
            
        except Exception as e:
            logger.error(f"æ¸…ç†ä¼šè¯ {session_id} å¤±è´¥: {e}")
```

## åº”ç”¨åœºæ™¯

### 1. å¤šè½®é—®ç­”

#### æ™ºèƒ½é—®ç­”æµç¨‹
```python
async def multi_turn_qa(user_id: str, session_id: str, question: str) -> AsyncGenerator[StreamEvent, None]:
    """å¤šè½®é—®ç­”å¤„ç†"""
    try:
        # 1. è·å–ä¸Šä¸‹æ–‡
        context_state = await context_manager.get_context(user_id, session_id)
        
        # 2. åˆ†æé—®é¢˜ç±»å‹
        question_type = await analyze_question_type(question, context_state)
        
        # 3. æ ¹æ®é—®é¢˜ç±»å‹é€‰æ‹©å¤„ç†ç­–ç•¥
        if question_type == "clarification":
            # æ¾„æ¸…é—®é¢˜
            yield await handle_clarification_question(question, context_state)
        elif question_type == "follow_up":
            # è·Ÿè¿›é—®é¢˜
            yield await handle_follow_up_question(question, context_state)
        elif question_type == "new_topic":
            # æ–°è¯é¢˜
            yield await handle_new_topic_question(question, context_state)
        else:
            # ä¸€èˆ¬é—®é¢˜
            yield await handle_general_question(question, context_state)
        
    except Exception as e:
        yield StreamEvent(
            event_type=EventType.ERROR,
            agent_source="QA",
            payload=EventPayload(content_type=None, data=f"é—®ç­”å¤„ç†å¤±è´¥: {str(e)}")
        )
```

### 2. ä»»åŠ¡åä½œ

#### å¤šAgentåä½œ
```python
async def multi_agent_collaboration(user_id: str, session_id: str, task: str) -> AsyncGenerator[StreamEvent, None]:
    """å¤šAgentåä½œå¤„ç†"""
    try:
        # 1. ä»»åŠ¡åˆ†è§£
        subtasks = await decompose_task(task)
        
        # 2. åˆ†é…Agent
        agent_assignments = await assign_agents_to_subtasks(subtasks)
        
        # 3. å¹¶è¡Œæ‰§è¡Œ
        results = await asyncio.gather(*[
            execute_subtask_with_agent(subtask, agent, user_id, session_id)
            for subtask, agent in agent_assignments
        ])
        
        # 4. ç»“æœæ•´åˆ
        final_result = await integrate_results(results)
        
        # 5. æµå¼è¿”å›ç»“æœ
        yield StreamEvent(
            event_type=EventType.AGENT_ACTION,
            agent_source="Collaboration",
            payload=EventPayload(
                content_type="task_result",
                data=final_result
            )
        )
        
    except Exception as e:
        yield StreamEvent(
            event_type=EventType.ERROR,
            agent_source="Collaboration",
            payload=EventPayload(content_type=None, data=f"åä½œå¤„ç†å¤±è´¥: {str(e)}")
        )
```

## æ€»ç»“

BluePlan Researchçš„å¤šè½®å¯¹è¯ç³»ç»Ÿå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### 1. æŠ€æœ¯ä¼˜åŠ¿
- **ä¸Šä¸‹æ–‡ç®¡ç†**: å®Œå–„çš„ä¼šè¯çŠ¶æ€å’Œå¯¹è¯å†å²ç®¡ç†
- **æµå¼å“åº”**: åŸºäºSSEçš„å®æ—¶æµå¼å“åº”
- **çŠ¶æ€æ¢å¤**: æ™ºèƒ½çš„æ–­çº¿é‡è¿å’ŒçŠ¶æ€æ¢å¤æœºåˆ¶
- **å¤šAgentåä½œ**: æ”¯æŒå¤šä¸ªAgentçš„åä½œå¯¹è¯

### 2. ä¸šåŠ¡ä»·å€¼
- **è‡ªç„¶å¯¹è¯**: æ”¯æŒè‡ªç„¶ã€è¿è´¯çš„å¤šè½®å¯¹è¯
- **æ™ºèƒ½ç†è§£**: åŸºäºä¸Šä¸‹æ–‡çš„æ™ºèƒ½ç†è§£èƒ½åŠ›
- **ä¸ªæ€§åŒ–ä½“éªŒ**: ä¸ªæ€§åŒ–çš„å¯¹è¯ä½“éªŒ
- **é«˜æ•ˆåä½œ**: å¤šAgentåä½œæå‡å¤„ç†æ•ˆç‡

### 3. ç³»ç»Ÿç‰¹ç‚¹
- **é«˜å¯ç”¨æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
- **å¯æ‰©å±•æ€§**: æ”¯æŒå¤§è§„æ¨¡å¹¶å‘å¯¹è¯
- **å®æ—¶æ€§**: æµå¼å“åº”æä¾›å®æ—¶åé¦ˆ
- **æŒä¹…åŒ–**: æ”¯æŒä¼šè¯çŠ¶æ€çš„æŒä¹…åŒ–å­˜å‚¨

å¤šè½®å¯¹è¯ç³»ç»Ÿä¸ºBluePlan Researchæä¾›äº†å¼ºå¤§çš„å¯¹è¯äº¤äº’èƒ½åŠ›ï¼Œæ˜¯ç³»ç»Ÿæ™ºèƒ½åŒ–çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸ºç”¨æˆ·æä¾›äº†è‡ªç„¶ã€æµç•…çš„å¯¹è¯ä½“éªŒã€‚
