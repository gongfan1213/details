# BluePlan Research 多轮对话实现分析

## 系统概述

BluePlan Research的多轮对话系统基于上下文管理、会话状态维护和流式响应技术，实现了智能、连贯的多轮对话体验。系统支持会话持久化、上下文传递、实时流式响应和智能状态恢复，为用户提供自然、流畅的对话交互。

## 技术架构

### 1. 多轮对话架构设计

#### 整体架构
```python
class MultiTurnDialogueSystem:
    """
    多轮对话系统架构
    
    核心组件：
    1. 上下文管理器 - 维护会话状态和对话历史
    2. 会话管理器 - 管理用户会话生命周期
    3. 流式响应器 - 实时推送对话内容
    4. 状态恢复器 - 处理断线重连和状态恢复
    """
    
    def __init__(self):
        self.context_manager = ContextManager()
        self.session_manager = SessionManager()
        self.streaming_responder = StreamingResponder()
        self.state_recovery = StateRecovery()
```

#### 会话生命周期管理
```python
class SessionLifecycle:
    """会话生命周期管理"""
    
    def __init__(self):
        self.session_states = {
            "created": "会话创建",
            "active": "活跃状态", 
            "paused": "暂停状态",
            "completed": "完成状态",
            "expired": "过期状态"
        }
    
    async def create_session(self, user_id: str, session_id: str) -> Dict[str, Any]:
        """创建新会话"""
        session_data = {
            "user_id": user_id,
            "session_id": session_id,
            "state": "created",
            "created_at": datetime.now().isoformat(),
            "last_activity": datetime.now().isoformat(),
            "conversation_history": [],
            "context_data": {}
        }
        
        # 保存到存储
        await self.save_session(session_data)
        return session_data
    
    async def update_session_activity(self, session_id: str):
        """更新会话活动时间"""
        session = await self.get_session(session_id)
        if session:
            session["last_activity"] = datetime.now().isoformat()
            session["state"] = "active"
            await self.save_session(session)
```

### 2. 上下文管理系统

#### Nova3上下文管理器
```python
@dataclass
class ContextState:
    """上下文状态数据结构"""
    session_id: str
    user_id: str
    thread_id: str
    current_step: int
    total_steps: int
    global_context: Dict[str, Any]  # 全局上下文
    agent_contexts: Dict[str, Any]  # 各agent的上下文
    shared_memory: Dict[str, Any]   # 共享内存
    conversation_history: List[Dict[str, Any]]  # 对话历史
    research_findings: Dict[str, Any]  # 研究发现
    created_at: str
    updated_at: str

class ContextManager:
    """多智能体上下文管理器"""
    
    def __init__(self):
        self.logger = BluePlanLogger("context_manager")
        self.redis_client = None
        self._context_cache: Dict[str, ContextState] = {}
    
    async def create_context(self, user_id: str, session_id: str, initial_query: str) -> ContextState:
        """创建新的上下文状态"""
        thread_id = str(uuid.uuid4())
        
        context_state = ContextState(
            session_id=session_id,
            user_id=user_id,
            thread_id=thread_id,
            current_step=0,
            total_steps=1,
            global_context={
                "initial_query": initial_query,
                "session_start_time": datetime.now().isoformat(),
                "workflow_type": "nova3_research"
            },
            agent_contexts={},
            shared_memory={},
            conversation_history=[{
                "role": "user",
                "content": initial_query,
                "timestamp": datetime.now().isoformat()
            }],
            research_findings={},
            created_at=datetime.now().isoformat(),
            updated_at=datetime.now().isoformat()
        )
        
        # 保存到Redis和缓存
        await self._save_context(context_state)
        self._context_cache[f"{user_id}:{session_id}"] = context_state
        
        return context_state
    
    async def add_conversation_message(self, user_id: str, session_id: str, role: str, content: str, agent_source: Optional[str] = None) -> bool:
        """添加对话消息到历史记录"""
        context_state = await self.get_context(user_id, session_id)
        if not context_state:
            return False
        
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat(),
            "agent_source": agent_source,
            "step": context_state.current_step
        }
        
        context_state.conversation_history.append(message)
        await self._save_context(context_state)
        self._context_cache[f"{user_id}:{session_id}"] = context_state
        
        return True
```

#### Loomi上下文管理器
```python
@dataclass
class LoomiContextState:
    """Loomi上下文状态数据结构"""
    session_id: str
    user_id: str
    thread_id: str
    
    # Loomi特有的上下文结构
    user_message_queue: List[Dict[str, Any]]  # 用户消息队列
    orchestrator_calls: List[Dict[str, Any]]  # orchestrator调用记录
    created_notes: List[Dict[str, Any]]  # 创建的notes
    
    # 通用上下文
    global_context: Dict[str, Any]  # 全局上下文
    agent_contexts: Dict[str, Any]  # 各agent的上下文
    shared_memory: Dict[str, Any]   # 共享内存
    conversation_history: List[Dict[str, Any]]  # 对话历史
    
    created_at: str
    updated_at: str

class LoomiContextManager:
    """Loomi多智能体上下文管理器"""
    
    async def create_context(self, user_id: str, session_id: str, initial_query: str) -> LoomiContextState:
        """创建新的上下文状态（支持持久化）"""
        # 首先尝试从数据库恢复现有上下文
        existing_context = await self._load_context_from_db(user_id, session_id)
        if existing_context:
            # 将新的查询添加到消息队列
            existing_context.user_message_queue.append({
                "content": initial_query,
                "timestamp": datetime.now().isoformat(),
                "is_new": True,
                "message_id": str(uuid.uuid4())
            })
            # 同时添加到对话历史
            existing_context.conversation_history.append({
                "role": "user",
                "content": initial_query,
                "timestamp": datetime.now().isoformat()
            })
            await self._save_context(existing_context)
            return existing_context
        
        # 创建新上下文
        thread_id = str(uuid.uuid4())
        context_state = LoomiContextState(
            session_id=session_id,
            user_id=user_id,
            thread_id=thread_id,
            user_message_queue=[{
                "content": initial_query,
                "timestamp": datetime.now().isoformat(),
                "is_new": True,
                "message_id": str(uuid.uuid4())
            }],
            orchestrator_calls=[],
            created_notes=[],
            global_context={
                "initial_query": initial_query,
                "session_start_time": datetime.now().isoformat(),
                "workflow_type": "loomi_content_creation"
            },
            agent_contexts={},
            shared_memory={},
            conversation_history=[{
                "role": "user",
                "content": initial_query,
                "timestamp": datetime.now().isoformat()
            }],
            created_at=datetime.now().isoformat(),
            updated_at=datetime.now().isoformat()
        )
        
        await self._save_context(context_state)
        return context_state
```

### 3. 上下文构建器

#### LoomiContextBuilder
```python
class LoomiContextBuilder:
    """Loomi上下文构建器"""
    
    async def build_concierge_context(self, user_id: str, session_id: str, current_user_message: str, user_selections: Optional[List[str]] = None) -> str:
        """为Concierge构建上下文"""
        parts = []
        
        try:
            # 🎯 【智能agent引用】如果user_selections有内容且消息不以@开头，自动添加引用
            if "@" not in current_user_message and user_selections and current_user_message and not current_user_message.strip().startswith('@'):
                current_user_message = f"@{user_selections[0]},{current_user_message}"
            
            # 1. [chat_history] - 对话历史，使用编号格式
            parts.append("[chat_history]")
            
            # 获取对话历史
            context_state = await loomi_context_manager.get_context(user_id, session_id)
            if context_state and context_state.conversation_history:
                # 检查当前消息是否是新的（还未记录在对话历史中）
                last_message = context_state.conversation_history[-1] if context_state.conversation_history else None
                is_new_message = True
                if last_message and last_message.get("role") == "user" and last_message.get("content", "").strip() == current_user_message.strip():
                    is_new_message = False
                
                # 格式化对话历史为编号格式
                for i, msg in enumerate(context_state.conversation_history, 1):
                    role = msg.get("role", "")
                    content = msg.get("content", "")
                    
                    if role == "user":
                        parts.append(f"#{i} **用户**: {content}")
                    elif role == "websearch":
                        parts.append(f"#{i} websearch:")
                        parts.append(content)
                    else:
                        parts.append(f"#{i} Loomi（你）: {content}")
                
                # 如果当前消息是新的，添加到末尾并标记(新)
                if is_new_message:
                    next_num = len(context_state.conversation_history) + 1
                    parts.append(f"#{next_num} **(新) 用户**: {current_user_message}")
            else:
                # 首次对话，当前消息是新的
                parts.append(f"#1 **(新) 用户**: {current_user_message}")
            
            # 2. [notes] - 已创建的notes
            parts.append("\n[notes]")
            if context_state and context_state.created_notes:
                for i, note in enumerate(context_state.created_notes, 1):
                    note_name = note.get("name", f"note_{i}")
                    note_content = note.get("context", "")
                    parts.append(f"@{note_name}: {note_content}")
            else:
                parts.append("暂无已创建的notes")
            
            # 3. [instructions] - 系统指令
            parts.append("\n[instructions]")
            parts.append("你是Loomi，一个专业的社交媒体内容创作助手。")
            parts.append("请根据用户的请求，创建相应的notes或执行相关操作。")
            
            return "\n".join(parts)
            
        except Exception as e:
            self.logger.error(f"构建Concierge上下文失败: {e}")
            return f"用户消息: {current_user_message}"
```

## 流式响应实现

### 1. Server-Sent Events (SSE) 架构

#### SSE服务器实现
```python
from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse
import asyncio
import json

class SSEServer:
    def __init__(self):
        self.app = FastAPI()
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.post("/novachat")
        async def novachat_stream(request: Request):
            """Nova3模式的流式聊天接口"""
            return StreamingResponse(
                self.generate_nova3_stream(request),
                media_type="text/event-stream",
                headers={
                    "Cache-Control": "no-cache",
                    "Connection": "keep-alive",
                    "Access-Control-Allow-Origin": "*",
                    "Access-Control-Allow-Headers": "*"
                }
            )
        
        @self.app.post("/loomichat")
        async def loomichat_stream(request: Request):
            """Loomi模式的流式聊天接口"""
            return StreamingResponse(
                self.generate_loomi_stream(request),
                media_type="text/event-stream"
            )
```

#### Nova3流式响应生成器
```python
async def novachat_stream_generator(request: ChatRequest) -> AsyncGenerator[str, None]:
    """Nova3聊天流式响应生成器"""
    try:
        # 发送开始事件
        start_event = StreamEvent(
            event_type=EventType.SYSTEM,
            agent_source="Nova3",
            payload=EventPayload(content_type=None, data="Nova3 智能编排系统已连接，开始分析您的需求...")
        )
        yield f"{start_event.model_dump_json()}\n\n"
        
        # 使用会话级agent实例，避免全局状态混乱
        nova3 = await session_agent_manager.get_nova3_supervisor(request.user_id, request.session_id)
        
        # 构建请求数据
        nova3_request: Dict[str, Any] = {
            "query": request.request_data.query,
            "user_id": request.user_id,
            "session_id": request.session_id,
            "timestamp": datetime.now().isoformat()
        }
        
        # 添加session信息到context
        context = {
            "user_id": request.user_id,
            "session_id": request.session_id,
            "timestamp": datetime.now().isoformat()
        }
        
        async for event in nova3.process_request(nova3_request, context):
            # 确保事件格式符合流式协议
            if isinstance(event, dict):
                # 转换为StreamEvent格式
                stream_event = StreamEvent(
                    event_type=EventType(event.get("event_type", "system")),
                    agent_source=event.get("agent_source", "Nova3"),
                    timestamp=event.get("timestamp", datetime.now().isoformat()),
                    payload=EventPayload(
                        content_type=event.get("payload", {}).get("content_type"),
                        data=event.get("payload", {}).get("data", ""),
                        metadata=event.get("payload", {}).get("metadata", {})
                    )
                )
                yield f"{stream_event.model_dump_json()}\n\n"
            else:
                # 如果已经是StreamEvent对象
                yield f"{event.model_dump_json()}\n\n"
        
        # 流式输出结束，发送DONE标记
        yield "[DONE]\n\n"
            
    except Exception as e:
        # 发送错误事件
        error_event = StreamEvent(
            event_type=EventType.ERROR,
            agent_source="Nova3",
            payload=EventPayload(content_type=None, data=f"处理失败: {str(e)}")
        )
        yield f"{error_event.model_dump_json()}\n\n"
        yield "[DONE]\n\n"
```

#### Loomi流式响应生成器
```python
async def loomichat_stream_generator(request: ChatRequest) -> AsyncGenerator[str, None]:
    """Loomi聊天流式响应生成器"""
    try:
        # 记录流式处理开始日志
        query = request.request_data.query.strip() if request.request_data.query else ""
        auto_mode = getattr(request.request_data, 'auto', False)
        
        # 发送开始事件
        start_event = StreamEvent(
            event_type=EventType.SYSTEM,
            agent_source="Loomi",
            payload=EventPayload(content_type=None, data="Loomi 智能接待员已连接，开始分析您的需求...")
        )
        yield f"{start_event.model_dump_json()}\n\n"
        
        # 使用会话级agent实例，避免全局状态混乱
        loomi_concierge = await session_agent_manager.get_loomi_concierge(request.user_id, request.session_id)
        
        # 构建Concierge请求
        concierge_request = {
            "user_id": request.user_id,
            "session_id": request.session_id,
            "query": query,
            "auto_mode": auto_mode,
            "user_selections": getattr(request.request_data, 'user_selections', []),
            "timestamp": datetime.now().isoformat()
        }
        
        # 流式处理
        async for event in loomi_concierge.process_request(concierge_request):
            # 检查事件类型：StreamEvent对象或字符串
            if isinstance(event, str):
                # 如果是字符串，直接yield
                yield event
            else:
                # 如果是StreamEvent对象，调用model_dump_json()
                yield f"{event.model_dump_json()}\n\n"
        
        # 发送完成事件
        end_event = StreamEvent(
            event_type=EventType.SYSTEM,
            agent_source="Loomi",
            payload=EventPayload(content_type=None, data="Loomi 处理完成")
        )
        yield f"{end_event.model_dump_json()}\n\n"
        yield "[DONE]\n\n"
        
    except Exception as e:
        # 发送错误事件
        error_event = StreamEvent(
            event_type=EventType.ERROR,
            agent_source="Loomi",
            payload=EventPayload(content_type=None, data=f"Loomi处理失败: {str(e)}")
        )
        yield f"{error_event.model_dump_json()}\n\n"
        yield "[DONE]\n\n"
```

### 2. 事件类型定义

#### 标准事件结构
```python
@dataclass
class StreamEvent:
    """流式事件结构"""
    event_type: EventType
    agent_source: str
    timestamp: str
    payload: EventPayload

@dataclass
class EventPayload:
    """事件载荷"""
    content_type: Optional[str]
    data: str
    metadata: Optional[Dict[str, Any]] = None

class EventType(str, Enum):
    """事件类型枚举"""
    SYSTEM = "system"           # 系统事件
    LLM_CHUNK = "llm_chunk"     # LLM流式输出
    AGENT_ACTION = "agent_action"  # Agent动作
    TOOL_CALL = "tool_call"     # 工具调用
    ERROR = "error"             # 错误事件
    COMPLETE = "complete"       # 完成事件
```

## 多轮对话流程

### 1. 对话初始化流程

#### 会话创建
```python
async def initialize_conversation(user_id: str, session_id: str, initial_query: str) -> Dict[str, Any]:
    """初始化对话会话"""
    try:
        # 1. 创建会话
        session_data = await session_manager.create_session(user_id, session_id)
        
        # 2. 创建上下文
        context_state = await context_manager.create_context(
            user_id=user_id,
            session_id=session_id,
            initial_query=initial_query
        )
        
        # 3. 初始化Agent实例
        agent_instance = await agent_manager.get_agent_instance(user_id, session_id)
        
        # 4. 返回初始化结果
        return {
            "session_id": session_id,
            "thread_id": context_state.thread_id,
            "status": "initialized",
            "timestamp": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"对话初始化失败: {e}")
        raise
```

### 2. 对话消息处理流程

#### 消息接收和处理
```python
async def process_conversation_message(user_id: str, session_id: str, message: str) -> AsyncGenerator[StreamEvent, None]:
    """处理对话消息"""
    try:
        # 1. 获取或恢复上下文
        context_state = await context_manager.get_context(user_id, session_id)
        if not context_state:
            # 创建新上下文
            context_state = await context_manager.create_context(
                user_id=user_id,
                session_id=session_id,
                initial_query=message
            )
            yield StreamEvent(
                event_type=EventType.SYSTEM,
                agent_source="System",
                payload=EventPayload(content_type=None, data="新会话已创建")
            )
        else:
            # 添加用户消息到历史
            await context_manager.add_conversation_message(
                user_id=user_id,
                session_id=session_id,
                role="user",
                content=message
            )
        
        # 2. 获取Agent实例
        agent = await agent_manager.get_agent_instance(user_id, session_id)
        
        # 3. 构建请求数据
        request_data = {
            "query": message,
            "user_id": user_id,
            "session_id": session_id,
            "context": context_state,
            "timestamp": datetime.now().isoformat()
        }
        
        # 4. 流式处理请求
        async for event in agent.process_request(request_data):
            yield event
            
            # 如果是Agent回复，添加到对话历史
            if event.event_type == EventType.AGENT_ACTION and event.payload.content_type == "response":
                await context_manager.add_conversation_message(
                    user_id=user_id,
                    session_id=session_id,
                    role="assistant",
                    content=event.payload.data,
                    agent_source=event.agent_source
                )
        
        # 5. 发送完成事件
        yield StreamEvent(
            event_type=EventType.COMPLETE,
            agent_source="System",
            payload=EventPayload(content_type=None, data="消息处理完成")
        )
        
    except Exception as e:
        # 发送错误事件
        yield StreamEvent(
            event_type=EventType.ERROR,
            agent_source="System",
            payload=EventPayload(content_type=None, data=f"处理失败: {str(e)}")
        )
```

### 3. 上下文传递机制

#### 智能上下文传递
```python
class ContextPassingManager:
    """上下文传递管理器"""
    
    async def build_context_for_agent(self, agent_name: str, context_state: ContextState, current_query: str) -> str:
        """为特定Agent构建上下文"""
        if agent_name == "concierge":
            return await self._build_concierge_context(context_state, current_query)
        elif agent_name == "orchestrator":
            return await self._build_orchestrator_context(context_state, current_query)
        elif agent_name == "supervisor":
            return await self._build_supervisor_context(context_state, current_query)
        else:
            return await self._build_generic_context(context_state, current_query)
    
    async def _build_concierge_context(self, context_state: ContextState, current_query: str) -> str:
        """构建Concierge上下文"""
        parts = []
        
        # 1. 对话历史
        parts.append("[chat_history]")
        for i, msg in enumerate(context_state.conversation_history, 1):
            role = msg.get("role", "")
            content = msg.get("content", "")
            if role == "user":
                parts.append(f"#{i} **用户**: {content}")
            else:
                parts.append(f"#{i} **助手**: {content}")
        
        # 2. 当前查询
        parts.append(f"\n[当前查询]")
        parts.append(f"用户: {current_query}")
        
        # 3. 系统指令
        parts.append(f"\n[指令]")
        parts.append("你是Loomi的智能接待员，请理解用户需求并创建相应的notes。")
        
        return "\n".join(parts)
```

## 状态恢复机制

### 1. 断线重连处理

#### 会话状态检查
```python
async def check_session_status(user_id: str, session_id: str) -> Dict[str, Any]:
    """检查会话状态"""
    try:
        # 1. 检查会话是否存在
        session = await session_manager.get_session(session_id)
        if not session:
            return {
                "status": "not_found",
                "message": "会话不存在"
            }
        
        # 2. 检查会话是否过期
        last_activity = datetime.fromisoformat(session["last_activity"])
        if datetime.now() - last_activity > timedelta(hours=24):
            return {
                "status": "expired",
                "message": "会话已过期"
            }
        
        # 3. 检查上下文状态
        context_state = await context_manager.get_context(user_id, session_id)
        if not context_state:
            return {
                "status": "context_missing",
                "message": "上下文丢失"
            }
        
        # 4. 返回会话状态
        return {
            "status": "active",
            "session": session,
            "context": context_state,
            "message": "会话正常"
        }
        
    except Exception as e:
        logger.error(f"检查会话状态失败: {e}")
        return {
            "status": "error",
            "message": f"检查失败: {str(e)}"
        }
```

### 2. 状态恢复流程

#### 智能状态恢复
```python
async def recover_conversation_state(user_id: str, session_id: str) -> Dict[str, Any]:
    """恢复对话状态"""
    try:
        # 1. 检查会话状态
        session_status = await check_session_status(user_id, session_id)
        
        if session_status["status"] != "active":
            # 会话不可恢复，创建新会话
            return await initialize_conversation(user_id, session_id, "")
        
        # 2. 恢复上下文
        context_state = session_status["context"]
        
        # 3. 恢复Agent实例
        agent = await agent_manager.get_agent_instance(user_id, session_id)
        
        # 4. 构建恢复信息
        recovery_info = {
            "session_id": session_id,
            "thread_id": context_state.thread_id,
            "conversation_history": context_state.conversation_history,
            "current_step": context_state.current_step,
            "total_steps": context_state.total_steps,
            "status": "recovered",
            "timestamp": datetime.now().isoformat()
        }
        
        # 5. 发送恢复事件
        yield StreamEvent(
            event_type=EventType.SYSTEM,
            agent_source="System",
            payload=EventPayload(
                content_type="recovery",
                data="会话状态已恢复",
                metadata=recovery_info
            )
        )
        
        return recovery_info
        
    except Exception as e:
        logger.error(f"恢复对话状态失败: {e}")
        raise
```

## 多轮对话优化

### 1. 上下文压缩

#### 智能上下文压缩
```python
class ContextCompressor:
    """上下文压缩器"""
    
    def __init__(self, max_history_length: int = 50):
        self.max_history_length = max_history_length
    
    async def compress_conversation_history(self, history: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """压缩对话历史"""
        if len(history) <= self.max_history_length:
            return history
        
        # 保留最新的消息
        recent_messages = history[-self.max_history_length:]
        
        # 如果有重要消息（如系统消息、错误消息），优先保留
        important_messages = [msg for msg in history if msg.get("role") in ["system", "error"]]
        
        # 合并重要消息和最新消息
        compressed_history = important_messages + recent_messages
        
        # 去重
        seen = set()
        unique_history = []
        for msg in compressed_history:
            msg_key = f"{msg.get('role')}:{msg.get('content', '')[:100]}"
            if msg_key not in seen:
                seen.add(msg_key)
                unique_history.append(msg)
        
        return unique_history
```

### 2. 会话管理优化

#### 会话清理策略
```python
class SessionCleanupManager:
    """会话清理管理器"""
    
    def __init__(self):
        self.cleanup_interval = 3600  # 1小时清理一次
        self.session_ttl = 86400 * 7  # 7天TTL
    
    async def cleanup_expired_sessions(self):
        """清理过期会话"""
        try:
            # 获取所有会话
            all_sessions = await session_manager.get_all_sessions()
            
            current_time = datetime.now()
            expired_sessions = []
            
            for session in all_sessions:
                last_activity = datetime.fromisoformat(session["last_activity"])
                if current_time - last_activity > timedelta(seconds=self.session_ttl):
                    expired_sessions.append(session["session_id"])
            
            # 批量清理过期会话
            for session_id in expired_sessions:
                await self.cleanup_session(session_id)
            
            logger.info(f"清理了 {len(expired_sessions)} 个过期会话")
            
        except Exception as e:
            logger.error(f"清理过期会话失败: {e}")
    
    async def cleanup_session(self, session_id: str):
        """清理单个会话"""
        try:
            # 1. 删除会话数据
            await session_manager.delete_session(session_id)
            
            # 2. 删除上下文数据
            await context_manager.delete_context(session_id)
            
            # 3. 清理Agent实例
            await agent_manager.cleanup_agent_instance(session_id)
            
            logger.info(f"会话 {session_id} 清理完成")
            
        except Exception as e:
            logger.error(f"清理会话 {session_id} 失败: {e}")
```

## 应用场景

### 1. 多轮问答

#### 智能问答流程
```python
async def multi_turn_qa(user_id: str, session_id: str, question: str) -> AsyncGenerator[StreamEvent, None]:
    """多轮问答处理"""
    try:
        # 1. 获取上下文
        context_state = await context_manager.get_context(user_id, session_id)
        
        # 2. 分析问题类型
        question_type = await analyze_question_type(question, context_state)
        
        # 3. 根据问题类型选择处理策略
        if question_type == "clarification":
            # 澄清问题
            yield await handle_clarification_question(question, context_state)
        elif question_type == "follow_up":
            # 跟进问题
            yield await handle_follow_up_question(question, context_state)
        elif question_type == "new_topic":
            # 新话题
            yield await handle_new_topic_question(question, context_state)
        else:
            # 一般问题
            yield await handle_general_question(question, context_state)
        
    except Exception as e:
        yield StreamEvent(
            event_type=EventType.ERROR,
            agent_source="QA",
            payload=EventPayload(content_type=None, data=f"问答处理失败: {str(e)}")
        )
```

### 2. 任务协作

#### 多Agent协作
```python
async def multi_agent_collaboration(user_id: str, session_id: str, task: str) -> AsyncGenerator[StreamEvent, None]:
    """多Agent协作处理"""
    try:
        # 1. 任务分解
        subtasks = await decompose_task(task)
        
        # 2. 分配Agent
        agent_assignments = await assign_agents_to_subtasks(subtasks)
        
        # 3. 并行执行
        results = await asyncio.gather(*[
            execute_subtask_with_agent(subtask, agent, user_id, session_id)
            for subtask, agent in agent_assignments
        ])
        
        # 4. 结果整合
        final_result = await integrate_results(results)
        
        # 5. 流式返回结果
        yield StreamEvent(
            event_type=EventType.AGENT_ACTION,
            agent_source="Collaboration",
            payload=EventPayload(
                content_type="task_result",
                data=final_result
            )
        )
        
    except Exception as e:
        yield StreamEvent(
            event_type=EventType.ERROR,
            agent_source="Collaboration",
            payload=EventPayload(content_type=None, data=f"协作处理失败: {str(e)}")
        )
```

## 总结

BluePlan Research的多轮对话系统具有以下特点：

### 1. 技术优势
- **上下文管理**: 完善的会话状态和对话历史管理
- **流式响应**: 基于SSE的实时流式响应
- **状态恢复**: 智能的断线重连和状态恢复机制
- **多Agent协作**: 支持多个Agent的协作对话

### 2. 业务价值
- **自然对话**: 支持自然、连贯的多轮对话
- **智能理解**: 基于上下文的智能理解能力
- **个性化体验**: 个性化的对话体验
- **高效协作**: 多Agent协作提升处理效率

### 3. 系统特点
- **高可用性**: 完善的错误处理和恢复机制
- **可扩展性**: 支持大规模并发对话
- **实时性**: 流式响应提供实时反馈
- **持久化**: 支持会话状态的持久化存储

多轮对话系统为BluePlan Research提供了强大的对话交互能力，是系统智能化的重要组成部分，为用户提供了自然、流畅的对话体验。
