# 配置管理与环境适配系统

## 功能概述

BluePlan Research的配置管理与环境适配系统是一个高度灵活和可扩展的配置管理解决方案。系统支持多环境配置、动态配置更新、配置验证和安全管理，确保系统在不同部署环境下都能稳定运行。

## 技术方案支撑

### 1. 多环境配置管理

#### 环境配置文件结构
```python
# config/settings.py
from pydantic import BaseSettings, Field
from typing import Optional, Dict, Any
import os

class Settings(BaseSettings):
    """应用配置类"""
    
    # 基础配置
    app_name: str = Field(default="BluePlan Research", env="APP_NAME")
    debug: bool = Field(default=False, env="DEBUG")
    log_level: str = Field(default="INFO", env="LOG_LEVEL")
    
    # LLM配置
    llm_provider: str = Field(default="openai", env="LLM_PROVIDER")
    llm_api_key: str = Field(env="LLM_API_KEY")
    llm_base_url: str = Field(env="LLM_BASE_URL")
    llm_model: str = Field(default="gemini-2.5-pro", env="LLM_MODEL")
    llm_temperature: float = Field(default=0.7, env="LLM_TEMPERATURE")
    llm_max_tokens: int = Field(default=4096, env="LLM_MAX_TOKENS")
    
    # Redis配置
    redis_host: str = Field(env="REDIS_HOST")
    redis_port: int = Field(default=6379, env="REDIS_PORT")
    redis_password: Optional[str] = Field(default=None, env="REDIS_PASSWORD")
    redis_db: int = Field(default=0, env="REDIS_DB")
    
    # 数据库配置
    database_url: str = Field(env="DATABASE_URL")
    database_pool_size: int = Field(default=10, env="DATABASE_POOL_SIZE")
    
    # 搜索配置
    jina_api_key: str = Field(env="JINA_API_KEY")
    jina_base_url: str = Field(default="https://r.jina.ai/", env="JINA_BASE_URL")
    
    # 安全配置
    secret_key: str = Field(env="SECRET_KEY")
    access_token_expire_minutes: int = Field(default=30, env="ACCESS_TOKEN_EXPIRE_MINUTES")
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
        case_sensitive = False

# 全局配置实例
settings = Settings()
```

#### 环境配置文件管理
```python
# config_manager.py
import os
import yaml
import json
from pathlib import Path
from typing import Dict, Any, Optional

class ConfigManager:
    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
        self.config_cache = {}
        self.load_all_configs()
    
    def load_all_configs(self):
        """加载所有配置文件"""
        # 加载YAML配置文件
        yaml_files = self.config_dir.glob("*.yaml")
        for yaml_file in yaml_files:
            self.load_yaml_config(yaml_file)
        
        # 加载JSON配置文件
        json_files = self.config_dir.glob("*.json")
        for json_file in json_files:
            self.load_json_config(json_file)
    
    def load_yaml_config(self, file_path: Path):
        """加载YAML配置文件"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                config_data = yaml.safe_load(f)
                config_name = file_path.stem
                self.config_cache[config_name] = config_data
        except Exception as e:
            print(f"加载YAML配置文件失败: {file_path}, 错误: {e}")
    
    def load_json_config(self, file_path: Path):
        """加载JSON配置文件"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                config_data = json.load(f)
                config_name = file_path.stem
                self.config_cache[config_name] = config_data
        except Exception as e:
            print(f"加载JSON配置文件失败: {file_path}, 错误: {e}")
    
    def get_config(self, config_name: str) -> Optional[Dict[str, Any]]:
        """获取指定配置"""
        return self.config_cache.get(config_name)
    
    def update_config(self, config_name: str, config_data: Dict[str, Any]):
        """更新配置"""
        self.config_cache[config_name] = config_data
        self.save_config(config_name, config_data)
    
    def save_config(self, config_name: str, config_data: Dict[str, Any]):
        """保存配置到文件"""
        file_path = self.config_dir / f"{config_name}.yaml"
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                yaml.dump(config_data, f, default_flow_style=False, allow_unicode=True)
        except Exception as e:
            print(f"保存配置文件失败: {file_path}, 错误: {e}")
```

### 2. 动态配置更新

#### 配置热更新机制
```python
class HotConfigManager:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.config_key_prefix = "config:"
        self.watchers = {}
    
    async def set_config(self, config_name: str, config_data: Dict[str, Any]):
        """设置配置"""
        key = f"{self.config_key_prefix}{config_name}"
        await self.redis.set(key, json.dumps(config_data))
        
        # 通知配置变更
        await self.notify_config_change(config_name, config_data)
    
    async def get_config(self, config_name: str) -> Optional[Dict[str, Any]]:
        """获取配置"""
        key = f"{self.config_key_prefix}{config_name}"
        config_str = await self.redis.get(key)
        if config_str:
            return json.loads(config_str)
        return None
    
    async def watch_config(self, config_name: str, callback):
        """监听配置变更"""
        if config_name not in self.watchers:
            self.watchers[config_name] = []
        self.watchers[config_name].append(callback)
    
    async def notify_config_change(self, config_name: str, config_data: Dict[str, Any]):
        """通知配置变更"""
        if config_name in self.watchers:
            for callback in self.watchers[config_name]:
                try:
                    await callback(config_name, config_data)
                except Exception as e:
                    print(f"配置变更通知失败: {e}")
```

#### 配置验证器
```python
from pydantic import BaseModel, validator
from typing import List, Optional

class LLMConfig(BaseModel):
    """LLM配置验证模型"""
    provider: str
    api_key: str
    base_url: str
    model: str
    temperature: float = 0.7
    max_tokens: int = 4096
    
    @validator('temperature')
    def validate_temperature(cls, v):
        if not 0 <= v <= 2:
            raise ValueError('temperature必须在0-2之间')
        return v
    
    @validator('max_tokens')
    def validate_max_tokens(cls, v):
        if v <= 0:
            raise ValueError('max_tokens必须大于0')
        return v

class RedisConfig(BaseModel):
    """Redis配置验证模型"""
    host: str
    port: int = 6379
    password: Optional[str] = None
    db: int = 0
    
    @validator('port')
    def validate_port(cls, v):
        if not 1 <= v <= 65535:
            raise ValueError('port必须在1-65535之间')
        return v

class ConfigValidator:
    def __init__(self):
        self.validators = {
            'llm': LLMConfig,
            'redis': RedisConfig
        }
    
    def validate_config(self, config_type: str, config_data: Dict[str, Any]):
        """验证配置"""
        if config_type in self.validators:
            validator_class = self.validators[config_type]
            return validator_class(**config_data)
        else:
            raise ValueError(f"未知的配置类型: {config_type}")
```

### 3. 环境适配器

#### 环境检测与适配
```python
class EnvironmentAdapter:
    def __init__(self):
        self.current_env = self.detect_environment()
        self.env_configs = self.load_environment_configs()
    
    def detect_environment(self) -> str:
        """检测当前环境"""
        env = os.getenv("ENVIRONMENT", "development")
        
        # 根据环境变量判断
        if os.getenv("PRODUCTION"):
            return "production"
        elif os.getenv("STAGING"):
            return "staging"
        elif os.getenv("TESTING"):
            return "testing"
        else:
            return env
    
    def load_environment_configs(self) -> Dict[str, Dict[str, Any]]:
        """加载环境配置"""
        configs = {
            "development": {
                "debug": True,
                "log_level": "DEBUG",
                "database_pool_size": 5,
                "cache_ttl": 300
            },
            "staging": {
                "debug": False,
                "log_level": "INFO",
                "database_pool_size": 10,
                "cache_ttl": 600
            },
            "production": {
                "debug": False,
                "log_level": "WARNING",
                "database_pool_size": 20,
                "cache_ttl": 1800
            }
        }
        return configs
    
    def get_env_config(self) -> Dict[str, Any]:
        """获取当前环境配置"""
        return self.env_configs.get(self.current_env, {})
    
    def adapt_config(self, base_config: Dict[str, Any]) -> Dict[str, Any]:
        """适配配置到当前环境"""
        env_config = self.get_env_config()
        adapted_config = base_config.copy()
        adapted_config.update(env_config)
        return adapted_config
```

## 业务功能实现

### 1. 多环境部署支持

#### 功能特性
- **环境隔离**: 不同环境的配置完全隔离
- **配置继承**: 支持配置的继承和覆盖
- **环境切换**: 支持动态环境切换
- **配置验证**: 环境配置的自动验证

#### 实现示例
```python
class MultiEnvironmentManager:
    def __init__(self):
        self.environments = ["development", "staging", "production"]
        self.current_env = None
        self.configs = {}
    
    def switch_environment(self, env_name: str):
        """切换环境"""
        if env_name not in self.environments:
            raise ValueError(f"不支持的环境: {env_name}")
        
        self.current_env = env_name
        self.load_environment_config(env_name)
    
    def load_environment_config(self, env_name: str):
        """加载环境配置"""
        config_file = f"config/{env_name}.yaml"
        if os.path.exists(config_file):
            with open(config_file, 'r', encoding='utf-8') as f:
                self.configs[env_name] = yaml.safe_load(f)
        else:
            # 使用默认配置
            self.configs[env_name] = self.get_default_config(env_name)
    
    def get_config(self, key: str, default=None):
        """获取配置值"""
        if self.current_env and self.current_env in self.configs:
            return self.configs[self.current_env].get(key, default)
        return default
    
    def get_default_config(self, env_name: str) -> Dict[str, Any]:
        """获取默认配置"""
        defaults = {
            "development": {
                "debug": True,
                "log_level": "DEBUG",
                "database_url": "sqlite:///dev.db"
            },
            "staging": {
                "debug": False,
                "log_level": "INFO",
                "database_url": "postgresql://staging:pass@localhost/staging"
            },
            "production": {
                "debug": False,
                "log_level": "WARNING",
                "database_url": "postgresql://prod:pass@localhost/prod"
            }
        }
        return defaults.get(env_name, {})
```

### 2. 配置安全管理

#### 功能特性
- **敏感信息加密**: 自动加密敏感配置信息
- **访问控制**: 基于角色的配置访问控制
- **审计日志**: 配置变更的审计日志
- **密钥轮换**: 支持密钥的定期轮换

#### 实现示例
```python
from cryptography.fernet import Fernet
import base64

class SecureConfigManager:
    def __init__(self, encryption_key: str = None):
        if encryption_key:
            self.cipher = Fernet(encryption_key.encode())
        else:
            # 生成新的加密密钥
            key = Fernet.generate_key()
            self.cipher = Fernet(key)
        
        self.sensitive_keys = [
            "api_key", "password", "secret_key", "token"
        ]
    
    def encrypt_value(self, value: str) -> str:
        """加密敏感值"""
        if not value:
            return value
        
        encrypted = self.cipher.encrypt(value.encode())
        return base64.b64encode(encrypted).decode()
    
    def decrypt_value(self, encrypted_value: str) -> str:
        """解密敏感值"""
        if not encrypted_value:
            return encrypted_value
        
        try:
            encrypted_bytes = base64.b64decode(encrypted_value.encode())
            decrypted = self.cipher.decrypt(encrypted_bytes)
            return decrypted.decode()
        except Exception as e:
            print(f"解密失败: {e}")
            return encrypted_value
    
    def secure_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """安全化配置"""
        secured_config = {}
        
        for key, value in config.items():
            if any(sensitive in key.lower() for sensitive in self.sensitive_keys):
                # 加密敏感信息
                secured_config[key] = self.encrypt_value(str(value))
            else:
                secured_config[key] = value
        
        return secured_config
    
    def load_secure_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """加载安全配置"""
        loaded_config = {}
        
        for key, value in config.items():
            if any(sensitive in key.lower() for sensitive in self.sensitive_keys):
                # 解密敏感信息
                loaded_config[key] = self.decrypt_value(str(value))
            else:
                loaded_config[key] = value
        
        return loaded_config
```

### 3. 配置监控与告警

#### 功能特性
- **配置监控**: 实时监控配置变更
- **异常检测**: 检测配置异常和错误
- **告警通知**: 配置异常的告警通知
- **配置备份**: 自动配置备份和恢复

#### 实现示例
```python
from datetime import datetime

class ConfigMonitor:
    def __init__(self, alert_manager):
        self.alert_manager = alert_manager
        self.config_history = []
        self.monitoring_rules = self.load_monitoring_rules()
    
    def monitor_config_change(self, config_name: str, old_config: Dict, new_config: Dict):
        """监控配置变更"""
        # 记录配置历史
        self.config_history.append({
            "timestamp": datetime.now(),
            "config_name": config_name,
            "old_config": old_config,
            "new_config": new_config
        })
        
        # 检查配置变更
        self.check_config_changes(config_name, old_config, new_config)
    
    def check_config_changes(self, config_name: str, old_config: Dict, new_config: Dict):
        """检查配置变更"""
        for rule in self.monitoring_rules:
            if rule["config_name"] == config_name:
                self.apply_monitoring_rule(rule, old_config, new_config)
    
    def apply_monitoring_rule(self, rule: Dict, old_config: Dict, new_config: Dict):
        """应用监控规则"""
        rule_type = rule.get("type")
        
        if rule_type == "value_change":
            self.check_value_change(rule, old_config, new_config)
        elif rule_type == "required_field":
            self.check_required_field(rule, new_config)
        elif rule_type == "value_range":
            self.check_value_range(rule, new_config)
    
    def check_value_change(self, rule: Dict, old_config: Dict, new_config: Dict):
        """检查值变更"""
        field = rule.get("field")
        if field in old_config and field in new_config:
            if old_config[field] != new_config[field]:
                self.send_alert(f"配置字段 {field} 发生变更", {
                    "old_value": old_config[field],
                    "new_value": new_config[field]
                })
    
    def check_required_field(self, rule: Dict, config: Dict):
        """检查必需字段"""
        required_fields = rule.get("fields", [])
        missing_fields = [field for field in required_fields if field not in config]
        
        if missing_fields:
            self.send_alert(f"缺少必需配置字段: {missing_fields}", config)
    
    def check_value_range(self, rule: Dict, config: Dict):
        """检查值范围"""
        field = rule.get("field")
        min_value = rule.get("min_value")
        max_value = rule.get("max_value")
        
        if field in config:
            value = config[field]
            if min_value is not None and value < min_value:
                self.send_alert(f"配置字段 {field} 值 {value} 小于最小值 {min_value}", config)
            if max_value is not None and value > max_value:
                self.send_alert(f"配置字段 {field} 值 {value} 大于最大值 {max_value}", config)
    
    def send_alert(self, message: str, context: Dict):
        """发送告警"""
        alert_data = {
            "type": "config_alert",
            "message": message,
            "context": context,
            "timestamp": datetime.now().isoformat()
        }
        
        self.alert_manager.send_alert(alert_data)
```

## 常见问题与解决方案

### 1. 配置冲突问题

#### 问题描述
不同环境的配置可能存在冲突，导致系统运行异常。

#### 解决方案
- **配置优先级**: 建立明确的配置优先级规则
- **配置验证**: 在加载配置时进行验证
- **冲突检测**: 自动检测配置冲突
- **配置合并**: 智能合并配置

### 2. 敏感信息泄露

#### 问题描述
配置文件中的敏感信息可能被意外泄露。

#### 解决方案
- **环境变量**: 使用环境变量存储敏感信息
- **配置加密**: 对敏感配置进行加密
- **访问控制**: 严格控制配置文件的访问权限
- **审计日志**: 记录配置访问日志

### 3. 配置更新同步

#### 问题描述
多实例部署时配置更新可能不同步。

#### 解决方案
- **集中配置**: 使用集中配置管理
- **配置推送**: 主动推送配置更新
- **版本控制**: 配置版本控制
- **回滚机制**: 配置回滚机制

## 系统设计优势

### 1. 灵活性
- **多环境支持**: 支持多种部署环境
- **动态配置**: 支持运行时配置更新
- **配置继承**: 支持配置的继承和覆盖
- **插件机制**: 支持配置插件扩展

### 2. 安全性
- **敏感信息保护**: 自动保护敏感配置信息
- **访问控制**: 严格的配置访问控制
- **审计追踪**: 完整的配置变更审计
- **加密存储**: 敏感配置的加密存储

### 3. 可维护性
- **配置验证**: 自动配置验证
- **错误检测**: 配置错误的自动检测
- **监控告警**: 配置异常的监控告警
- **文档生成**: 自动生成配置文档

## 可扩展性设计

### 1. 配置源扩展
```python
# 支持新的配置源
class DatabaseConfigSource:
    def __init__(self, database_url):
        self.db = Database(database_url)
    
    def load_config(self, config_name: str) -> Dict[str, Any]:
        """从数据库加载配置"""
        query = "SELECT config_data FROM configs WHERE name = ?"
        result = self.db.execute(query, (config_name,))
        return json.loads(result.config_data) if result else {}
```

### 2. 配置格式扩展
- **XML配置**: 支持XML格式配置
- **INI配置**: 支持INI格式配置
- **TOML配置**: 支持TOML格式配置
- **自定义格式**: 支持自定义配置格式

### 3. 配置验证扩展
- **自定义验证器**: 支持自定义配置验证器
- **规则引擎**: 支持复杂的验证规则
- **依赖检查**: 支持配置依赖检查
- **格式验证**: 支持配置格式验证

## 高可用性保障

### 1. 配置备份
- **自动备份**: 定期自动备份配置
- **版本管理**: 配置版本管理
- **快速恢复**: 快速配置恢复
- **备份验证**: 备份数据验证

### 2. 故障恢复
- **配置回滚**: 配置变更回滚
- **默认配置**: 提供默认配置
- **降级策略**: 配置降级策略
- **故障隔离**: 配置故障隔离

### 3. 性能优化
- **配置缓存**: 智能配置缓存
- **懒加载**: 配置懒加载
- **预加载**: 关键配置预加载
- **压缩存储**: 配置压缩存储

## 通用性设计

### 1. 标准化接口
- **统一API**: 统一的配置管理API
- **数据格式**: 标准化的配置数据格式
- **错误处理**: 统一的错误处理机制

### 2. 跨平台支持
- **操作系统**: 支持多种操作系统
- **容器化**: 支持容器化部署
- **云平台**: 支持多种云平台
- **混合环境**: 支持混合环境部署

### 3. 集成能力
- **CI/CD集成**: 支持CI/CD集成
- **监控集成**: 支持监控系统集成
- **日志集成**: 支持日志系统集成
- **告警集成**: 支持告警系统集成

## 总结

配置管理与环境适配系统是BluePlan Research的重要基础设施，通过灵活的配置管理、安全的信息保护和完善的监控机制，确保系统在不同环境下都能稳定运行。系统具备强大的扩展性和高可用性，能够满足复杂部署环境的各种需求。
