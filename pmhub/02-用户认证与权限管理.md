# 用户认证与权限管理

## 1. 功能概述

用户认证与权限管理是PMHub系统的核心安全模块，负责用户身份验证、权限控制和安全管理。该模块基于Spring Security框架构建，采用JWT Token实现无状态认证，支持RBAC（基于角色的访问控制）模型。

## 2. 技术架构

### 2.1 核心组件

```
认证授权架构:
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用       │    │   网关层        │    │   认证服务      │
│                 │    │                 │    │                 │
│ - 登录界面       │    │ - 路由转发      │    │ - 用户认证      │
│ - 权限验证       │    │ - Token验证     │    │ - Token生成     │
│ - 菜单权限       │    │ - 权限拦截      │    │ - 权限验证      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   系统服务       │    │   缓存服务      │    │   数据库        │
│                 │    │                 │    │                 │
│ - 用户管理       │    │ - Token缓存     │    │ - 用户表        │
│ - 角色管理       │    │ - 权限缓存      │    │ - 角色表        │
│ - 菜单管理       │    │ - 会话缓存      │    │ - 权限表        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 技术选型

- **安全框架**: Spring Security 5.7.x
- **认证方式**: JWT Token
- **权限模型**: RBAC (Role-Based Access Control)
- **缓存**: Redis
- **数据库**: MySQL
- **密码加密**: BCrypt

## 3. 功能模块

### 3.1 用户管理

#### 3.1.1 用户信息管理

**功能描述**: 管理系统用户的基本信息，包括用户创建、修改、删除、查询等操作。

**核心功能**:
- 用户注册与创建
- 用户信息维护
- 用户状态管理
- 用户导入导出
- 用户密码管理

**数据模型**:
```sql
-- 用户表
CREATE TABLE sys_user (
    user_id BIGINT PRIMARY KEY,
    dept_id BIGINT,
    user_name VARCHAR(30),
    nick_name VARCHAR(30),
    user_type VARCHAR(2),
    email VARCHAR(50),
    phonenumber VARCHAR(11),
    sex CHAR(1),
    avatar VARCHAR(100),
    password VARCHAR(50),
    status CHAR(1),
    login_ip VARCHAR(128),
    login_date DATETIME,
    create_by VARCHAR(64),
    create_time DATETIME,
    update_by VARCHAR(64),
    update_time DATETIME,
    remark VARCHAR(500)
);
```

**API接口**:
```java
@RestController
@RequestMapping("/system/user")
public class SysUserController {
    
    // 获取用户列表
    @GetMapping("/list")
    public TableDataInfo list(SysUser user);
    
    // 新增用户
    @PostMapping("/add")
    public AjaxResult add(@Validated @RequestBody SysUser user);
    
    // 修改用户
    @PostMapping("/edit")
    public AjaxResult edit(@Validated @RequestBody SysUser user);
    
    // 删除用户
    @PostMapping("/remove")
    public AjaxResult remove(@RequestBody Long[] userIds);
    
    // 重置密码
    @PostMapping("/resetPwd")
    public AjaxResult resetPwd(@RequestBody SysUser user);
}
```

#### 3.1.2 用户认证

**功能描述**: 处理用户登录认证，生成和管理JWT Token。

**认证流程**:
1. 用户提交用户名密码
2. 验证用户身份
3. 生成JWT Token
4. 返回Token给客户端
5. 客户端后续请求携带Token

**核心代码**:
```java
@Service
public class SysLoginService {
    
    public String login(String username, String password) {
        // 1. 验证用户名密码
        Authentication authentication = authenticationManager
            .authenticate(new UsernamePasswordAuthenticationToken(username, password));
        
        // 2. 生成Token
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        String token = tokenService.createToken(loginUser);
        
        // 3. 记录登录日志
        recordLoginInfo(username, Constants.LOGIN_SUCCESS, "登录成功");
        
        return token;
    }
}
```

### 3.2 角色管理

#### 3.2.1 角色信息管理

**功能描述**: 管理系统角色，包括角色的创建、修改、删除和权限分配。

**核心功能**:
- 角色创建与维护
- 角色权限分配
- 角色数据权限
- 角色状态管理

**数据模型**:
```sql
-- 角色表
CREATE TABLE sys_role (
    role_id BIGINT PRIMARY KEY,
    role_name VARCHAR(30),
    role_key VARCHAR(100),
    role_sort INT,
    data_scope CHAR(1),
    menu_check_strictly TINYINT(1),
    dept_check_strictly TINYINT(1),
    status CHAR(1),
    del_flag CHAR(1),
    create_by VARCHAR(64),
    create_time DATETIME,
    update_by VARCHAR(64),
    update_time DATETIME,
    remark VARCHAR(500)
);

-- 用户角色关联表
CREATE TABLE sys_user_role (
    user_id BIGINT,
    role_id BIGINT,
    PRIMARY KEY (user_id, role_id)
);
```

**API接口**:
```java
@RestController
@RequestMapping("/system/role")
public class SysRoleController {
    
    // 获取角色列表
    @GetMapping("/list")
    public TableDataInfo list(SysRole role);
    
    // 新增角色
    @PostMapping("/add")
    public AjaxResult add(@Validated @RequestBody SysRole role);
    
    // 修改角色
    @PostMapping("/edit")
    public AjaxResult edit(@Validated @RequestBody SysRole role);
    
    // 删除角色
    @PostMapping("/remove")
    public AjaxResult remove(@RequestBody Long[] roleIds);
    
    // 分配权限
    @PostMapping("/dataScope")
    public AjaxResult dataScope(@RequestBody SysRole role);
}
```

### 3.3 菜单权限管理

#### 3.3.1 菜单管理

**功能描述**: 管理系统菜单和权限，支持多级菜单和按钮权限控制。

**权限类型**:
- **菜单权限**: 控制用户可访问的菜单
- **按钮权限**: 控制用户可操作的按钮
- **数据权限**: 控制用户可访问的数据范围

**数据模型**:
```sql
-- 菜单表
CREATE TABLE sys_menu (
    menu_id BIGINT PRIMARY KEY,
    menu_name VARCHAR(50),
    parent_id BIGINT,
    order_num INT,
    path VARCHAR(200),
    component VARCHAR(255),
    query VARCHAR(255),
    is_frame INT,
    is_cache INT,
    menu_type CHAR(1),
    visible CHAR(1),
    status CHAR(1),
    perms VARCHAR(100),
    icon VARCHAR(100),
    create_by VARCHAR(64),
    create_time DATETIME,
    update_by VARCHAR(64),
    update_time DATETIME,
    remark VARCHAR(500)
);

-- 角色菜单关联表
CREATE TABLE sys_role_menu (
    role_id BIGINT,
    menu_id BIGINT,
    PRIMARY KEY (role_id, menu_id)
);
```

**权限验证**:
```java
@Component
public class PermissionService {
    
    public boolean hasPermi(String permission) {
        if (StringUtils.isEmpty(permission)) {
            return false;
        }
        LoginUser loginUser = SecurityUtils.getLoginUser();
        if (StringUtils.isNull(loginUser) || CollectionUtils.isEmpty(loginUser.getPermissions())) {
            return false;
        }
        return hasPermissions(loginUser.getPermissions(), permission);
    }
    
    public boolean hasRole(String role) {
        if (StringUtils.isEmpty(role)) {
            return false;
        }
        LoginUser loginUser = SecurityUtils.getLoginUser();
        if (StringUtils.isNull(loginUser) || CollectionUtils.isEmpty(loginUser.getUser().getRoles())) {
            return false;
        }
        for (SysRole sysRole : loginUser.getUser().getRoles()) {
            String roleKey = sysRole.getRoleKey();
            if (SUPER_ADMIN.equals(roleKey) || role.equals(roleKey)) {
                return true;
            }
        }
        return false;
    }
}
```

### 3.4 部门管理

#### 3.4.1 组织架构管理

**功能描述**: 管理公司的组织架构，支持树形结构的数据权限控制。

**核心功能**:
- 部门树形管理
- 部门信息维护
- 数据权限控制
- 部门状态管理

**数据模型**:
```sql
-- 部门表
CREATE TABLE sys_dept (
    dept_id BIGINT PRIMARY KEY,
    parent_id BIGINT,
    ancestors VARCHAR(50),
    dept_name VARCHAR(30),
    order_num INT,
    leader VARCHAR(20),
    phone VARCHAR(11),
    email VARCHAR(50),
    status CHAR(1),
    del_flag CHAR(1),
    create_by VARCHAR(64),
    create_time DATETIME,
    update_by VARCHAR(64),
    update_time DATETIME
);
```

## 4. 安全机制

### 4.1 JWT Token机制

**Token结构**:
```java
public class JwtToken {
    private String token;
    private String refreshToken;
    private Long expireTime;
    private String tokenType = "Bearer";
}
```

**Token生成**:
```java
@Component
public class TokenService {
    
    public String createToken(LoginUser loginUser) {
        String token = IdUtil.fastUUID();
        loginUser.setToken(token);
        setUserAgent(loginUser);
        refreshToken(loginUser);
        
        // 生成JWT
        Map<String, Object> claims = new HashMap<>();
        claims.put(SecurityConstants.LOGIN_USER_KEY, token);
        return createToken(claims);
    }
    
    private String createToken(Map<String, Object> claims) {
        String token = Jwts.builder()
            .setClaims(claims)
            .signWith(SignatureAlgorithm.HS512, secret)
            .setExpiration(new Date(System.currentTimeMillis() + expireTime))
            .compact();
        return token;
    }
}
```

### 4.2 权限拦截机制

**网关权限拦截**:
```java
@Component
public class AuthFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String token = getToken(request);
        
        if (StringUtils.isNotEmpty(token)) {
            // 验证Token
            Claims claims = JwtUtils.parseToken(token);
            if (claims != null) {
                // 验证权限
                String uri = request.getURI().getPath();
                if (!hasPermission(claims, uri)) {
                    return unauthorized(exchange);
                }
            }
        }
        
        return chain.filter(exchange);
    }
}
```

### 4.3 数据权限控制

**数据权限注解**:
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataScope {
    /**
     * 部门表的别名
     */
    String deptAlias() default "";

    /**
     * 用户表的别名
     */
    String userAlias() default "";

    /**
     * 权限字符（用于多个角色匹配符合要求的权限）默认根据权限注解@ss获取，多个权限用逗号分隔开来
     */
    String permission() default "";
}
```

**数据权限实现**:
```java
@Aspect
@Component
public class DataScopeAspect {
    
    @Around("@annotation(controllerDataScope)")
    public Object doConcurrent(ProceedingJoinPoint point, DataScope controllerDataScope) throws Throwable {
        clearDataScope(point);
        handleDataScope(point, controllerDataScope);
        return point.proceed();
    }
    
    protected void handleDataScope(final JoinPoint point, DataScope controllerDataScope) {
        // 获取当前的用户
        LoginUser loginUser = SecurityUtils.getLoginUser();
        if (StringUtils.isNotNull(loginUser)) {
            SysUser currentUser = loginUser.getUser();
            // 如果是超级管理员，则不过滤数据
            if (StringUtils.isNotNull(currentUser) && !currentUser.isAdmin()) {
                dataScopeFilter(joinPoint, currentUser, controllerDataScope.deptAlias(),
                    controllerDataScope.userAlias());
            }
        }
    }
}
```

## 5. 缓存策略

### 5.1 用户信息缓存

**缓存结构**:
```java
// Redis缓存Key设计
public class CacheConstants {
    // 登录用户 redis key
    public static final String LOGIN_TOKEN_KEY = "login_tokens:";
    
    // 验证码 redis key
    public static final String CAPTCHA_CODE_KEY = "captcha_codes:";
    
    // 参数管理 cache key
    public static final String SYS_CONFIG_KEY = "sys_config:";
    
    // 字典管理 cache key
    public static final String SYS_DICT_KEY = "sys_dict:";
}
```

**缓存更新机制**:
```java
@Service
public class TokenService {
    
    public void refreshToken(LoginUser loginUser) {
        loginUser.setLoginTime(System.currentTimeMillis());
        loginUser.setExpireTime(loginUser.getLoginTime() + expireTime * 1000);
        // 根据uuid将loginUser缓存
        String userKey = getTokenKey(loginUser.getToken());
        redisCache.setCacheObject(userKey, loginUser, expireTime, TimeUnit.SECONDS);
    }
    
    public void delLoginUser(String token) {
        if (StringUtils.isNotEmpty(token)) {
            String userKey = getTokenKey(token);
            redisCache.deleteObject(userKey);
        }
    }
}
```

## 6. 安全防护

### 6.1 密码安全

**密码加密**:
```java
@Component
public class PasswordService {
    
    public String encryptPassword(String password) {
        return BCrypt.hashpw(password, BCrypt.gensalt());
    }
    
    public boolean matches(String rawPassword, String encodedPassword) {
        return BCrypt.checkpw(rawPassword, encodedPassword);
    }
}
```

### 6.2 登录安全

**登录限制**:
```java
@Service
public class SysLoginService {
    
    public String login(String username, String password, String code, String uuid) {
        // 验证码校验
        validateCaptcha(username, code, uuid);
        
        // 登录失败次数限制
        checkLoginFailCount(username);
        
        // 验证用户名密码
        Authentication authentication = authenticationManager
            .authenticate(new UsernamePasswordAuthenticationToken(username, password));
        
        // 清除登录失败记录
        clearLoginFailCount(username);
        
        return generateToken(authentication);
    }
}
```

### 6.3 接口安全

**接口限流**:
```java
@Component
public class RateLimitFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String ip = getClientIP(exchange.getRequest());
        
        // 检查IP限流
        if (isRateLimited(ip)) {
            return unauthorized(exchange);
        }
        
        return chain.filter(exchange);
    }
}
```

## 7. 监控审计

### 7.1 登录日志

**日志记录**:
```java
@Aspect
@Component
public class LogAspect {
    
    @Around("@annotation(controllerLog)")
    public Object doConcurrent(ProceedingJoinPoint joinPoint, Log controllerLog) throws Throwable {
        // 记录操作日志
        handleLog(joinPoint, controllerLog, null);
        return joinPoint.proceed();
    }
    
    private void handleLog(final JoinPoint joinPoint, Log controllerLog, final Exception e) {
        // 获取当前的用户
        LoginUser loginUser = SecurityUtils.getLoginUser();
        
        // 记录操作日志
        SysOperLog operLog = new SysOperLog();
        operLog.setStatus(BusinessStatus.SUCCESS.ordinal());
        operLog.setOperIp(IpUtils.getIpAddr());
        operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());
        operLog.setRequestMethod(ServletUtils.getRequest().getMethod());
        operLog.setOperParam(JSON.toJSONString(joinPoint.getArgs()));
        operLog.setOperName(loginUser.getUsername());
        operLog.setOperTime(new Date());
        
        // 保存日志
        AsyncManager.me().execute(AsyncFactory.recordOper(operLog));
    }
}
```

### 7.2 权限审计

**权限检查日志**:
```java
@Component
public class PermissionService {
    
    public boolean hasPermi(String permission) {
        boolean hasPermission = checkPermission(permission);
        
        // 记录权限检查日志
        if (!hasPermission) {
            logPermissionDenied(permission);
        }
        
        return hasPermission;
    }
}
```

## 8. 扩展功能

### 8.1 第三方登录

**OAuth2集成**:
```java
@Configuration
@EnableOAuth2Client
public class OAuth2Config {
    
    @Bean
    public OAuth2RestTemplate oauth2RestTemplate() {
        return new OAuth2RestTemplate(oauth2ClientContext());
    }
    
    @Bean
    public OAuth2ClientContext oauth2ClientContext() {
        return new DefaultOAuth2ClientContext();
    }
}
```

### 8.2 单点登录(SSO)

**SSO配置**:
```java
@Configuration
public class SSOConfig {
    
    @Bean
    public CasAuthenticationProvider casAuthenticationProvider() {
        CasAuthenticationProvider provider = new CasAuthenticationProvider();
        provider.setTicketValidator(cas20ServiceTicketValidator());
        provider.setServiceProperties(serviceProperties());
        provider.setKey("an_id_for_this_auth_provider_only");
        return provider;
    }
}
```

## 9. 性能优化

### 9.1 权限缓存优化

**权限缓存策略**:
```java
@Service
public class PermissionService {
    
    @Cacheable(value = "permissions", key = "#userId")
    public Set<String> getPermissions(Long userId) {
        // 从数据库查询用户权限
        return userService.selectUserPermissions(userId);
    }
    
    @CacheEvict(value = "permissions", key = "#userId")
    public void clearUserPermissions(Long userId) {
        // 清除用户权限缓存
    }
}
```

### 9.2 Token优化

**Token刷新机制**:
```java
@Component
public class TokenService {
    
    public String refreshToken(String token) {
        LoginUser loginUser = getLoginUser(token);
        if (StringUtils.isNotNull(loginUser)) {
            // 刷新Token
            refreshToken(loginUser);
            return loginUser.getToken();
        }
        return null;
    }
}
```

## 10. 总结

用户认证与权限管理模块是PMHub系统的安全基石，具备以下特点：

1. **安全性高**: 采用JWT Token、BCrypt加密、权限验证等多重安全机制
2. **功能完善**: 支持用户管理、角色管理、权限管理、部门管理等完整功能
3. **性能优化**: 通过缓存机制提升系统性能
4. **可扩展**: 支持第三方登录、SSO等扩展功能
5. **易维护**: 完善的日志记录和监控审计机制

该模块为PMHub系统提供了可靠的安全保障，确保系统的安全性和可控性。
