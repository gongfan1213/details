# 消息队列与异步架构

## 1. 目标与价值
- 解耦：发布/订阅降低服务间耦合
- 削峰：应对突发高并发
- 异步：提升用户体验与整体吞吐
- 最终一致：事件驱动补偿一致性

## 2. 技术选型
- RocketMQ（推荐）：高吞吐、顺序消息、事务消息、延时/定时、DLQ
- 主题与Tag规划：按领域/场景划分

## 3. 典型场景
- 项目/任务状态变更通知
- 审批通过/驳回事件
- 定时提醒（延时消息）
- 缓存失效/重建事件

## 4. 设计要点
- 幂等消费：业务唯一键 + 去重表/Redis SET
- 有序性：按照 projectId/shardingKey 做顺序队列
- 失败重试：固定/指数退避；超过阈值进入 DLQ
- 事务消息：关键业务写库 + 发送半消息，事务提交后确认
- 序列化：JSON 标准化，兼容字段扩展

## 5. Topic/Tag 建议
- `project.events`：Tag `created|updated|archived`
- `task.events`：Tag `created|assigned|status_changed|deadline`
- `workflow.events`：Tag `started|approved|rejected|copied`
- `notice.events`：Tag `email|sms|inbox`

## 6. 生产者/消费者约定
- Header：traceId、tenantId、eventId（唯一）
- 重试策略：消费者方配置最大重试与退避
- 死信处理：DLQ 监控 + 人工补偿/自动补偿

## 7. 事务消息（示意）
1) 本地事务开始→写业务表
2) 发送半消息（prepare）
3) 本地事务提交→Broker 确认→可投递
4) Broker 回查：提供查询接口保证幂等

## 8. 监控与告警
- 指标：TPS、堆积、失败率、耗时分布
- 告警：堆积阈值、DLQ 出现、重试超限

## 9. 常见问题
- 重复消费：必须幂等；业务键+状态机
- 消息丢失：开启持久化；确认机制正确
- 顺序错乱：确保同一 key 路由到同一队列
