### 面试题：后端与多智能体编排

#### Q1：后端如何为一次请求选择合适的 Handler？
**标准回答**：
- `AgentHandlerFactory` 在构造时收集所有 `AgentHandlerService` 实现为列表，`getHandler` 遍历调用每个 `support(context, request)`，返回首个匹配的 Handler。这样便于按 Agent 类型、输出风格等条件路由到 `PlanSolveHandlerImpl`、`ReactHandlerImpl` 等实现，具备良好的可扩展性。

#### Q2：`ToolCollection` 如何组织与调用工具？
**标准回答**：
- 后端在 `buildToolCollection` 中注入：固定 `file` 工具 + 来自配置的默认工具（`search/code/report`）+ 动态发现的 MCP 工具（通过 `listTool` 注入）。
- 调用时优先在本地 `toolMap` 命中，否则在 `mcpToolMap` 查询并通过 `McpTool.callTool` 转发到 MCP 客户端；未命中时报错。这个优先级保证了本地“强约束/低延迟”与外部“高扩展”的平衡。

#### Q3：多步执行是如何被限制和收敛的？
**标准回答**：
- `BaseAgent` 以 `maxSteps/currentStep/state` 控制循环执行，每步通过覆写 `step()` 执行具体逻辑；超过最大步数或达到 `FINISHED` 即退出。
- 结合 `application.yml` 中 `autobots.*.max_steps` 对不同阶段（规划、执行、React）进行上限约束，避免无限循环或“思维游走”。

#### Q4：如何把工具列表暴露给 LLM 的 Function-Call？
**标准回答**：
- 在 `LLM` 组装请求参数前，将 `BaseTool` 与 MCP 工具统一转为 `tools` 数组（或兼容 Claude 的格式），包含 `name/description/parameters(JSON-Schema)`；模型据此选择并返回函数调用，后端再以工具路由执行。

#### Q5：如何避免重复工具调用与幂等问题？
**标准回答**：
- 提示工程侧：Prompt 中显式要求“不要重复相同参数调用相同工具”。
- 运行时侧：对工具输入做哈希/去重、在 `requestId+taskId+toolName+args` 维度落盘或缓存以消除重复。
- 结果侧：对文件名与产物做去重校验（例如输出路径/文件名唯一化策略）。

#### Q6：异常与心跳处理如何设计？
**标准回答**：
- 使用 `SseEmitterUTF8` 与定时 `heartbeat` 保活；出错时 `completeWithError`，前端识别异常并降级。
- 对于内部 `/AutoAgent` 的事件流，中转服务解析出 `heartbeat` 与 `[DONE]`，转换为统一的事件格式再推向前端；异常抓取并通过统一的 `GptProcessResult` 反馈状态。

#### Q7：如何灰度开启或关闭某些工具/模型？
**标准回答**：
- 通过 `application.yml` 中的 `autobots.tool_list` 或 `llm.settings` 做动态配置；也可通过环境变量或配置中心切换不同模型网关；对敏感工具（如写文件）可在 `support()` 里加白名单/鉴权条件。


