### 多智能体编排与处理链路深度解析

#### 入口与上下文构建
- 入口控制器：`/AutoAgent` 与 `/web/api/v1/gpt/queryAgentStreamIncr`
- 关键代码：
```103:148:genie-backend/src/main/java/com/jd/genie/controller/GenieController.java
@PostMapping("/AutoAgent")
public SseEmitter AutoAgent(@RequestBody AgentRequest request) throws UnsupportedEncodingException {
    Long AUTO_AGENT_SSE_TIMEOUT = 60 * 60 * 1000L;
    SseEmitter emitter = new SseEmitter(AUTO_AGENT_SSE_TIMEOUT);
    ScheduledFuture<?> heartbeatFuture = startHeartbeat(emitter, request.getRequestId());
    registerSSEMonitor(emitter, request.getRequestId(), heartbeatFuture);
    request.setQuery(handleOutputStyle(request));
    ThreadUtil.execute(() -> {
        Printer printer = new SSEPrinter(emitter, request, request.getAgentType());
        AgentContext agentContext = AgentContext.builder()
                .requestId(request.getRequestId())
                .sessionId(request.getRequestId())
                .printer(printer)
                .query(request.getQuery())
                .dateInfo(DateUtil.CurrentDateInfo())
                .agentType(request.getAgentType())
                .isStream(Objects.nonNull(request.getIsStream()) ? request.getIsStream() : false)
                .build();
        agentContext.setToolCollection(buildToolCollection(agentContext, request));
        AgentHandlerService handler = agentHandlerFactory.getHandler(agentContext, request);
        handler.handle(agentContext, request);
    });
}
```

`AgentContext` 统一承载请求元信息、输出设备（`SSEPrinter`）、可用工具集合，以及后续各阶段所需的上下文。

#### 工具集合构建
默认工具列表来自配置：`search,code,report`，并总是包含 `file` 工具；同时动态从 MCP Server 拉取工具清单注入。
```174:214:genie-backend/src/main/java/com/jd/genie/controller/GenieController.java
private ToolCollection buildToolCollection(AgentContext agentContext, AgentRequest request) {
    ToolCollection toolCollection = new ToolCollection();
    toolCollection.setAgentContext(agentContext);
    // file
    FileTool fileTool = new FileTool();
    toolCollection.addTool(fileTool);
    // default tools by config
    if (agentToolList.contains("code")) { toolCollection.addTool(new CodeInterpreterTool()); }
    if (agentToolList.contains("report")) { toolCollection.addTool(new ReportTool()); }
    if (agentToolList.contains("search")) { toolCollection.addTool(new DeepSearchTool()); }
    // MCP 工具动态注入（list → addMcpTool）
}
```
`ToolCollection` 调度时优先本地工具，未命中则走 MCP 工具：
```71:88:genie-backend/src/main/java/com/jd/genie/agent/tool/ToolCollection.java
public Object execute
    if (toolMap.containsKey(name)) {
        return toolMap.get(name).execute(toolInput);
    } else if (mcpToolMap.containsKey(name)) {
        return new McpTool().callTool(toolInfo.getMcpServerUrl(), name, toolInput);
    }
    return null;
}
```

#### Handler 选择与响应处理
- `AgentHandlerFactory` 遍历所有 `AgentHandlerService`，调用 `support()` 选择合适的实现。
```30:44:genie-backend/src/main/java/com/jd/genie/service/impl/AgentHandlerFactory.java
public AgentHandlerService getHandler(AgentContext context, AgentRequest request) {
    for (AgentHandlerService handler : handlerMap.values()) {
        if (handler.support(context, request)) {
            return handler;
        }
    }
    return null;
}
```
- SSE 聚合：`/web/api/v1/gpt/queryAgentStreamIncr` 将内部 `/AutoAgent` 的事件流解析并转译为前端消费的结构；`AgentResponseHandler` 映射不同 `AgentType`（如 `PLAN_SOLVE`、`REACT`）。
```1:31:genie-backend/src/main/java/com/jd/genie/handler/AgentHandlerConfig.java
public Map<AgentType, AgentResponseHandler> handlerMap() {
    map.put(AgentType.PLAN_SOLVE, handler);
    map.put(AgentType.REACT, handler);
    return map;
}
```

#### 多步执行与状态控制
- 基类 `BaseAgent` 维护状态机（`IDLE/FINISHED/ERROR`）、最大步数、记忆体与工具列表；每步通过 `step()` 执行，循环直至完成或达到步数上限。
```62:89:genie-backend/src/main/java/com/jd/genie/agent/agent/BaseAgent.java
public String run(String query) {
    while (currentStep < maxSteps && state != AgentState.FINISHED) {
        currentStep++;
        String stepResult = step();
        results.add(stepResult);
    }
    return results.isEmpty() ? "No steps executed" : results.get(results.size() - 1);
}
```

#### 设计要点与难点
- 工具选择与冲突消解：同名工具优先本地，未命中再走 MCP；需避免参数重复与幂等问题
- 计划→执行→总结链路的数据契约：保证阶段事件在前端可稳定渲染（plan/task/content/summary 等类型）
- 异步编排与流式输出：SSE 与心跳协同，避免长时间无数据导致网络层断开
- 可插拔：通过 `application.yml` 动态控制工具集合与模型配置，便于灰度/扩展


