---

## 11. 技术深度分析

### 11.1 设计模式理解与选择能力

#### 11.1.1 整体架构设计模式

JoyAgent-JDGenie采用了**分层架构 + 策略模式 + 工厂模式**的组合设计：

```java
// 分层架构示例
Controller层 (API接口) → Service层 (业务逻辑) → Agent层 (智能体核心) → Tool层 (工具调用) → LLM层 (大模型接口)

// 策略模式 - Agent类型选择
public interface AgentHandlerService {
    String handle(AgentContext context, AgentRequest request);
    Boolean support(AgentContext context, AgentRequest request);
}

// 工厂模式 - Agent创建
@Component
public class AgentHandlerFactory {
    private final Map<String, AgentHandlerService> handlerMap = new ConcurrentHashMap<>();
    
    public AgentHandlerService getHandler(AgentContext context, AgentRequest request) {
        for (AgentHandlerService handler : handlerMap.values()) {
            if (handler.support(context, request)) {
                return handler;
            }
        }
        return null;
    }
}
```

**为什么选择这种设计模式？**

1. **分层架构优势**：
   - 🎯 **职责分离**：每层专注特定职责，降低耦合度
   - 🔧 **易于维护**：修改某层不影响其他层
   - 📈 **可扩展性**：新增功能只需在对应层添加实现
   - 🧪 **易于测试**：每层可独立测试

2. **策略模式优势**：
   - 🔄 **运行时切换**：根据任务类型动态选择Agent策略
   - 📦 **封装变化**：新增Agent类型不影响现有代码
   - 🎛️ **配置驱动**：通过配置文件控制Agent选择逻辑

3. **工厂模式优势**：
   - 🏭 **统一创建**：集中管理Agent实例创建逻辑
   - 🔒 **封装复杂性**：隐藏Agent创建的复杂细节
   - 🎯 **类型安全**：编译时检查Agent类型

#### 11.1.2 智能体设计模式详解

**ReAct模式实现**：
```java
public abstract class ReActAgent extends BaseAgent {
    @Override
    public String step() {
        boolean shouldAct = think();  // 思考阶段
        if (!shouldAct) {
            return "Thinking complete - no action needed";
        }
        return act();  // 行动阶段
    }
}
```

**Planning & Executor模式实现**：
```java
// PlanningAgent负责任务拆解
public class PlanningAgent extends ReActAgent {
    @Override
    public boolean think() {
        // 分析用户需求，制定任务计划
        CompletableFuture<LLM.ToolCallResponse> future = getLlm().askTool(
            context, messages, systemMsg, availableTools, ToolChoice.AUTO
        );
        // 解析LLM响应，生成任务列表
    }
}

// ExecutorAgent负责任务执行
public class ExecutorAgent extends ReActAgent {
    @Override
    public String act() {
        // 执行具体任务，调用相应工具
        for (ToolCall toolCall : toolCalls) {
            Object result = executeTool(toolCall);
            // 处理工具返回结果
        }
    }
}
```

**为什么选择这两种模式？**

1. **ReAct模式适用场景**：
   - 🎯 **简单直接任务**：问答、单步操作
   - ⚡ **快速响应**：实时交互，即时反馈
   - 🔄 **迭代优化**：通过观察结果调整策略

2. **Planning & Executor模式适用场景**：
   - 📋 **复杂多步骤任务**：需要全局规划
   - 🎯 **结构化输出**：报告生成、数据分析
   - 🔍 **可追溯性**：每个步骤都有明确记录

#### 11.1.3 工具系统设计模式

**适配器模式 + 装饰器模式**：
```java
// 适配器模式 - 统一工具接口
public interface BaseTool {
    String getName();
    String getDescription();
    Map<String, Object> toParams();
    Object execute(Object input);
}

// 装饰器模式 - 工具功能增强
public class ToolCollection {
    private Map<String, BaseTool> toolMap;
    
    public Object execute(String name, Object input) {
        BaseTool tool = toolMap.get(name);
        if (tool == null) {
            throw new IllegalArgumentException("Unknown tool: " + name);
        }
        
        // 装饰器：添加日志、监控、错误处理
        long startTime = System.currentTimeMillis();
        try {
            Object result = tool.execute(input);
            log.info("Tool {} executed successfully in {}ms", name, 
                    System.currentTimeMillis() - startTime);
            return result;
        } catch (Exception e) {
            log.error("Tool {} execution failed", name, e);
            throw e;
        }
    }
}
```

### 11.2 多Agent协作机制

#### 11.2.1 任务分配机制

**基于任务复杂度的智能分配**：
```java
public class PlanSolveHandlerImpl implements AgentHandlerService {
    @Override
    public String handle(AgentContext agentContext, AgentRequest request) {
        // 1. PlanningAgent进行任务拆解
        PlanningAgent planning = new PlanningAgent(agentContext);
        String planningResult = planning.run(agentContext.getQuery());
        
        // 2. 将复杂任务拆分为子任务
        List<String> planningResults = Arrays.stream(planningResult.split("<sep>"))
            .map(task -> "你的任务是：" + task)
            .collect(Collectors.toList());
        
        // 3. 并行执行子任务
        if (planningResults.size() > 1) {
            Map<String, String> tmpTaskResult = new ConcurrentHashMap<>();
            CountDownLatch taskCount = ThreadUtil.getCountDownLatch(planningResults.size());
            
            for (String task : planningResults) {
                ExecutorAgent slaveExecutor = new ExecutorAgent(agentContext);
                ThreadUtil.execute(() -> {
                    String taskResult = slaveExecutor.run(task);
                    tmpTaskResult.put(task, taskResult);
                    taskCount.countDown();
                });
            }
            ThreadUtil.await(taskCount);
        }
    }
}
```

**状态隔离机制**：
```java
// 每个Agent实例独立的状态管理
public class BaseAgent {
    private Memory memory = new Memory();        // 独立记忆
    private AgentState state = AgentState.IDLE;  // 独立状态
    private int currentStep = 0;                 // 独立步数
    
    // 状态隔离：每个Agent有自己的上下文
    protected AgentContext context;
}
```

#### 11.2.2 结果合并与冲突处理

**结果合并策略**：
```java
// 多任务结果合并
public class PlanSolveHandlerImpl {
    private String mergeResults(Map<String, String> taskResults) {
        // 1. 按任务顺序排序
        List<String> orderedResults = taskResults.entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .map(Map.Entry::getValue)
            .collect(Collectors.toList());
        
        // 2. 合并结果
        return String.join("\n", orderedResults);
    }
}
```

**冲突处理机制**：
```java
// 工具调用冲突处理
public class ToolCollection {
    public Object execute(String name, Object input) {
        // 1. 检查工具可用性
        if (!toolMap.containsKey(name)) {
            log.error("Tool {} not found", name);
            return "Tool not available: " + name;
        }
        
        // 2. 并发控制
        synchronized (this) {
            BaseTool tool = toolMap.get(name);
            return tool.execute(input);
        }
    }
}
```

#### 11.2.3 Planner-Subagent结构运行细节

**工作流程详解**：
```java
// 1. Planner阶段：任务分析和拆解
PlanningAgent planner = new PlanningAgent(context);
String plan = planner.run(query);

// 2. 任务分解：将复杂任务拆分为可执行的子任务
List<String> subTasks = parsePlan(plan);

// 3. Subagent执行：每个子任务由专门的执行器处理
for (String subTask : subTasks) {
    ExecutorAgent executor = new ExecutorAgent(context);
    String result = executor.run(subTask);
    results.add(result);
}

// 4. 结果整合：将子任务结果合并为最终输出
String finalResult = integrateResults(results);
```

**通信机制**：
```java
// Agent间通信通过共享上下文
public class AgentContext {
    private String requestId;           // 请求标识
    private ToolCollection toolCollection; // 共享工具集
    private List<File> productFiles;   // 共享文件
    private Printer printer;           // 共享输出器
}
```

### 11.3 上下文与记忆架构设计

#### 11.3.1 记忆系统架构

**Memory类设计**：
```java
public class Memory {
    private List<Message> messages = new ArrayList<>();
    
    // 记忆管理方法
    public void addMessage(Message message) {
        messages.add(message);
    }
    
    public void clearToolContext() {
        // 清理工具执行历史，保留核心对话
        Iterator<Message> iterator = messages.iterator();
        while (iterator.hasNext()) {
            Message message = iterator.next();
            if (message.getRole() == RoleType.TOOL) {
                iterator.remove();
            }
        }
    }
}
```

**记忆类型分析**：

1. **短期记忆（对话上下文）**：
   - 📝 **用户输入**：保存用户查询和需求
   - 🤖 **Agent响应**：保存Agent的思考和行动
   - 🔧 **工具调用**：保存工具执行过程和结果

2. **长期记忆（跨会话记忆）**：
   - 🗂️ **文件缓存**：上传的文件和生成的结果
   - 📊 **任务模式**：相似任务的执行模式
   - 🎯 **用户偏好**：用户的常用工具和输出格式

#### 11.3.2 记忆管理策略

**写入控制**：
```java
public class BaseAgent {
    public void updateMemory(RoleType role, String content, String base64Image) {
        Message message;
        switch (role) {
            case USER:
                message = Message.userMessage(content, base64Image);
                break;
            case SYSTEM:
                message = Message.systemMessage(content, base64Image);
                break;
            case ASSISTANT:
                message = Message.assistantMessage(content, base64Image);
                break;
            case TOOL:
                message = Message.toolMessage(content, base64Image);
                break;
        }
        memory.addMessage(message);
    }
}
```

**清理策略**：
```java
// 智能记忆清理
public class Memory {
    public void smartClean() {
        // 1. 保留核心对话（用户输入和最终结果）
        // 2. 清理中间工具调用历史
        // 3. 保留重要的思考过程
        // 4. 清理过长的对话历史
        if (messages.size() > MAX_MEMORY_SIZE) {
            messages = messages.subList(messages.size() - MAX_MEMORY_SIZE, messages.size());
        }
    }
}
```

#### 11.3.3 高级记忆技术

**Agentic Memory实现**：
```java
// 基于任务类型的记忆组织
public class AgenticMemory {
    private Map<String, List<Message>> taskMemory = new HashMap<>();
    
    public void addTaskMemory(String taskType, Message message) {
        taskMemory.computeIfAbsent(taskType, k -> new ArrayList<>()).add(message);
    }
    
    public List<Message> getRelevantMemory(String currentTask) {
        // 根据当前任务类型检索相关记忆
        return taskMemory.getOrDefault(currentTask, new ArrayList<>());
    }
}
```

**KV Memory实现**：
```java
// 键值对记忆存储
public class KVMemory {
    private Map<String, Object> memoryStore = new ConcurrentHashMap<>();
    
    public void put(String key, Object value) {
        memoryStore.put(key, value);
    }
    
    public Object get(String key) {
        return memoryStore.get(key);
    }
    
    public void remove(String key) {
        memoryStore.remove(key);
    }
}
```

### 11.4 工具调用与API注入机制

#### 11.4.1 动态工具注册机制

**工具注册流程**：
```java
public class ToolCollection {
    private Map<String, BaseTool> toolMap = new HashMap<>();
    private Map<String, McpToolInfo> mcpToolMap = new HashMap<>();
    
    // 动态注册内置工具
    public void addTool(BaseTool tool) {
        toolMap.put(tool.getName(), tool);
        log.info("Registered tool: {}", tool.getName());
    }
    
    // 动态注册MCP工具
    public void addMcpTool(String name, String desc, String parameters, String mcpServerUrl) {
        mcpToolMap.put(name, McpToolInfo.builder()
            .name(name)
            .desc(desc)
            .parameters(parameters)
            .mcpServerUrl(mcpServerUrl)
            .build());
    }
}
```

**工具发现机制**：
```java
// MCP工具自动发现
public class McpToolDiscovery {
    public List<McpToolInfo> discoverTools(String mcpServerUrl) {
        try {
            String response = callMcpServer(mcpServerUrl + "/tools");
            return parseToolList(response);
        } catch (Exception e) {
            log.error("Failed to discover tools from {}", mcpServerUrl, e);
            return new ArrayList<>();
        }
    }
}
```

#### 11.4.2 Schema解析机制

**参数Schema解析**：
```java
public class SchemaParser {
    public Map<String, Object> parseSchema(String schemaJson) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(schemaJson, Map.class);
        } catch (Exception e) {
            log.error("Failed to parse schema: {}", schemaJson, e);
            return new HashMap<>();
        }
    }
    
    public boolean validateParameters(Map<String, Object> params, Map<String, Object> schema) {
        // 验证参数是否符合schema定义
        Map<String, Object> properties = (Map<String, Object>) schema.get("properties");
        List<String> required = (List<String>) schema.get("required");
        
        for (String requiredField : required) {
            if (!params.containsKey(requiredField)) {
                return false;
            }
        }
        return true;
    }
}
```

**工具选择机制**：
```java
public class ToolSelector {
    public List<ToolCall> selectTools(String query, ToolCollection tools) {
        // 1. 分析查询内容
        List<String> keywords = extractKeywords(query);
        
        // 2. 计算工具相关性
        Map<String, Double> toolScores = new HashMap<>();
        for (BaseTool tool : tools.getToolMap().values()) {
            double score = calculateRelevance(keywords, tool.getDescription());
            toolScores.put(tool.getName(), score);
        }
        
        // 3. 选择最相关的工具
        return toolScores.entrySet().stream()
            .filter(entry -> entry.getValue() > THRESHOLD)
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(MAX_TOOLS)
            .map(entry -> createToolCall(entry.getKey()))
            .collect(Collectors.toList());
    }
}
```

#### 11.4.3 工具执行接口抽象

**统一工具执行接口**：
```java
public interface ToolExecutor {
    ToolResult execute(ToolCall toolCall);
    
    default ToolResult executeWithFallback(ToolCall toolCall) {
        try {
            return execute(toolCall);
        } catch (Exception e) {
            log.error("Tool execution failed: {}", toolCall.getName(), e);
            return ToolResult.builder()
                .success(false)
                .error(e.getMessage())
                .build();
        }
    }
}

public class ToolResult {
    private boolean success;
    private Object data;
    private String error;
    private long executionTime;
    private Map<String, Object> metadata;
}
```

**参数对齐机制**：
```java
public class ParameterAligner {
    public Map<String, Object> alignParameters(Map<String, Object> input, Map<String, Object> schema) {
        Map<String, Object> aligned = new HashMap<>();
        
        // 1. 类型转换
        for (Map.Entry<String, Object> entry : input.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            
            if (schema.containsKey(key)) {
                Object convertedValue = convertType(value, schema.get(key));
                aligned.put(key, convertedValue);
            }
        }
        
        // 2. 默认值填充
        Map<String, Object> properties = (Map<String, Object>) schema.get("properties");
        for (Map.Entry<String, Object> prop : properties.entrySet()) {
            String key = prop.getKey();
            Map<String, Object> propSchema = (Map<String, Object>) prop.getValue();
            
            if (!aligned.containsKey(key) && propSchema.containsKey("default")) {
                aligned.put(key, propSchema.get("default"));
            }
        }
        
        return aligned;
    }
}
```

### 11.5 控制流与调度能力

#### 11.5.1 DAG工作流设计

**任务依赖图构建**：
```java
public class WorkflowDAG {
    private Map<String, TaskNode> nodes = new HashMap<>();
    private Map<String, List<String>> dependencies = new HashMap<>();
    
    public void addTask(String taskId, String taskDescription) {
        nodes.put(taskId, new TaskNode(taskId, taskDescription));
    }
    
    public void addDependency(String fromTask, String toTask) {
        dependencies.computeIfAbsent(fromTask, k -> new ArrayList<>()).add(toTask);
    }
    
    public List<String> getExecutionOrder() {
        // 拓扑排序确定执行顺序
        return topologicalSort();
    }
}

public class TaskNode {
    private String id;
    private String description;
    private TaskStatus status = TaskStatus.PENDING;
    private Object result;
    private Exception error;
}
```

**并行执行引擎**：
```java
public class ParallelExecutor {
    private ExecutorService executor = Executors.newFixedThreadPool(10);
    
    public Map<String, Object> executeParallel(List<String> tasks) {
        Map<String, CompletableFuture<Object>> futures = new HashMap<>();
        
        // 提交所有任务
        for (String task : tasks) {
            CompletableFuture<Object> future = CompletableFuture.supplyAsync(() -> {
                return executeTask(task);
            }, executor);
            futures.put(task, future);
        }
        
        // 等待所有任务完成
        Map<String, Object> results = new HashMap<>();
        for (Map.Entry<String, CompletableFuture<Object>> entry : futures.entrySet()) {
            try {
                results.put(entry.getKey(), entry.getValue().get());
            } catch (Exception e) {
                log.error("Task {} failed", entry.getKey(), e);
                results.put(entry.getKey(), "ERROR: " + e.getMessage());
            }
        }
        
        return results;
    }
}
```

#### 11.5.2 幂等执行机制

**任务幂等性保证**：
```java
public class IdempotentExecutor {
    private Map<String, TaskResult> completedTasks = new ConcurrentHashMap<>();
    
    public TaskResult executeTask(String taskId, String taskDescription) {
        // 检查是否已执行
        if (completedTasks.containsKey(taskId)) {
            log.info("Task {} already completed, returning cached result", taskId);
            return completedTasks.get(taskId);
        }
        
        // 执行任务
        TaskResult result = doExecute(taskId, taskDescription);
        
        // 缓存结果
        completedTasks.put(taskId, result);
        
        return result;
    }
}

public class TaskResult {
    private String taskId;
    private TaskStatus status;
    private Object data;
    private long executionTime;
    private String checksum; // 用于验证结果一致性
}
```

**失败回滚机制**：
```java
public class RollbackManager {
    private Stack<RollbackAction> actionStack = new Stack<>();
    
    public void executeWithRollback(Runnable action, Runnable rollback) {
        try {
            action.run();
            actionStack.push(new RollbackAction(rollback));
        } catch (Exception e) {
            log.error("Action failed, performing rollback", e);
            performRollback();
            throw e;
        }
    }
    
    private void performRollback() {
        while (!actionStack.isEmpty()) {
            RollbackAction action = actionStack.pop();
            try {
                action.getRollback().run();
            } catch (Exception e) {
                log.error("Rollback action failed", e);
            }
        }
    }
}
```

#### 11.5.3 优先级调度机制

**任务优先级管理**：
```java
public class PriorityScheduler {
    private PriorityBlockingQueue<Task> taskQueue = new PriorityBlockingQueue<>();
    
    public void submitTask(Task task) {
        taskQueue.offer(task);
    }
    
    public Task getNextTask() {
        return taskQueue.poll();
    }
}

public class Task implements Comparable<Task> {
    private String id;
    private int priority; // 1-10, 10为最高优先级
    private long submitTime;
    private String description;
    
    @Override
    public int compareTo(Task other) {
        // 优先级高的先执行，同优先级按提交时间排序
        int priorityCompare = Integer.compare(other.priority, this.priority);
        if (priorityCompare != 0) {
            return priorityCompare;
        }
        return Long.compare(this.submitTime, other.submitTime);
    }
}
```

**异步协同机制**：
```java
public class AsyncCoordinator {
    private Map<String, CompletableFuture<Void>> runningTasks = new ConcurrentHashMap<>();
    
    public CompletableFuture<Void> coordinateTasks(List<String> taskIds) {
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (String taskId : taskIds) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                executeTask(taskId);
            });
            runningTasks.put(taskId, future);
            futures.add(future);
        }
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
    }
    
    public void cancelTask(String taskId) {
        CompletableFuture<Void> future = runningTasks.get(taskId);
        if (future != null && !future.isDone()) {
            future.cancel(true);
            runningTasks.remove(taskId);
        }
    }
}
```

### 11.6 性能与系统监控能力

#### 11.6.1 性能评估体系

**响应延迟监控**：
```java
public class PerformanceMonitor {
    private Map<String, List<Long>> responseTimes = new ConcurrentHashMap<>();
    
    public void recordResponseTime(String agentType, long responseTime) {
        responseTimes.computeIfAbsent(agentType, k -> new ArrayList<>()).add(responseTime);
    }
    
    public PerformanceMetrics getMetrics(String agentType) {
        List<Long> times = responseTimes.get(agentType);
        if (times == null || times.isEmpty()) {
            return new PerformanceMetrics();
        }
        
        return PerformanceMetrics.builder()
            .avgResponseTime(times.stream().mapToLong(Long::longValue).average().orElse(0))
            .maxResponseTime(times.stream().mapToLong(Long::longValue).max().orElse(0))
            .minResponseTime(times.stream().mapToLong(Long::longValue).min().orElse(0))
            .p95ResponseTime(calculatePercentile(times, 95))
            .p99ResponseTime(calculatePercentile(times, 99))
            .build();
    }
}
```

**Token成本分析**：
```java
public class TokenCounter {
    private int totalInputTokens = 0;
    private int totalOutputTokens = 0;
    private Map<String, Integer> modelTokenUsage = new HashMap<>();
    
    public void recordTokenUsage(String model, int inputTokens, int outputTokens) {
        totalInputTokens += inputTokens;
        totalOutputTokens += outputTokens;
        modelTokenUsage.merge(model, inputTokens + outputTokens, Integer::sum);
    }
    
    public CostAnalysis calculateCost() {
        // 根据模型定价计算成本
        double totalCost = 0.0;
        for (Map.Entry<String, Integer> entry : modelTokenUsage.entrySet()) {
            String model = entry.getKey();
            int tokens = entry.getValue();
            double costPerToken = getModelCost(model);
            totalCost += tokens * costPerToken;
        }
        
        return CostAnalysis.builder()
            .totalCost(totalCost)
            .totalTokens(totalInputTokens + totalOutputTokens)
            .modelUsage(modelTokenUsage)
            .build();
    }
}
```

#### 11.6.2 内存检索效率优化

**向量化检索**：
```java
public class VectorMemory {
    private Map<String, float[]> embeddings = new HashMap<>();
    private List<float[]> memoryVectors = new ArrayList<>();
    private List<String> memoryTexts = new ArrayList<>();
    
    public void addMemory(String text) {
        float[] embedding = generateEmbedding(text);
        memoryVectors.add(embedding);
        memoryTexts.add(text);
    }
    
    public List<String> searchSimilar(String query, int topK) {
        float[] queryEmbedding = generateEmbedding(query);
        
        // 计算相似度并排序
        List<SimilarityResult> results = new ArrayList<>();
        for (int i = 0; i < memoryVectors.size(); i++) {
            float similarity = cosineSimilarity(queryEmbedding, memoryVectors.get(i));
            results.add(new SimilarityResult(memoryTexts.get(i), similarity));
        }
        
        return results.stream()
            .sorted(Comparator.comparing(SimilarityResult::getSimilarity).reversed())
            .limit(topK)
            .map(SimilarityResult::getText)
            .collect(Collectors.toList());
    }
}
```

**缓存优化策略**：
```java
public class MemoryCache {
    private Cache<String, Object> cache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(1, TimeUnit.HOURS)
        .build();
    
    public Object getOrCompute(String key, Supplier<Object> supplier) {
        return cache.get(key, k -> supplier.get());
    }
    
    public void invalidatePattern(String pattern) {
        cache.asMap().keySet().removeIf(key -> key.matches(pattern));
    }
}
```

#### 11.6.3 监控工具集成

**Tracing集成**：
```java
public class TracingInterceptor {
    public <T> T trace(String operation, Supplier<T> supplier) {
        String traceId = generateTraceId();
        long startTime = System.currentTimeMillis();
        
        try {
            T result = supplier.get();
            recordSuccess(operation, traceId, System.currentTimeMillis() - startTime);
            return result;
        } catch (Exception e) {
            recordError(operation, traceId, e);
            throw e;
        }
    }
    
    private void recordSuccess(String operation, String traceId, long duration) {
        // 记录到Jaeger/Zipkin等分布式追踪系统
        log.info("Operation {} completed in {}ms, traceId: {}", operation, duration, traceId);
    }
}
```

**LangSmith集成**：
```java
public class LangSmithTracker {
    private final String apiKey;
    private final String projectName;
    
    public void trackRun(String runId, String name, Map<String, Object> inputs, 
                        Map<String, Object> outputs, Map<String, Object> metadata) {
        // 发送到LangSmith进行监控和分析
        LangSmithRun run = LangSmithRun.builder()
            .id(runId)
            .name(name)
            .inputs(inputs)
            .outputs(outputs)
            .metadata(metadata)
            .build();
        
        sendToLangSmith(run);
    }
}
```

### 11.7 安全性与合规意识

#### 11.7.1 权限边界设计

**多层级权限控制**：
```java
public class SecurityManager {
    private Map<String, Set<String>> userPermissions = new HashMap<>();
    private Map<String, Set<String>> toolPermissions = new HashMap<>();
    
    public boolean canAccessTool(String userId, String toolName) {
        Set<String> userPerms = userPermissions.get(userId);
        Set<String> toolPerms = toolPermissions.get(toolName);
        
        if (userPerms == null || toolPerms == null) {
            return false;
        }
        
        return !Collections.disjoint(userPerms, toolPerms);
    }
    
    public void validateInput(String input) {
        // 输入验证
        if (input.length() > MAX_INPUT_LENGTH) {
            throw new SecurityException("Input too long");
        }
        
        // 敏感词过滤
        if (containsSensitiveWords(input)) {
            throw new SecurityException("Input contains sensitive content");
        }
    }
}
```

**数据访问控制**：
```java
public class DataAccessControl {
    public boolean canAccessFile(String userId, String filePath) {
        // 检查文件权限
        FilePermission permission = getFilePermission(filePath);
        return permission.canRead(userId);
    }
    
    public String sanitizeOutput(String output) {
        // 输出脱敏
        return StringUtil.textDesensitization(output, sensitivePatterns);
    }
}
```

#### 11.7.2 Prompt注入防护

**输入验证机制**：
```java
public class PromptInjectionDetector {
    private static final List<Pattern> injectionPatterns = Arrays.asList(
        Pattern.compile("(?i)ignore.*previous.*instructions"),
        Pattern.compile("(?i)system.*prompt"),
        Pattern.compile("(?i)role.*play"),
        Pattern.compile("(?i)pretend.*to.*be")
    );
    
    public boolean detectInjection(String input) {
        for (Pattern pattern : injectionPatterns) {
            if (pattern.matcher(input).find()) {
                return true;
            }
        }
        return false;
    }
    
    public String sanitizePrompt(String prompt) {
        // 移除可能的注入内容
        String sanitized = prompt;
        for (Pattern pattern : injectionPatterns) {
            sanitized = pattern.matcher(sanitized).replaceAll("");
        }
        return sanitized;
    }
}
```

**上下文隔离**：
```java
public class ContextIsolation {
    private final String systemPrompt;
    private final String userPrompt;
    
    public String buildSafePrompt(String userInput) {
        // 确保系统提示词不被用户输入覆盖
        return String.format("""
            %s
            
            User: %s
            
            Assistant: Let me help you with that. I'll follow the guidelines and provide a helpful response.
            """, systemPrompt, sanitizeInput(userInput));
    }
}
```

#### 11.7.3 审计与合规回溯

**操作日志记录**：
```java
public class AuditLogger {
    public void logOperation(String userId, String operation, Map<String, Object> details) {
        AuditLog log = AuditLog.bui