---

## 11. æŠ€æœ¯æ·±åº¦åˆ†æ

### 11.1 è®¾è®¡æ¨¡å¼ç†è§£ä¸é€‰æ‹©èƒ½åŠ›

#### 11.1.1 æ•´ä½“æ¶æ„è®¾è®¡æ¨¡å¼

JoyAgent-JDGenieé‡‡ç”¨äº†**åˆ†å±‚æ¶æ„ + ç­–ç•¥æ¨¡å¼ + å·¥å‚æ¨¡å¼**çš„ç»„åˆè®¾è®¡ï¼š

```java
// åˆ†å±‚æ¶æ„ç¤ºä¾‹
Controllerå±‚ (APIæ¥å£) â†’ Serviceå±‚ (ä¸šåŠ¡é€»è¾‘) â†’ Agentå±‚ (æ™ºèƒ½ä½“æ ¸å¿ƒ) â†’ Toolå±‚ (å·¥å…·è°ƒç”¨) â†’ LLMå±‚ (å¤§æ¨¡å‹æ¥å£)

// ç­–ç•¥æ¨¡å¼ - Agentç±»å‹é€‰æ‹©
public interface AgentHandlerService {
    String handle(AgentContext context, AgentRequest request);
    Boolean support(AgentContext context, AgentRequest request);
}

// å·¥å‚æ¨¡å¼ - Agentåˆ›å»º
@Component
public class AgentHandlerFactory {
    private final Map<String, AgentHandlerService> handlerMap = new ConcurrentHashMap<>();
    
    public AgentHandlerService getHandler(AgentContext context, AgentRequest request) {
        for (AgentHandlerService handler : handlerMap.values()) {
            if (handler.support(context, request)) {
                return handler;
            }
        }
        return null;
    }
}
```

**ä¸ºä»€ä¹ˆé€‰æ‹©è¿™ç§è®¾è®¡æ¨¡å¼ï¼Ÿ**

1. **åˆ†å±‚æ¶æ„ä¼˜åŠ¿**ï¼š
   - ğŸ¯ **èŒè´£åˆ†ç¦»**ï¼šæ¯å±‚ä¸“æ³¨ç‰¹å®šèŒè´£ï¼Œé™ä½è€¦åˆåº¦
   - ğŸ”§ **æ˜“äºç»´æŠ¤**ï¼šä¿®æ”¹æŸå±‚ä¸å½±å“å…¶ä»–å±‚
   - ğŸ“ˆ **å¯æ‰©å±•æ€§**ï¼šæ–°å¢åŠŸèƒ½åªéœ€åœ¨å¯¹åº”å±‚æ·»åŠ å®ç°
   - ğŸ§ª **æ˜“äºæµ‹è¯•**ï¼šæ¯å±‚å¯ç‹¬ç«‹æµ‹è¯•

2. **ç­–ç•¥æ¨¡å¼ä¼˜åŠ¿**ï¼š
   - ğŸ”„ **è¿è¡Œæ—¶åˆ‡æ¢**ï¼šæ ¹æ®ä»»åŠ¡ç±»å‹åŠ¨æ€é€‰æ‹©Agentç­–ç•¥
   - ğŸ“¦ **å°è£…å˜åŒ–**ï¼šæ–°å¢Agentç±»å‹ä¸å½±å“ç°æœ‰ä»£ç 
   - ğŸ›ï¸ **é…ç½®é©±åŠ¨**ï¼šé€šè¿‡é…ç½®æ–‡ä»¶æ§åˆ¶Agenté€‰æ‹©é€»è¾‘

3. **å·¥å‚æ¨¡å¼ä¼˜åŠ¿**ï¼š
   - ğŸ­ **ç»Ÿä¸€åˆ›å»º**ï¼šé›†ä¸­ç®¡ç†Agentå®ä¾‹åˆ›å»ºé€»è¾‘
   - ğŸ”’ **å°è£…å¤æ‚æ€§**ï¼šéšè—Agentåˆ›å»ºçš„å¤æ‚ç»†èŠ‚
   - ğŸ¯ **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥Agentç±»å‹

#### 11.1.2 æ™ºèƒ½ä½“è®¾è®¡æ¨¡å¼è¯¦è§£

**ReActæ¨¡å¼å®ç°**ï¼š
```java
public abstract class ReActAgent extends BaseAgent {
    @Override
    public String step() {
        boolean shouldAct = think();  // æ€è€ƒé˜¶æ®µ
        if (!shouldAct) {
            return "Thinking complete - no action needed";
        }
        return act();  // è¡ŒåŠ¨é˜¶æ®µ
    }
}
```

**Planning & Executoræ¨¡å¼å®ç°**ï¼š
```java
// PlanningAgentè´Ÿè´£ä»»åŠ¡æ‹†è§£
public class PlanningAgent extends ReActAgent {
    @Override
    public boolean think() {
        // åˆ†æç”¨æˆ·éœ€æ±‚ï¼Œåˆ¶å®šä»»åŠ¡è®¡åˆ’
        CompletableFuture<LLM.ToolCallResponse> future = getLlm().askTool(
            context, messages, systemMsg, availableTools, ToolChoice.AUTO
        );
        // è§£æLLMå“åº”ï¼Œç”Ÿæˆä»»åŠ¡åˆ—è¡¨
    }
}

// ExecutorAgentè´Ÿè´£ä»»åŠ¡æ‰§è¡Œ
public class ExecutorAgent extends ReActAgent {
    @Override
    public String act() {
        // æ‰§è¡Œå…·ä½“ä»»åŠ¡ï¼Œè°ƒç”¨ç›¸åº”å·¥å…·
        for (ToolCall toolCall : toolCalls) {
            Object result = executeTool(toolCall);
            // å¤„ç†å·¥å…·è¿”å›ç»“æœ
        }
    }
}
```

**ä¸ºä»€ä¹ˆé€‰æ‹©è¿™ä¸¤ç§æ¨¡å¼ï¼Ÿ**

1. **ReActæ¨¡å¼é€‚ç”¨åœºæ™¯**ï¼š
   - ğŸ¯ **ç®€å•ç›´æ¥ä»»åŠ¡**ï¼šé—®ç­”ã€å•æ­¥æ“ä½œ
   - âš¡ **å¿«é€Ÿå“åº”**ï¼šå®æ—¶äº¤äº’ï¼Œå³æ—¶åé¦ˆ
   - ğŸ”„ **è¿­ä»£ä¼˜åŒ–**ï¼šé€šè¿‡è§‚å¯Ÿç»“æœè°ƒæ•´ç­–ç•¥

2. **Planning & Executoræ¨¡å¼é€‚ç”¨åœºæ™¯**ï¼š
   - ğŸ“‹ **å¤æ‚å¤šæ­¥éª¤ä»»åŠ¡**ï¼šéœ€è¦å…¨å±€è§„åˆ’
   - ğŸ¯ **ç»“æ„åŒ–è¾“å‡º**ï¼šæŠ¥å‘Šç”Ÿæˆã€æ•°æ®åˆ†æ
   - ğŸ” **å¯è¿½æº¯æ€§**ï¼šæ¯ä¸ªæ­¥éª¤éƒ½æœ‰æ˜ç¡®è®°å½•

#### 11.1.3 å·¥å…·ç³»ç»Ÿè®¾è®¡æ¨¡å¼

**é€‚é…å™¨æ¨¡å¼ + è£…é¥°å™¨æ¨¡å¼**ï¼š
```java
// é€‚é…å™¨æ¨¡å¼ - ç»Ÿä¸€å·¥å…·æ¥å£
public interface BaseTool {
    String getName();
    String getDescription();
    Map<String, Object> toParams();
    Object execute(Object input);
}

// è£…é¥°å™¨æ¨¡å¼ - å·¥å…·åŠŸèƒ½å¢å¼º
public class ToolCollection {
    private Map<String, BaseTool> toolMap;
    
    public Object execute(String name, Object input) {
        BaseTool tool = toolMap.get(name);
        if (tool == null) {
            throw new IllegalArgumentException("Unknown tool: " + name);
        }
        
        // è£…é¥°å™¨ï¼šæ·»åŠ æ—¥å¿—ã€ç›‘æ§ã€é”™è¯¯å¤„ç†
        long startTime = System.currentTimeMillis();
        try {
            Object result = tool.execute(input);
            log.info("Tool {} executed successfully in {}ms", name, 
                    System.currentTimeMillis() - startTime);
            return result;
        } catch (Exception e) {
            log.error("Tool {} execution failed", name, e);
            throw e;
        }
    }
}
```

### 11.2 å¤šAgentåä½œæœºåˆ¶

#### 11.2.1 ä»»åŠ¡åˆ†é…æœºåˆ¶

**åŸºäºä»»åŠ¡å¤æ‚åº¦çš„æ™ºèƒ½åˆ†é…**ï¼š
```java
public class PlanSolveHandlerImpl implements AgentHandlerService {
    @Override
    public String handle(AgentContext agentContext, AgentRequest request) {
        // 1. PlanningAgentè¿›è¡Œä»»åŠ¡æ‹†è§£
        PlanningAgent planning = new PlanningAgent(agentContext);
        String planningResult = planning.run(agentContext.getQuery());
        
        // 2. å°†å¤æ‚ä»»åŠ¡æ‹†åˆ†ä¸ºå­ä»»åŠ¡
        List<String> planningResults = Arrays.stream(planningResult.split("<sep>"))
            .map(task -> "ä½ çš„ä»»åŠ¡æ˜¯ï¼š" + task)
            .collect(Collectors.toList());
        
        // 3. å¹¶è¡Œæ‰§è¡Œå­ä»»åŠ¡
        if (planningResults.size() > 1) {
            Map<String, String> tmpTaskResult = new ConcurrentHashMap<>();
            CountDownLatch taskCount = ThreadUtil.getCountDownLatch(planningResults.size());
            
            for (String task : planningResults) {
                ExecutorAgent slaveExecutor = new ExecutorAgent(agentContext);
                ThreadUtil.execute(() -> {
                    String taskResult = slaveExecutor.run(task);
                    tmpTaskResult.put(task, taskResult);
                    taskCount.countDown();
                });
            }
            ThreadUtil.await(taskCount);
        }
    }
}
```

**çŠ¶æ€éš”ç¦»æœºåˆ¶**ï¼š
```java
// æ¯ä¸ªAgentå®ä¾‹ç‹¬ç«‹çš„çŠ¶æ€ç®¡ç†
public class BaseAgent {
    private Memory memory = new Memory();        // ç‹¬ç«‹è®°å¿†
    private AgentState state = AgentState.IDLE;  // ç‹¬ç«‹çŠ¶æ€
    private int currentStep = 0;                 // ç‹¬ç«‹æ­¥æ•°
    
    // çŠ¶æ€éš”ç¦»ï¼šæ¯ä¸ªAgentæœ‰è‡ªå·±çš„ä¸Šä¸‹æ–‡
    protected AgentContext context;
}
```

#### 11.2.2 ç»“æœåˆå¹¶ä¸å†²çªå¤„ç†

**ç»“æœåˆå¹¶ç­–ç•¥**ï¼š
```java
// å¤šä»»åŠ¡ç»“æœåˆå¹¶
public class PlanSolveHandlerImpl {
    private String mergeResults(Map<String, String> taskResults) {
        // 1. æŒ‰ä»»åŠ¡é¡ºåºæ’åº
        List<String> orderedResults = taskResults.entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .map(Map.Entry::getValue)
            .collect(Collectors.toList());
        
        // 2. åˆå¹¶ç»“æœ
        return String.join("\n", orderedResults);
    }
}
```

**å†²çªå¤„ç†æœºåˆ¶**ï¼š
```java
// å·¥å…·è°ƒç”¨å†²çªå¤„ç†
public class ToolCollection {
    public Object execute(String name, Object input) {
        // 1. æ£€æŸ¥å·¥å…·å¯ç”¨æ€§
        if (!toolMap.containsKey(name)) {
            log.error("Tool {} not found", name);
            return "Tool not available: " + name;
        }
        
        // 2. å¹¶å‘æ§åˆ¶
        synchronized (this) {
            BaseTool tool = toolMap.get(name);
            return tool.execute(input);
        }
    }
}
```

#### 11.2.3 Planner-Subagentç»“æ„è¿è¡Œç»†èŠ‚

**å·¥ä½œæµç¨‹è¯¦è§£**ï¼š
```java
// 1. Planneré˜¶æ®µï¼šä»»åŠ¡åˆ†æå’Œæ‹†è§£
PlanningAgent planner = new PlanningAgent(context);
String plan = planner.run(query);

// 2. ä»»åŠ¡åˆ†è§£ï¼šå°†å¤æ‚ä»»åŠ¡æ‹†åˆ†ä¸ºå¯æ‰§è¡Œçš„å­ä»»åŠ¡
List<String> subTasks = parsePlan(plan);

// 3. Subagentæ‰§è¡Œï¼šæ¯ä¸ªå­ä»»åŠ¡ç”±ä¸“é—¨çš„æ‰§è¡Œå™¨å¤„ç†
for (String subTask : subTasks) {
    ExecutorAgent executor = new ExecutorAgent(context);
    String result = executor.run(subTask);
    results.add(result);
}

// 4. ç»“æœæ•´åˆï¼šå°†å­ä»»åŠ¡ç»“æœåˆå¹¶ä¸ºæœ€ç»ˆè¾“å‡º
String finalResult = integrateResults(results);
```

**é€šä¿¡æœºåˆ¶**ï¼š
```java
// Agenté—´é€šä¿¡é€šè¿‡å…±äº«ä¸Šä¸‹æ–‡
public class AgentContext {
    private String requestId;           // è¯·æ±‚æ ‡è¯†
    private ToolCollection toolCollection; // å…±äº«å·¥å…·é›†
    private List<File> productFiles;   // å…±äº«æ–‡ä»¶
    private Printer printer;           // å…±äº«è¾“å‡ºå™¨
}
```

### 11.3 ä¸Šä¸‹æ–‡ä¸è®°å¿†æ¶æ„è®¾è®¡

#### 11.3.1 è®°å¿†ç³»ç»Ÿæ¶æ„

**Memoryç±»è®¾è®¡**ï¼š
```java
public class Memory {
    private List<Message> messages = new ArrayList<>();
    
    // è®°å¿†ç®¡ç†æ–¹æ³•
    public void addMessage(Message message) {
        messages.add(message);
    }
    
    public void clearToolContext() {
        // æ¸…ç†å·¥å…·æ‰§è¡Œå†å²ï¼Œä¿ç•™æ ¸å¿ƒå¯¹è¯
        Iterator<Message> iterator = messages.iterator();
        while (iterator.hasNext()) {
            Message message = iterator.next();
            if (message.getRole() == RoleType.TOOL) {
                iterator.remove();
            }
        }
    }
}
```

**è®°å¿†ç±»å‹åˆ†æ**ï¼š

1. **çŸ­æœŸè®°å¿†ï¼ˆå¯¹è¯ä¸Šä¸‹æ–‡ï¼‰**ï¼š
   - ğŸ“ **ç”¨æˆ·è¾“å…¥**ï¼šä¿å­˜ç”¨æˆ·æŸ¥è¯¢å’Œéœ€æ±‚
   - ğŸ¤– **Agentå“åº”**ï¼šä¿å­˜Agentçš„æ€è€ƒå’Œè¡ŒåŠ¨
   - ğŸ”§ **å·¥å…·è°ƒç”¨**ï¼šä¿å­˜å·¥å…·æ‰§è¡Œè¿‡ç¨‹å’Œç»“æœ

2. **é•¿æœŸè®°å¿†ï¼ˆè·¨ä¼šè¯è®°å¿†ï¼‰**ï¼š
   - ğŸ—‚ï¸ **æ–‡ä»¶ç¼“å­˜**ï¼šä¸Šä¼ çš„æ–‡ä»¶å’Œç”Ÿæˆçš„ç»“æœ
   - ğŸ“Š **ä»»åŠ¡æ¨¡å¼**ï¼šç›¸ä¼¼ä»»åŠ¡çš„æ‰§è¡Œæ¨¡å¼
   - ğŸ¯ **ç”¨æˆ·åå¥½**ï¼šç”¨æˆ·çš„å¸¸ç”¨å·¥å…·å’Œè¾“å‡ºæ ¼å¼

#### 11.3.2 è®°å¿†ç®¡ç†ç­–ç•¥

**å†™å…¥æ§åˆ¶**ï¼š
```java
public class BaseAgent {
    public void updateMemory(RoleType role, String content, String base64Image) {
        Message message;
        switch (role) {
            case USER:
                message = Message.userMessage(content, base64Image);
                break;
            case SYSTEM:
                message = Message.systemMessage(content, base64Image);
                break;
            case ASSISTANT:
                message = Message.assistantMessage(content, base64Image);
                break;
            case TOOL:
                message = Message.toolMessage(content, base64Image);
                break;
        }
        memory.addMessage(message);
    }
}
```

**æ¸…ç†ç­–ç•¥**ï¼š
```java
// æ™ºèƒ½è®°å¿†æ¸…ç†
public class Memory {
    public void smartClean() {
        // 1. ä¿ç•™æ ¸å¿ƒå¯¹è¯ï¼ˆç”¨æˆ·è¾“å…¥å’Œæœ€ç»ˆç»“æœï¼‰
        // 2. æ¸…ç†ä¸­é—´å·¥å…·è°ƒç”¨å†å²
        // 3. ä¿ç•™é‡è¦çš„æ€è€ƒè¿‡ç¨‹
        // 4. æ¸…ç†è¿‡é•¿çš„å¯¹è¯å†å²
        if (messages.size() > MAX_MEMORY_SIZE) {
            messages = messages.subList(messages.size() - MAX_MEMORY_SIZE, messages.size());
        }
    }
}
```

#### 11.3.3 é«˜çº§è®°å¿†æŠ€æœ¯

**Agentic Memoryå®ç°**ï¼š
```java
// åŸºäºä»»åŠ¡ç±»å‹çš„è®°å¿†ç»„ç»‡
public class AgenticMemory {
    private Map<String, List<Message>> taskMemory = new HashMap<>();
    
    public void addTaskMemory(String taskType, Message message) {
        taskMemory.computeIfAbsent(taskType, k -> new ArrayList<>()).add(message);
    }
    
    public List<Message> getRelevantMemory(String currentTask) {
        // æ ¹æ®å½“å‰ä»»åŠ¡ç±»å‹æ£€ç´¢ç›¸å…³è®°å¿†
        return taskMemory.getOrDefault(currentTask, new ArrayList<>());
    }
}
```

**KV Memoryå®ç°**ï¼š
```java
// é”®å€¼å¯¹è®°å¿†å­˜å‚¨
public class KVMemory {
    private Map<String, Object> memoryStore = new ConcurrentHashMap<>();
    
    public void put(String key, Object value) {
        memoryStore.put(key, value);
    }
    
    public Object get(String key) {
        return memoryStore.get(key);
    }
    
    public void remove(String key) {
        memoryStore.remove(key);
    }
}
```

### 11.4 å·¥å…·è°ƒç”¨ä¸APIæ³¨å…¥æœºåˆ¶

#### 11.4.1 åŠ¨æ€å·¥å…·æ³¨å†Œæœºåˆ¶

**å·¥å…·æ³¨å†Œæµç¨‹**ï¼š
```java
public class ToolCollection {
    private Map<String, BaseTool> toolMap = new HashMap<>();
    private Map<String, McpToolInfo> mcpToolMap = new HashMap<>();
    
    // åŠ¨æ€æ³¨å†Œå†…ç½®å·¥å…·
    public void addTool(BaseTool tool) {
        toolMap.put(tool.getName(), tool);
        log.info("Registered tool: {}", tool.getName());
    }
    
    // åŠ¨æ€æ³¨å†ŒMCPå·¥å…·
    public void addMcpTool(String name, String desc, String parameters, String mcpServerUrl) {
        mcpToolMap.put(name, McpToolInfo.builder()
            .name(name)
            .desc(desc)
            .parameters(parameters)
            .mcpServerUrl(mcpServerUrl)
            .build());
    }
}
```

**å·¥å…·å‘ç°æœºåˆ¶**ï¼š
```java
// MCPå·¥å…·è‡ªåŠ¨å‘ç°
public class McpToolDiscovery {
    public List<McpToolInfo> discoverTools(String mcpServerUrl) {
        try {
            String response = callMcpServer(mcpServerUrl + "/tools");
            return parseToolList(response);
        } catch (Exception e) {
            log.error("Failed to discover tools from {}", mcpServerUrl, e);
            return new ArrayList<>();
        }
    }
}
```

#### 11.4.2 Schemaè§£ææœºåˆ¶

**å‚æ•°Schemaè§£æ**ï¼š
```java
public class SchemaParser {
    public Map<String, Object> parseSchema(String schemaJson) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.readValue(schemaJson, Map.class);
        } catch (Exception e) {
            log.error("Failed to parse schema: {}", schemaJson, e);
            return new HashMap<>();
        }
    }
    
    public boolean validateParameters(Map<String, Object> params, Map<String, Object> schema) {
        // éªŒè¯å‚æ•°æ˜¯å¦ç¬¦åˆschemaå®šä¹‰
        Map<String, Object> properties = (Map<String, Object>) schema.get("properties");
        List<String> required = (List<String>) schema.get("required");
        
        for (String requiredField : required) {
            if (!params.containsKey(requiredField)) {
                return false;
            }
        }
        return true;
    }
}
```

**å·¥å…·é€‰æ‹©æœºåˆ¶**ï¼š
```java
public class ToolSelector {
    public List<ToolCall> selectTools(String query, ToolCollection tools) {
        // 1. åˆ†ææŸ¥è¯¢å†…å®¹
        List<String> keywords = extractKeywords(query);
        
        // 2. è®¡ç®—å·¥å…·ç›¸å…³æ€§
        Map<String, Double> toolScores = new HashMap<>();
        for (BaseTool tool : tools.getToolMap().values()) {
            double score = calculateRelevance(keywords, tool.getDescription());
            toolScores.put(tool.getName(), score);
        }
        
        // 3. é€‰æ‹©æœ€ç›¸å…³çš„å·¥å…·
        return toolScores.entrySet().stream()
            .filter(entry -> entry.getValue() > THRESHOLD)
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(MAX_TOOLS)
            .map(entry -> createToolCall(entry.getKey()))
            .collect(Collectors.toList());
    }
}
```

#### 11.4.3 å·¥å…·æ‰§è¡Œæ¥å£æŠ½è±¡

**ç»Ÿä¸€å·¥å…·æ‰§è¡Œæ¥å£**ï¼š
```java
public interface ToolExecutor {
    ToolResult execute(ToolCall toolCall);
    
    default ToolResult executeWithFallback(ToolCall toolCall) {
        try {
            return execute(toolCall);
        } catch (Exception e) {
            log.error("Tool execution failed: {}", toolCall.getName(), e);
            return ToolResult.builder()
                .success(false)
                .error(e.getMessage())
                .build();
        }
    }
}

public class ToolResult {
    private boolean success;
    private Object data;
    private String error;
    private long executionTime;
    private Map<String, Object> metadata;
}
```

**å‚æ•°å¯¹é½æœºåˆ¶**ï¼š
```java
public class ParameterAligner {
    public Map<String, Object> alignParameters(Map<String, Object> input, Map<String, Object> schema) {
        Map<String, Object> aligned = new HashMap<>();
        
        // 1. ç±»å‹è½¬æ¢
        for (Map.Entry<String, Object> entry : input.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            
            if (schema.containsKey(key)) {
                Object convertedValue = convertType(value, schema.get(key));
                aligned.put(key, convertedValue);
            }
        }
        
        // 2. é»˜è®¤å€¼å¡«å……
        Map<String, Object> properties = (Map<String, Object>) schema.get("properties");
        for (Map.Entry<String, Object> prop : properties.entrySet()) {
            String key = prop.getKey();
            Map<String, Object> propSchema = (Map<String, Object>) prop.getValue();
            
            if (!aligned.containsKey(key) && propSchema.containsKey("default")) {
                aligned.put(key, propSchema.get("default"));
            }
        }
        
        return aligned;
    }
}
```

### 11.5 æ§åˆ¶æµä¸è°ƒåº¦èƒ½åŠ›

#### 11.5.1 DAGå·¥ä½œæµè®¾è®¡

**ä»»åŠ¡ä¾èµ–å›¾æ„å»º**ï¼š
```java
public class WorkflowDAG {
    private Map<String, TaskNode> nodes = new HashMap<>();
    private Map<String, List<String>> dependencies = new HashMap<>();
    
    public void addTask(String taskId, String taskDescription) {
        nodes.put(taskId, new TaskNode(taskId, taskDescription));
    }
    
    public void addDependency(String fromTask, String toTask) {
        dependencies.computeIfAbsent(fromTask, k -> new ArrayList<>()).add(toTask);
    }
    
    public List<String> getExecutionOrder() {
        // æ‹“æ‰‘æ’åºç¡®å®šæ‰§è¡Œé¡ºåº
        return topologicalSort();
    }
}

public class TaskNode {
    private String id;
    private String description;
    private TaskStatus status = TaskStatus.PENDING;
    private Object result;
    private Exception error;
}
```

**å¹¶è¡Œæ‰§è¡Œå¼•æ“**ï¼š
```java
public class ParallelExecutor {
    private ExecutorService executor = Executors.newFixedThreadPool(10);
    
    public Map<String, Object> executeParallel(List<String> tasks) {
        Map<String, CompletableFuture<Object>> futures = new HashMap<>();
        
        // æäº¤æ‰€æœ‰ä»»åŠ¡
        for (String task : tasks) {
            CompletableFuture<Object> future = CompletableFuture.supplyAsync(() -> {
                return executeTask(task);
            }, executor);
            futures.put(task, future);
        }
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        Map<String, Object> results = new HashMap<>();
        for (Map.Entry<String, CompletableFuture<Object>> entry : futures.entrySet()) {
            try {
                results.put(entry.getKey(), entry.getValue().get());
            } catch (Exception e) {
                log.error("Task {} failed", entry.getKey(), e);
                results.put(entry.getKey(), "ERROR: " + e.getMessage());
            }
        }
        
        return results;
    }
}
```

#### 11.5.2 å¹‚ç­‰æ‰§è¡Œæœºåˆ¶

**ä»»åŠ¡å¹‚ç­‰æ€§ä¿è¯**ï¼š
```java
public class IdempotentExecutor {
    private Map<String, TaskResult> completedTasks = new ConcurrentHashMap<>();
    
    public TaskResult executeTask(String taskId, String taskDescription) {
        // æ£€æŸ¥æ˜¯å¦å·²æ‰§è¡Œ
        if (completedTasks.containsKey(taskId)) {
            log.info("Task {} already completed, returning cached result", taskId);
            return completedTasks.get(taskId);
        }
        
        // æ‰§è¡Œä»»åŠ¡
        TaskResult result = doExecute(taskId, taskDescription);
        
        // ç¼“å­˜ç»“æœ
        completedTasks.put(taskId, result);
        
        return result;
    }
}

public class TaskResult {
    private String taskId;
    private TaskStatus status;
    private Object data;
    private long executionTime;
    private String checksum; // ç”¨äºéªŒè¯ç»“æœä¸€è‡´æ€§
}
```

**å¤±è´¥å›æ»šæœºåˆ¶**ï¼š
```java
public class RollbackManager {
    private Stack<RollbackAction> actionStack = new Stack<>();
    
    public void executeWithRollback(Runnable action, Runnable rollback) {
        try {
            action.run();
            actionStack.push(new RollbackAction(rollback));
        } catch (Exception e) {
            log.error("Action failed, performing rollback", e);
            performRollback();
            throw e;
        }
    }
    
    private void performRollback() {
        while (!actionStack.isEmpty()) {
            RollbackAction action = actionStack.pop();
            try {
                action.getRollback().run();
            } catch (Exception e) {
                log.error("Rollback action failed", e);
            }
        }
    }
}
```

#### 11.5.3 ä¼˜å…ˆçº§è°ƒåº¦æœºåˆ¶

**ä»»åŠ¡ä¼˜å…ˆçº§ç®¡ç†**ï¼š
```java
public class PriorityScheduler {
    private PriorityBlockingQueue<Task> taskQueue = new PriorityBlockingQueue<>();
    
    public void submitTask(Task task) {
        taskQueue.offer(task);
    }
    
    public Task getNextTask() {
        return taskQueue.poll();
    }
}

public class Task implements Comparable<Task> {
    private String id;
    private int priority; // 1-10, 10ä¸ºæœ€é«˜ä¼˜å…ˆçº§
    private long submitTime;
    private String description;
    
    @Override
    public int compareTo(Task other) {
        // ä¼˜å…ˆçº§é«˜çš„å…ˆæ‰§è¡Œï¼ŒåŒä¼˜å…ˆçº§æŒ‰æäº¤æ—¶é—´æ’åº
        int priorityCompare = Integer.compare(other.priority, this.priority);
        if (priorityCompare != 0) {
            return priorityCompare;
        }
        return Long.compare(this.submitTime, other.submitTime);
    }
}
```

**å¼‚æ­¥ååŒæœºåˆ¶**ï¼š
```java
public class AsyncCoordinator {
    private Map<String, CompletableFuture<Void>> runningTasks = new ConcurrentHashMap<>();
    
    public CompletableFuture<Void> coordinateTasks(List<String> taskIds) {
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        
        for (String taskId : taskIds) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                executeTask(taskId);
            });
            runningTasks.put(taskId, future);
            futures.add(future);
        }
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
    }
    
    public void cancelTask(String taskId) {
        CompletableFuture<Void> future = runningTasks.get(taskId);
        if (future != null && !future.isDone()) {
            future.cancel(true);
            runningTasks.remove(taskId);
        }
    }
}
```

### 11.6 æ€§èƒ½ä¸ç³»ç»Ÿç›‘æ§èƒ½åŠ›

#### 11.6.1 æ€§èƒ½è¯„ä¼°ä½“ç³»

**å“åº”å»¶è¿Ÿç›‘æ§**ï¼š
```java
public class PerformanceMonitor {
    private Map<String, List<Long>> responseTimes = new ConcurrentHashMap<>();
    
    public void recordResponseTime(String agentType, long responseTime) {
        responseTimes.computeIfAbsent(agentType, k -> new ArrayList<>()).add(responseTime);
    }
    
    public PerformanceMetrics getMetrics(String agentType) {
        List<Long> times = responseTimes.get(agentType);
        if (times == null || times.isEmpty()) {
            return new PerformanceMetrics();
        }
        
        return PerformanceMetrics.builder()
            .avgResponseTime(times.stream().mapToLong(Long::longValue).average().orElse(0))
            .maxResponseTime(times.stream().mapToLong(Long::longValue).max().orElse(0))
            .minResponseTime(times.stream().mapToLong(Long::longValue).min().orElse(0))
            .p95ResponseTime(calculatePercentile(times, 95))
            .p99ResponseTime(calculatePercentile(times, 99))
            .build();
    }
}
```

**Tokenæˆæœ¬åˆ†æ**ï¼š
```java
public class TokenCounter {
    private int totalInputTokens = 0;
    private int totalOutputTokens = 0;
    private Map<String, Integer> modelTokenUsage = new HashMap<>();
    
    public void recordTokenUsage(String model, int inputTokens, int outputTokens) {
        totalInputTokens += inputTokens;
        totalOutputTokens += outputTokens;
        modelTokenUsage.merge(model, inputTokens + outputTokens, Integer::sum);
    }
    
    public CostAnalysis calculateCost() {
        // æ ¹æ®æ¨¡å‹å®šä»·è®¡ç®—æˆæœ¬
        double totalCost = 0.0;
        for (Map.Entry<String, Integer> entry : modelTokenUsage.entrySet()) {
            String model = entry.getKey();
            int tokens = entry.getValue();
            double costPerToken = getModelCost(model);
            totalCost += tokens * costPerToken;
        }
        
        return CostAnalysis.builder()
            .totalCost(totalCost)
            .totalTokens(totalInputTokens + totalOutputTokens)
            .modelUsage(modelTokenUsage)
            .build();
    }
}
```

#### 11.6.2 å†…å­˜æ£€ç´¢æ•ˆç‡ä¼˜åŒ–

**å‘é‡åŒ–æ£€ç´¢**ï¼š
```java
public class VectorMemory {
    private Map<String, float[]> embeddings = new HashMap<>();
    private List<float[]> memoryVectors = new ArrayList<>();
    private List<String> memoryTexts = new ArrayList<>();
    
    public void addMemory(String text) {
        float[] embedding = generateEmbedding(text);
        memoryVectors.add(embedding);
        memoryTexts.add(text);
    }
    
    public List<String> searchSimilar(String query, int topK) {
        float[] queryEmbedding = generateEmbedding(query);
        
        // è®¡ç®—ç›¸ä¼¼åº¦å¹¶æ’åº
        List<SimilarityResult> results = new ArrayList<>();
        for (int i = 0; i < memoryVectors.size(); i++) {
            float similarity = cosineSimilarity(queryEmbedding, memoryVectors.get(i));
            results.add(new SimilarityResult(memoryTexts.get(i), similarity));
        }
        
        return results.stream()
            .sorted(Comparator.comparing(SimilarityResult::getSimilarity).reversed())
            .limit(topK)
            .map(SimilarityResult::getText)
            .collect(Collectors.toList());
    }
}
```

**ç¼“å­˜ä¼˜åŒ–ç­–ç•¥**ï¼š
```java
public class MemoryCache {
    private Cache<String, Object> cache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(1, TimeUnit.HOURS)
        .build();
    
    public Object getOrCompute(String key, Supplier<Object> supplier) {
        return cache.get(key, k -> supplier.get());
    }
    
    public void invalidatePattern(String pattern) {
        cache.asMap().keySet().removeIf(key -> key.matches(pattern));
    }
}
```

#### 11.6.3 ç›‘æ§å·¥å…·é›†æˆ

**Tracingé›†æˆ**ï¼š
```java
public class TracingInterceptor {
    public <T> T trace(String operation, Supplier<T> supplier) {
        String traceId = generateTraceId();
        long startTime = System.currentTimeMillis();
        
        try {
            T result = supplier.get();
            recordSuccess(operation, traceId, System.currentTimeMillis() - startTime);
            return result;
        } catch (Exception e) {
            recordError(operation, traceId, e);
            throw e;
        }
    }
    
    private void recordSuccess(String operation, String traceId, long duration) {
        // è®°å½•åˆ°Jaeger/Zipkinç­‰åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿ
        log.info("Operation {} completed in {}ms, traceId: {}", operation, duration, traceId);
    }
}
```

**LangSmithé›†æˆ**ï¼š
```java
public class LangSmithTracker {
    private final String apiKey;
    private final String projectName;
    
    public void trackRun(String runId, String name, Map<String, Object> inputs, 
                        Map<String, Object> outputs, Map<String, Object> metadata) {
        // å‘é€åˆ°LangSmithè¿›è¡Œç›‘æ§å’Œåˆ†æ
        LangSmithRun run = LangSmithRun.builder()
            .id(runId)
            .name(name)
            .inputs(inputs)
            .outputs(outputs)
            .metadata(metadata)
            .build();
        
        sendToLangSmith(run);
    }
}
```

### 11.7 å®‰å…¨æ€§ä¸åˆè§„æ„è¯†

#### 11.7.1 æƒé™è¾¹ç•Œè®¾è®¡

**å¤šå±‚çº§æƒé™æ§åˆ¶**ï¼š
```java
public class SecurityManager {
    private Map<String, Set<String>> userPermissions = new HashMap<>();
    private Map<String, Set<String>> toolPermissions = new HashMap<>();
    
    public boolean canAccessTool(String userId, String toolName) {
        Set<String> userPerms = userPermissions.get(userId);
        Set<String> toolPerms = toolPermissions.get(toolName);
        
        if (userPerms == null || toolPerms == null) {
            return false;
        }
        
        return !Collections.disjoint(userPerms, toolPerms);
    }
    
    public void validateInput(String input) {
        // è¾“å…¥éªŒè¯
        if (input.length() > MAX_INPUT_LENGTH) {
            throw new SecurityException("Input too long");
        }
        
        // æ•æ„Ÿè¯è¿‡æ»¤
        if (containsSensitiveWords(input)) {
            throw new SecurityException("Input contains sensitive content");
        }
    }
}
```

**æ•°æ®è®¿é—®æ§åˆ¶**ï¼š
```java
public class DataAccessControl {
    public boolean canAccessFile(String userId, String filePath) {
        // æ£€æŸ¥æ–‡ä»¶æƒé™
        FilePermission permission = getFilePermission(filePath);
        return permission.canRead(userId);
    }
    
    public String sanitizeOutput(String output) {
        // è¾“å‡ºè„±æ•
        return StringUtil.textDesensitization(output, sensitivePatterns);
    }
}
```

#### 11.7.2 Promptæ³¨å…¥é˜²æŠ¤

**è¾“å…¥éªŒè¯æœºåˆ¶**ï¼š
```java
public class PromptInjectionDetector {
    private static final List<Pattern> injectionPatterns = Arrays.asList(
        Pattern.compile("(?i)ignore.*previous.*instructions"),
        Pattern.compile("(?i)system.*prompt"),
        Pattern.compile("(?i)role.*play"),
        Pattern.compile("(?i)pretend.*to.*be")
    );
    
    public boolean detectInjection(String input) {
        for (Pattern pattern : injectionPatterns) {
            if (pattern.matcher(input).find()) {
                return true;
            }
        }
        return false;
    }
    
    public String sanitizePrompt(String prompt) {
        // ç§»é™¤å¯èƒ½çš„æ³¨å…¥å†…å®¹
        String sanitized = prompt;
        for (Pattern pattern : injectionPatterns) {
            sanitized = pattern.matcher(sanitized).replaceAll("");
        }
        return sanitized;
    }
}
```

**ä¸Šä¸‹æ–‡éš”ç¦»**ï¼š
```java
public class ContextIsolation {
    private final String systemPrompt;
    private final String userPrompt;
    
    public String buildSafePrompt(String userInput) {
        // ç¡®ä¿ç³»ç»Ÿæç¤ºè¯ä¸è¢«ç”¨æˆ·è¾“å…¥è¦†ç›–
        return String.format("""
            %s
            
            User: %s
            
            Assistant: Let me help you with that. I'll follow the guidelines and provide a helpful response.
            """, systemPrompt, sanitizeInput(userInput));
    }
}
```

#### 11.7.3 å®¡è®¡ä¸åˆè§„å›æº¯

**æ“ä½œæ—¥å¿—è®°å½•**ï¼š
```java
public class AuditLogger {
    public void logOperation(String userId, String operation, Map<String, Object> details) {
        AuditLog log = AuditLog.bui