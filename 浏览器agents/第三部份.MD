# 浏览器Agent开发详解 - 第二部分：开发指南

## 目录
1. [开发指南](#开发指南)
2. [源码分析](#源码分析)
3. [最佳实践](#最佳实践)

## 开发指南

### 1. 环境准备

#### 基础依赖安装
```bash
# 创建conda虚拟环境
conda create -n browser-agent python=3.11
conda activate browser-agent

# 安装核心依赖
pip install browser-use
pip install lmnr-index
pip install playwright
playwright install chromium

# 安装开发工具
pip install pytest
pip install black
pip install mypy
```

#### 环境配置
```bash
# 创建.env文件配置API密钥
cat > .env << EOF
OPENAI_API_KEY=your_openai_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key
GEMINI_API_KEY=your_gemini_api_key
EOF
```

### 2. 基础Agent开发

#### 使用Browser-Use开发简单Agent
```python
import asyncio
from browser_use import Agent
from browser_use.llm import ChatOpenAI

async def basic_agent_example():
    """基础Agent示例"""
    # 创建Agent实例
    agent = Agent(
        task="访问百度首页并搜索'Python教程'",
        llm=ChatOpenAI(model="gpt-4o", temperature=0.1),
    )
    
    # 运行Agent
    history = await agent.run()
    
    # 输出结果
    print(f"任务完成，共执行{len(history.steps)}步")
    print(f"最终URL: {history.final_url}")
    print(f"最终内容: {history.final_content[:200]}...")

if __name__ == "__main__":
    asyncio.run(basic_agent_example())
```

#### 使用Index开发结构化输出Agent
```python
import asyncio
from index import Agent, GeminiProvider
from pydantic import BaseModel
from typing import List

class SearchResult(BaseModel):
    title: str
    url: str
    description: str

class SearchResults(BaseModel):
    results: List[SearchResult]
    total_count: int

async def structured_output_example():
    """结构化输出示例"""
    # 创建LLM提供者
    llm = GeminiProvider(model="gemini-2.5-pro")
    
    # 创建Agent
    agent = Agent(llm=llm)
    
    # 执行任务并获取结构化输出
    output = await agent.run(
        prompt="访问百度首页，搜索'Python教程'，提取前3个搜索结果的标题、URL和描述",
        output_model=SearchResults
    )
    
    # 解析结果
    results = SearchResults.model_validate(output.result.content)
    
    print(f"找到 {results.total_count} 个结果:")
    for i, result in enumerate(results.results, 1):
        print(f"{i}. {result.title}")
        print(f"   URL: {result.url}")
        print(f"   描述: {result.description}")
        print()

if __name__ == "__main__":
    asyncio.run(structured_output_example())
```

### 3. 自定义动作开发

#### Browser-Use自定义动作
```python
from browser_use.controller import Controller
from browser_use.core.views import ActionResult
from playwright.async_api import Page
import asyncio

# 创建控制器
controller = Controller()

@controller.registry.action("自定义搜索动作")
async def custom_search(query: str, page: Page):
    """在指定网站执行搜索"""
    try:
        # 导航到搜索页面
        await page.goto("https://www.example.com/search")
        
        # 等待搜索框加载
        await page.wait_for_selector("#search-input", timeout=10000)
        
        # 填写搜索框
        await page.fill("#search-input", query)
        
        # 点击搜索按钮
        await page.click("#search-button")
        
        # 等待结果加载
        await page.wait_for_selector(".search-results", timeout=10000)
        
        # 提取搜索结果
        results = await page.query_selector_all(".result-item")
        extracted_data = []
        
        for result in results[:5]:  # 取前5个结果
            title_elem = await result.query_selector(".title")
            title_text = await title_elem.text_content() if title_elem else ""
            
            link_elem = await result.query_selector("a")
            link_href = await link_elem.get_attribute("href") if link_elem else ""
            
            desc_elem = await result.query_selector(".description")
            desc_text = await desc_elem.text_content() if desc_elem else ""
            
            extracted_data.append({
                "title": title_text.strip(),
                "url": link_href,
                "description": desc_text.strip()
            })
        
        return ActionResult(
            extracted_content=extracted_data,
            include_in_memory=True,
            success=True
        )
        
    except Exception as e:
        return ActionResult(
            success=False,
            error=str(e),
            include_in_memory=True
        )

# 使用自定义动作
async def use_custom_action():
    from browser_use import Agent
    from browser_use.llm import ChatOpenAI
    
    agent = Agent(
        task="使用自定义搜索功能搜索'机器学习教程'",
        llm=ChatOpenAI(model="gpt-4o"),
        controller=controller
    )
    
    history = await agent.run()
    return history

if __name__ == "__main__":
    asyncio.run(use_custom_action())
```

### 4. 错误处理和重试机制

#### 基础重试机制
```python
import asyncio
from typing import Callable, Any, Optional
from functools import wraps

class RetryManager:
    def __init__(self, max_retries: int = 3, base_delay: float = 1.0):
        self.max_retries = max_retries
        self.base_delay = base_delay
    
    async def retry_with_backoff(
        self, 
        func: Callable, 
        *args, 
        **kwargs
    ) -> Any:
        """指数退避重试机制"""
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                if asyncio.iscoroutinefunction(func):
                    result = await func(*args, **kwargs)
                else:
                    result = func(*args, **kwargs)
                return result
                
            except Exception as e:
                last_exception = e
                print(f"尝试 {attempt + 1}/{self.max_retries} 失败: {e}")
                
                if attempt < self.max_retries - 1:
                    delay = self.base_delay * (2 ** attempt)
                    print(f"等待 {delay} 秒后重试...")
                    await asyncio.sleep(delay)
        
        raise last_exception

# 装饰器版本
def retry_on_failure(max_retries: int = 3, base_delay: float = 1.0):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            retry_manager = RetryManager(max_retries, base_delay)
            return await retry_manager.retry_with_backo