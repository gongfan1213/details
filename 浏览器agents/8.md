# Selenium高级功能详解 - 基于Steel-Browser项目实战

## 目录
1. [高级等待策略](#高级等待策略)
2. [自定义WebDriver](#自定义WebDriver)
3. [分布式测试](#分布式测试)
4. [移动端测试](#移动端测试)
5. [性能监控](#性能监控)
6. [安全测试](#安全测试)
7. [CI/CD集成](#cicd集成)

## 高级等待策略

### 1. 自定义等待条件

```typescript
import { Builder, By, until, WebDriver, Condition } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// 自定义等待条件
class CustomConditions {
  // 等待元素包含特定文本
  static elementTextContains(locator: By, text: string): Condition<boolean> {
    return new Condition(`element text contains "${text}"`, async (driver) => {
      try {
        const element = await driver.findElement(locator);
        const elementText = await element.getText();
        return elementText.includes(text);
      } catch {
        return false;
      }
    });
  }

  // 等待元素数量达到指定值
  static elementCountIs(locator: By, count: number): Condition<boolean> {
    return new Condition(`element count is ${count}`, async (driver) => {
      const elements = await driver.findElements(locator);
      return elements.length === count;
    });
  }

  // 等待元素可见且可点击
  static elementIsClickable(locator: By): Condition<boolean> {
    return new Condition('element is clickable', async (driver) => {
      try {
        const element = await driver.findElement(locator);
        const isDisplayed = await element.isDisplayed();
        const isEnabled = await element.isEnabled();
        return isDisplayed && isEnabled;
      } catch {
        return false;
      }
    });
  }

  // 等待页面完全加载
  static pageFullyLoaded(): Condition<boolean> {
    return new Condition('page fully loaded', async (driver) => {
      const readyState = await driver.executeScript('return document.readyState;');
      return readyState === 'complete';
    });
  }

  // 等待AJAX请求完成
  static ajaxCompleted(): Condition<boolean> {
    return new Condition('ajax completed', async (driver) => {
      const activeRequests = await driver.executeScript(`
        return window.jQuery ? window.jQuery.active : 0;
      `);
      return activeRequests === 0;
    });
  }
}

// 使用自定义等待条件
async function customWaitExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    await driver.get('https://example.com');
    
    // 等待页面完全加载
    await driver.wait(CustomConditions.pageFullyLoaded(), 30000);
    
    // 等待特定文本出现
    await driver.wait(
      CustomConditions.elementTextContains(By.css('.status'), 'Success'), 
      10000
    );
    
    // 等待元素数量
    await driver.wait(
      CustomConditions.elementCountIs(By.css('.item'), 5), 
      10000
    );
    
    // 等待元素可点击
    await driver.wait(
      CustomConditions.elementIsClickable(By.css('.submit-button')), 
      10000
    );
    
    // 等待AJAX完成
    await driver.wait(CustomConditions.ajaxCompleted(), 10000);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

### 2. 智能等待策略

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

class SmartWait {
  private driver: WebDriver;
  private defaultTimeout: number;
  
  constructor(driver: WebDriver, defaultTimeout: number = 10000) {
    this.driver = driver;
    this.defaultTimeout = defaultTimeout;
  }
  
  // 智能等待元素出现
  async waitForElement(locator: By, timeout?: number): Promise<WebElement> {
    const waitTimeout = timeout || this.defaultTimeout;
    const startTime = Date.now();
    
    while (Date.now() - startTime < waitTimeout) {
      try {
        const element = await this.driver.findElement(locator);
        if (await element.isDisplayed()) {
          return element;
        }
      } catch (error) {
        // 元素不存在或不可见，继续等待
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    throw new Error(`Element not found within ${waitTimeout}ms`);
  }
  
  // 等待元素消失
  async waitForElementToDisappear(locator: By, timeout?: number): Promise<void> {
    const waitTimeout = timeout || this.defaultTimeout;
    const startTime = Date.now();
    
    while (Date.now() - startTime < waitTimeout) {
      try {
        const element = await this.driver.findElement(locator);
        if (!(await element.isDisplayed())) {
          return;
        }
      } catch (error) {
        // 元素不存在，认为已消失
        return;
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    throw new Error(`Element did not disappear within ${waitTimeout}ms`);
  }
  
  // 等待页面稳定（无DOM变化）
  async waitForPageStable(timeout?: number): Promise<void> {
    const waitTimeout = timeout || this.defaultTimeout;
    const startTime = Date.now();
    let lastDOMHash = '';
    
    while (Date.now() - startTime < waitTimeout) {
      const currentDOMHash = await this.driver.executeScript(`
        return document.body.innerHTML.length + '_' + 
               document.querySelectorAll('*').length;
      `);
      
      if (currentDOMHash === lastDOMHash) {
        return; // 页面稳定
      }
      
      lastDOMHash = currentDOMHash;
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    throw new Error(`Page did not stabilize within ${waitTimeout}ms`);
  }
  
  // 等待网络空闲
  async waitForNetworkIdle(timeout?: number): Promise<void> {
    const waitTimeout = timeout || this.defaultTimeout;
    const startTime = Date.now();
    let lastRequestCount = 0;
    
    while (Date.now() - startTime < waitTimeout) {
      const currentRequestCount = await this.driver.executeScript(`
        return window.performance.getEntriesByType('resource').length;
      `);
      
      if (currentRequestCount === lastRequestCount) {
        return; // 网络空闲
      }
      
      lastRequestCount = currentRequestCount;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    throw new Error(`Network did not become idle within ${waitTimeout}ms`);
  }
}

// 使用智能等待
async function smartWaitExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const smartWait = new SmartWait(driver, 15000);
    
    await driver.get('https://example.com');
    
    // 等待页面稳定
    await smartWait.waitForPageStable();
    
    // 等待元素出现
    const element = await smartWait.waitForElement(By.css('.dynamic-content'));
    
    // 等待网络空闲
    await smartWait.waitForNetworkIdle();
    
    // 等待元素消失
    await smartWait.waitForElementToDisappear(By.css('.loading-spinner'));
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## 自定义WebDriver

### 1. 扩展WebDriver功能

```typescript
import { Builder, By, until, WebDriver, WebElement } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// 扩展的WebDriver类
class ExtendedWebDriver extends WebDriver {
  private originalDriver: WebDriver;
  
  constructor(driver: WebDriver) {
    super();
    this.originalDriver = driver;
  }
  
  // 获取原始驱动
  getDriver(): WebDriver {
    return this.originalDriver;
  }
  
  // 高亮元素
  async highlightElement(element: WebElement, color: string = 'red'): Promise<void> {
    await this.executeScript(`
      arguments[0].style.border = '3px solid ${color}';
      arguments[0].style.backgroundColor = 'yellow';
    `, element);
  }
  
  // 滚动到元素
  async scrollToElement(element: WebElement): Promise<void> {
    await this.executeScript('arguments[0].scrollIntoView({behavior: "smooth", block: "center"});', element);
  }
  
  // 获取元素截图
  async takeElementScreenshot(element: WebElement): Promise<string> {
    return await element.takeScreenshot();
  }
  
  // 执行JavaScript并等待
  async executeScriptAndWait(script: string, ...args: any[]): Promise<any> {
    const result = await this.executeScript(script, ...args);
    await new Promise(resolve => setTimeout(resolve, 1000));
    return result;
  }
  
  // 获取页面性能指标
  async getPerformanceMetrics(): Promise<any> {
    return await this.executeScript(`
      const performance = window.performance;
      return {
        navigationStart: performance.timing.navigationStart,
        loadEventEnd: performance.timing.loadEventEnd,
        domContentLoadedEventEnd: performance.timing.domContentLoadedEventEnd,
        responseEnd: performance.timing.responseEnd,
        requestStart: performance.timing.requestStart,
        loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
        domReadyTime: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart
      };
    `);
  }
  
  // 模拟用户输入
  async typeLikeHuman(element: WebElement, text: string): Promise<void> {
    for (const char of text) {
      await element.sendKeys(char);
      await new Promise(resolve => setTimeout(resolve, Math.random() * 100 + 50));
    }
  }
  
  // 等待并点击元素
  async waitAndClick(locator: By, timeout: number = 10000): Promise<void> {
    const element = await this.wait(until.elementLocated(locator), timeout);
    await this.wait(until.elementIsVisible(element), timeout);
    await element.click();
  }
  
  // 等待并输入文本
  async waitAndType(locator: By, text: string, timeout: number = 10000): Promise<void> {
    const element = await this.wait(until.elementLocated(locator), timeout);
    await this.wait(until.elementIsVisible(element), timeout);
    await element.clear();
    await element.sendKeys(text);
  }
  
  // 获取所有cookies
  async getAllCookies(): Promise<any[]> {
    return await this.manage().getCookies();
  }
  
  // 设置cookie
  async setCookie(name: string, value: string, domain?: string): Promise<void> {
    const cookie = {
      name,
      value,
      domain: domain || await this.executeScript('return window.location.hostname;')
    };
    await this.manage().addCookie(cookie);
  }
  
  // 清除所有cookies
  async clearAllCookies(): Promise<void> {
    await this.manage().deleteAllCookies();
  }
  
  // 获取本地存储
  async getLocalStorage(key: string): Promise<string | null> {
    return await this.executeScript(`return localStorage.getItem('${key}');`);
  }
  
  // 设置本地存储
  async setLocalStorage(key: string, value: string): Promise<void> {
    await this.executeScript(`localStorage.setItem('${key}', '${value}');`);
  }
  
  // 清除本地存储
  async clearLocalStorage(): Promise<void> {
    await this.executeScript('localStorage.clear();');
  }
  
  // 获取会话存储
  async getSessionStorage(key: string): Promise<string | null> {
    return await this.executeScript(`return sessionStorage.getItem('${key}');`);
  }
  
  // 设置会话存储
  async setSessionStorage(key: string, value: string): Promise<void> {
    await this.executeScript(`sessionStorage.setItem('${key}', '${value}');`);
  }
  
  // 清除会话存储
  async clearSessionStorage(): Promise<void> {
    await this.executeScript('sessionStorage.clear();');
  }
}

// 创建扩展的WebDriver
async function createExtendedDriver(): Promise<ExtendedWebDriver> {
  const options = new chrome.Options();
  options.addArguments('--no-sandbox');
  
  const driver = await new Builder()
    .forBrowser('chrome')
    .setChromeOptions(options)
    .build();
  
  return new ExtendedWebDriver(driver);
}

// 使用扩展的WebDriver
async function extendedDriverExample() {
  let driver: ExtendedWebDriver;
  
  try {
    driver = await createExtendedDriver();
    
    await driver.get('https://example.com');
    
    // 获取性能指标
    const metrics = await driver.getPerformanceMetrics();
    console.log('页面加载时间:', metrics.loadTime, 'ms');
    
    // 等待并点击元素
    await driver.waitAndClick(By.css('.button'));
    
    // 等待并输入文本
    await driver.waitAndType(By.css('input[type="text"]'), 'Hello World');
    
    // 高亮元素
    const element = await driver.findElement(By.css('.target'));
    await driver.highlightElement(element, 'blue');
    
    // 滚动到元素
    await driver.scrollToElement(element);
    
    // 模拟人类输入
    const inputElement = await driver.findElement(By.css('input[type="text"]'));
    await driver.typeLikeHuman(inputElement, 'This is typed like a human');
    
    // 设置cookie
    await driver.setCookie('test-cookie', 'test-value');
    
    // 设置本地存储
    await driver.setLocalStorage('test-key', 'test-value');
    
    // 获取存储的值
    const cookieValue = await driver.getAllCookies();
    const localStorageValue = await driver.getLocalStorage('test-key');
    
    console.log('Cookies:', cookieValue);
    console.log('LocalStorage:', localStorageValue);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

### 2. 自定义元素类

```typescript
import { WebElement, By, until } from 'selenium-webdriver';

// 扩展的WebElement类
class ExtendedWebElement extends WebElement {
  private driver: any;
  private element: WebElement;
  
  constructor(driver: any, element: WebElement) {
    super();
    this.driver = driver;
    this.element = element;
  }
  
  // 获取原始元素
  getElement(): WebElement {
    return this.element;
  }
  
  // 等待元素可见
  async waitForVisible(timeout: number = 10000): Promise<void> {
    await this.driver.wait(until.elementIsVisible(this.element), timeout);
  }
  
  // 等待元素可点击
  async waitForClickable(timeout: number = 10000): Promise<void> {
    await this.driver.wait(until.elementIsEnabled(this.element), timeout);
    await this.driver.wait(until.elementIsVisible(this.element), timeout);
  }
  
  // 安全点击
  async safeClick(): Promise<void> {
    await this.waitForClickable();
    await this.driver.executeScript('arguments[0].click();', this.element);
  }
  
  // 安全输入
  async safeType(text: string): Promise<void> {
    await this.waitForVisible();
    await this.element.clear();
    await this.element.sendKeys(text);
  }
  
  // 获取文本内容
  async getTextContent(): Promise<string> {
    return await this.driver.executeScript(
      'return arguments[0].textContent || arguments[0].innerText;', 
      this.element
    );
  }
  
  // 获取属性值
  async getAttributeValue(attribute: string): Promise<string> {
    return await this.element.getAttribute(attribute);
  }
  
  // 检查元素是否存在
  async isPresent(): Promise<boolean> {
    try {
      await this.element.isDisplayed();
      return true;
    } catch {
      return false;
    }
  }
  
  // 检查元素是否可见
  async isVisible(): Promise<boolean> {
    try {
      return await this.element.isDisplayed();
    } catch {
      return false;
    }
  }
  
  // 检查元素是否启用
  async isEnabled(): Promise<boolean> {
    try {
      return await this.element.isEnabled();
    } catch {
      return false;
    }
  }
  
  // 获取元素位置和大小
  async getRect(): Promise<{ x: number; y: number; width: number; height: number }> {
    return await this.element.getRect();
  }
  
  // 获取元素CSS属性
  async getCssValue(propertyName: string): Promise<string> {
    return await this.element.getCssValue(propertyName);
  }
  
  // 悬停元素
  async hover(): Promise<void> {
    const actions = this.driver.actions({ async: true });
    await actions.move({ origin: this.element }).perform();
  }
  
  // 双击元素
  async doubleClick(): Promise<void> {
    const actions = this.driver.actions({ async: true });
    await actions.doubleClick(this.element).perform();
  }
  
  // 右键点击元素
  async rightClick(): Promise<void> {
    const actions = this.driver.actions({ async: true });
    await actions.contextClick(this.element).perform();
  }
  
  // 拖拽元素
  async dragTo(targetElement: ExtendedWebElement): Promise<void> {
    const actions = this.driver.actions({ async: true });
    await actions
      .dragAndDrop(this.element, targetElement.getElement())
      .perform();
  }
  
  // 获取子元素
  async findChild(locator: By): Promise<ExtendedWebElement> {
    const childElement = await this.element.findElement(locator);
    return new ExtendedWebElement(this.driver, childElement);
  }
  
  // 获取所有子元素
  async findChildren(locator: By): Promise<ExtendedWebElement[]> {
    const childElements = await this.element.findElements(locator);
    return childElements.map(element => new ExtendedWebElement(this.driver, element));
  }
  
  // 获取父元素
  async getParent(): Promise<ExtendedWebElement> {
    const parentElement = await this.driver.executeScript(
      'return arguments[0].parentElement;', 
      this.element
    );
    return new ExtendedWebElement(this.driver, parentElement);
  }
  
  // 获取兄弟元素
  async getSiblings(): Promise<ExtendedWebElement[]> {
    const siblingElements = await this.driver.executeScript(`
      const siblings = [];
      let sibling = arguments[0].nextElementSibling;
      while (sibling) {
        siblings.push(sibling);
        sibling = sibling.nextElementSibling;
      }
      return siblings;
    `, this.element);
    
    return siblingElements.map((element: WebElement) => 
      new ExtendedWebElement(this.driver, element)
    );
  }
}

// 使用扩展的元素类
async function extendedElementExample() {
  let driver: any;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    await driver.get('https://example.com');
    
    // 创建扩展元素
    const element = new ExtendedWebElement(driver, await driver.findElement(By.css('.target')));
    
    // 等待元素可见
    await element.waitForVisible();
    
    // 安全点击
    await element.safeClick();
    
    // 获取文本内容
    const text = await element.getTextContent();
    console.log('元素文本:', text);
    
    // 获取属性
    const href = await element.getAttributeValue('href');
    console.log('链接地址:', href);
    
    // 检查元素状态
    console.log('元素存在:', await element.isPresent());
    console.log('元素可见:', await element.isVisible());
    console.log('元素启用:', await element.isEnabled());
    
    // 获取元素位置
    const rect = await element.getRect();
    console.log('元素位置:', rect);
    
    // 悬停元素
    await element.hover();
    
    // 获取子元素
    const childElement = await element.findChild(By.css('.child'));
    await childElement.safeClick();
    
    // 获取兄弟元素
    const siblings = await element.getSiblings();
    console.log('兄弟元素数量:', siblings.length);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## 分布式测试

### 1. Selenium Grid配置

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// Selenium Grid配置
class SeleniumGridConfig {
  private hubUrl: string;
  private capabilities: any;
  
  constructor(hubUrl: string, capabilities: any) {
    this.hubUrl = hubUrl;
    this.capabilities = capabilities;
  }
  
  // 创建连接到Grid的WebDriver
  async createDriver(): Promise<WebDriver> {
    return await new Builder()
      .usingServer(this.hubUrl)
      .forBrowser('chrome')
      .withCapabilities(this.capabilities)
      .build();
  }
  
  // 获取可用节点信息
  async getAvailableNodes(): Promise<any[]> {
    const response = await fetch(`${this.hubUrl}/grid/api/hub`);
    const data = await response.json();
    return data.slots || [];
  }
  
  // 获取节点状态
  async getNodeStatus(nodeId: string): Promise<any> {
    const response = await fetch(`${this.hubUrl}/grid/api/proxy?id=${nodeId}`);
    return await response.json();
  }
}

// 分布式测试管理器
class DistributedTestManager {
  private gridConfigs: SeleniumGridConfig[];
  private testQueue: TestTask[];
  private runningTests: Map<string, TestTask>;
  
  constructor(gridConfigs: SeleniumGridConfig[]) {
    this.gridConfigs = gridConfigs;
    this.testQueue = [];
    this.runningTests = new Map();
  }
  
  // 添加测试任务
  addTestTask(task: TestTask): void {
    this.testQueue.push(task);
  }
  
  // 执行所有测试
  async runAllTests(): Promise<TestResult[]> {
    const results: TestResult[] = [];
    const maxConcurrentTests = this.gridConfigs.length;
    
    while (this.testQueue.length > 0 || this.runningTests.size > 0) {
      // 启动新的测试
      while (this.runningTests.size < maxConcurrentTests && this.testQueue.length > 0) {
        const task = this.testQueue.shift()!;
        const gridConfig = this.gridConfigs[this.runningTests.size];
        
        this.runningTests.set(task.id, task);
        this.runTestTask(task, gridConfig).then(result => {
          results.push(result);
          this.runningTests.delete(task.id);
        });
      }
      
      // 等待一段时间
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    return results;
  }
  
  // 执行单个测试任务
  private async runTestTask(task: TestTask, gridConfig: SeleniumGridConfig): Promise<TestResult> {
    let driver: WebDriver | null = null;
    const startTime = Date.now();
    
    try {
      driver = await gridConfig.createDriver();
      
      // 执行测试
      await task.testFunction(driver);
      
      return {
        taskId: task.id,
        status: 'PASSED',
        duration: Date.now() - startTime,
        error: null
      };
      
    } catch (error) {
      return {
        taskId: task.id,
        status: 'FAILED',
        duration: Date.now() - startTime,
        error: error instanceof Error ? error.message : String(error)
      };
      
    } finally {
      if (driver) {
        await driver.quit();
      }
    }
  }
}

interface TestTask {
  id: string;
  name: string;
  testFunction: (driver: WebDriver) => Promise<void>;
}

interface TestResult {
  taskId: string;
  status: 'PASSED' | 'FAILED';
  duration: number;
  error: string | null;
}

// 使用分布式测试
async function distributedTestExample() {
  // 配置多个Grid节点
  const gridConfigs = [
    new SeleniumGridConfig('http://grid-hub-1:4444', {
      browserName: 'chrome',
      platform: 'WINDOWS'
    }),
    new SeleniumGridConfig('http://grid-hub-2:4444', {
      browserName: 'chrome',
      platform: 'LINUX'
    }),
    new SeleniumGridConfig('http://grid-hub-3:4444', {
      browserName: 'chrome',
      platform: 'MAC'
    })
  ];
  
  const testManager = new DistributedTestManager(gridConfigs);
  
  // 添加测试任务
  testManager.addTestTask({
    id: 'test-1',
    name: '百度搜索测试',
    testFunction: async (driver: WebDriver) => {
      await driver.get('https://www.baidu.com');
      await driver.findElement(By.id('kw')).sendKeys('Selenium');
      await driver.findElement(By.id('su')).click();
      await driver.wait(until.elementLocated(By.css('.result')), 10000);
    }
  });
  
  testManager.addTestTask({
    id: 'test-2',
    name: '表单填写测试',
    testFunction: async (driver: WebDriver) => {
      await driver.get('https://httpbin.org/forms/post');
      await driver.findElement(By.name('custname')).sendKeys('Test User');
      await driver.findElement(By.css('input[type="submit"]')).click();
      await driver.wait(until.elementLocated(By.tagName('pre')), 10000);
    }
  });
  
  // 执行所有测试
  const results = await testManager.runAllTests();
  
  // 输出结果
  console.log('测试结果:');
  results.forEach(result => {
    console.log(`${result.taskId}: ${result.status} (${result.duration}ms)`);
    if (result.error) {
      console.log(`  错误: ${result.error}`);
    }
  });
}
```

### 2. 负载测试

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// 负载测试管理器
class LoadTestManager {
  private concurrentUsers: number;
  private testDuration: number;
  private rampUpTime: number;
  private testFunction: (driver: WebDriver) => Promise<void>;
  private results: LoadTestResult[];
  
  constructor(
    concurrentUsers: number,
    testDuration: number,
    rampUpTime: number,
    testFunction: (driver: WebDriver) => Promise<void>
  ) {
    this.concurrentUsers = concurrentUsers;
    this.testDuration = testDuration;
    this.rampUpTime = rampUpTime;
    this.testFunction = testFunction;
    this.results = [];
  }
  
  // 执行负载测试
  async runLoadTest(): Promise<LoadTestReport> {
    const startTime = Date.now();
    const userPromises: Promise<void>[] = [];
    
    // 创建并发用户
    for (let i = 0; i < this.concurrentUsers; i++) {
      const userStartDelay = (i * this.rampUpTime) / this.concurrentUsers;
      
      const userPromise = this.runUserTest(i, userStartDelay);
      userPromises.push(userPromise);
    }
    
    // 等待所有用户完成
    await Promise.all(userPromises);
    
    const endTime = Date.now();
    const totalDuration = endTime - startTime;
    
    return this.generateReport(totalDuration);
  }
  
  // 运行单个用户测试
  private async runUserTest(userId: number, startDelay: number): Promise<void> {
    // 等待启动延迟
    await new Promise(resolve => setTimeout(resolve, startDelay));
    
    let driver: WebDriver | null = null;
    const userStartTime = Date.now();
    
    try {
      // 创建WebDriver
      const options = new chrome.Options();
      options.addArguments('--no-sandbox', '--headless');
      
      driver = await new Builder()
        .forBrowser('chrome')
        .setChromeOptions(options)
        .build();
      
      // 执行测试
      await this.testFunction(driver);
      
      const duration = Date.now() - userStartTime;
      
      this.results.push({
        userId,
        status: 'SUCCESS',
        duration,
        startTime: userStartTime,
        endTime: Date.now()
      });
      
    } catch (error) {
      const duration = Date.now() - userStartTime;
      
      this.results.push({
        userId,
        status: 'FAILED',
        duration,
        startTime: userStartTime,
        endTime: Date.now(),
        error: error instanceof Error ? error.message : String(error)
      });
      
    } finally {
      if (driver) {
        await driver.quit();
      }
    }
  }
  
  // 生成测试报告
  private generateReport(totalDuration: number): LoadTestReport {
    const successfulTests = this.results.filter(r => r.status === 'SUCCESS');
    const failedTests = this.results.filter(r => r.status === 'FAILED');
    
    const avgResponseTime = successfulTests.length > 0 
      ? successfulTests.reduce((sum, r) => sum + r.duration, 0) / successfulTests.length 
      : 0;
    
    const minResponseTime = successfulTests.length > 0 
      ? Math.min(...successfulTests.map(r => r.duration)) 
      : 0;
    
    const maxResponseTime = successfulTests.length > 0 
      ? Math.max(...successfulTests.map(r => r.duration)) 
      : 0;
    
    const throughput = (successfulTests.length / totalDuration) * 1000; // 请求/秒
    
    return {
      totalTests: this.results.length,
      successfulTests: successfulTests.length,
      failedTests: failedTests.length,
      successRate: (successfulTests.length / this.results.length) * 100,
      avgResponseTime,
      minResponseTime,
      maxResponseTime,
      throughput,
      totalDuration,
      results: this.results
    };
  }
}

interface LoadTestResult {
  userId: number;
  status: 'SUCCESS' | 'FAILED';
  duration: number;
  startTime: number;
  endTime: number;
  error?: string;
}

interface LoadTestReport {
  totalTests: number;
  successfulTests: number;
  failedTests: number;
  successRate: number;
  avgResponseTime: number;
  minResponseTime: number;
  maxResponseTime: number;
  throughput: number;
  totalDuration: number;
  results: LoadTestResult[];
}

// 使用负载测试
async function loadTestExample() {
  // 定义测试场景
  const testScenario = async (driver: WebDriver) => {
    await driver.get('https://example.com');
    await driver.findElement(By.css('.search-input')).sendKeys('test');
    await driver.findElement(By.css('.search-button')).click();
    await driver.wait(until.elementLocated(By.css('.search-results')), 10000);
  };
  
  // 创建负载测试管理器
  const loadTest = new LoadTestManager(
    10,    // 10个并发用户
    60000, // 60秒测试时间
    10000, // 10秒爬升时间
    testScenario
  );
  
  // 执行负载测试
  const report = await loadTest.runLoadTest();
  
  // 输出报告
  console.log('📊 负载测试报告');
  console.log('=' * 50);
  console.log(`总测试数: ${report.totalTests}`);
  console.log(`成功测试: ${report.successfulTests}`);
  console.log(`失败测试: ${report.failedTests}`);
  console.log(`成功率: ${report.successRate.toFixed(2)}%`);
  console.log(`平均响应时间: ${report.avgResponseTime.toFixed(2)}ms`);
  console.log(`最小响应时间: ${report.minResponseTime}ms`);
  console.log(`最大响应时间: ${report.maxResponseTime}ms`);
  console.log(`吞吐量: ${report.throughput.toFixed(2)} 请求/秒`);
  console.log(`总测试时间: ${report.totalDuration}ms`);
}
```

## 移动端测试

### 1. 移动端WebDriver配置

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// 移动端设备配置
const mobileDevices = {
  iPhone: {
    deviceName: 'iPhone 12',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1',
    viewport: { width: 390, height: 844 }
  },
  iPad: {
    deviceName: 'iPad Pro',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1',
    viewport: { width: 1024, height: 1366 }
  },
  Android: {
    deviceName: 'Samsung Galaxy S21',
    userAgent: 'Mozilla/5.0 (Linux; Android 11; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
    viewport: { width: 360, height: 800 }
  }
};

// 创建移动端WebDriver
async function createMobileDriver(deviceType: keyof typeof mobileDevices): Promise<WebDriver> {
  const device = mobileDevices[deviceType];
  
  const options = new chrome.Options();
  options.addArguments('--no-sandbox');
  options.addArguments('--disable-dev-shm-usage');
  
  // 设置移动端参数
  options.addArguments(`--user-agent=${device.userAgent}`);
  options.addArguments(`--window-size=${device.viewport.width},${device.viewport.height}`);
  
  // 启用触摸事件
  options.addArguments('--enable-touch-drag-drop');
  options.addArguments('--enable-features=VizDisplayCompositor');
  
  const driver = await new Builder()
    .forBrowser('chrome')
    .setChromeOptions(options)
    .build();
  
  // 设置视口大小
  await driver.manage().window().setRect({
    width: device.viewport.width,
    height: device.viewport.height
  });
  
  return driver;
}

// 移动端测试工具类
class MobileTestUtils {
  private driver: WebDriver;
  
  constructor(driver: WebDriver) {
    this.driver = driver;
  }
  
  // 模拟触摸点击
  async touchClick(element: any): Promise<void> {
    await this.driver.executeScript(`
      const element = arguments[0];
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      const touchEvent = new TouchEvent('touchstart', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [{
          identifier: 0,
          target: element,
          clientX: centerX,
          clientY: centerY,
          pageX: centerX,
          pageY: centerY
        }]
      });
      
      element.dispatchEvent(touchEvent);
    `, element);
  }
  
  // 模拟滑动
  async swipe(startX: number, startY: number, endX: number, endY: number, duration: number = 500): Promise<void> {
    await this.driver.executeScript(`
      const startX = arguments[0];
      const startY = arguments[1];
      const endX = arguments[2];
      const endY = arguments[3];
      const duration = arguments[4];
      
      const touchStartEvent = new TouchEvent('touchstart', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [{
          identifier: 0,
          target: document.body,
          clientX: startX,
          clientY: startY,
          pageX: startX,
          pageY: startY
        }]
      });
      
      const touchMoveEvent = new TouchEvent('touchmove', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [{
          identifier: 0,
          target: document.body,
          clientX: endX,
          clientY: endY,
          pageX: endX,
          pageY: endY
        }]
      });
      
      const touchEndEvent = new TouchEvent('touchend', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: []
      });
      
      document.body.dispatchEvent(touchStartEvent);
      setTimeout(() => {
        document.body.dispatchEvent(touchMoveEvent);
        setTimeout(() => {
          document.body.dispatchEvent(touchEndEvent);
        }, duration / 2);
      }, duration / 2);
    `, startX, startY, endX, endY, duration);
  }
  
  // 模拟捏合缩放
  async pinchZoom(scale: number): Promise<void> {
    await this.driver.executeScript(`
      const scale = arguments[0];
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      
      const touchStartEvent = new TouchEvent('touchstart', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [
          {
            identifier: 0,
            target: document.body,
            clientX: centerX - 50,
            clientY: centerY - 50,
            pageX: centerX - 50,
            pageY: centerY - 50
          },
          {
            identifier: 1,
            target: document.body,
            clientX: centerX + 50,
            clientY: centerY + 50,
            pageX: centerX + 50,
            pageY: centerY + 50
          }
        ]
      });
      
      const touchMoveEvent = new TouchEvent('touchmove', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [
          {
            identifier: 0,
            target: document.body,
            clientX: centerX - 50 * scale,
            clientY: centerY - 50 * scale,
            pageX: centerX - 50 * scale,
            pageY: centerY - 50 * scale
          },
          {
            identifier: 1,
            target: document.body,
            clientX: centerX + 50 * scale,
            clientY: centerY + 50 * scale,
            pageX: centerX + 50 * scale,
            pageY: centerY + 50 * scale
          }
        ]
      });
      
      const touchEndEvent = new TouchEvent('touchend', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: []
      });
      
      document.body.dispatchEvent(touchStartEvent);
      setTimeout(() => {
        document.body.dispatchEvent(touchMoveEvent);
        setTimeout(() => {
          document.body.dispatchEvent(touchEndEvent);
        }, 200);
      }, 200);
    `, scale);
  }
  
  // 检查元素是否在视口内
  async isElementInViewport(element: any): Promise<boolean> {
    return await this.driver.executeScript(`
      const element = arguments[0];
      const rect = element.getBoundingClientRect();
      return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= window.innerHeight &&
        rect.right <= window.innerWidth
      );
    `, element);
  }
  
  // 滚动到元素
  async scrollToElement(element: any): Promise<void> {
    await this.driver.executeScript(`
      const element = arguments[0];
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
    `, element);
  }
  
  // 获取设备方向
  async getOrientation(): Promise<string> {
    return await this.driver.executeScript(`
      return window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
    `);
  }
  
  // 旋转设备
  async rotateDevice(): Promise<void> {
    const currentOrientation = await this.getOrientation();
    const newWidth = currentOrientation === 'portrait' ? 844 : 390;
    const newHeight = currentOrientation === 'portrait' ? 390 : 844;
    
    await this.driver.manage().window().setRect({
      width: newWidth,
      height: newHeight
    });
  }
}

// 移动端测试示例
async function mobileTestExample() {
  let driver: WebDriver;
  
  try {
    // 创建iPhone设备驱动
    driver = await createMobileDriver('iPhone');
    const mobileUtils = new MobileTestUtils(driver);
    
    await driver.get('https://example.com');
    
    // 检查设备方向
    const orientation = await mobileUtils.getOrientation();
    console.log('设备方向:', orientation);
    
    // 查找并点击移动端菜单按钮
    const menuButton = await driver.findElement(By.css('.mobile-menu-button'));
    await mobileUtils.touchClick(menuButton);
    
    // 等待菜单展开
    await driver.wait(until.elementLocated(By.css('.mobile-menu')), 5000);
    
    // 滑动页面
    await mobileUtils.swipe(200, 400, 200, 100);
    
    // 查找元素并滚动到视口内
    const targetElement = await driver.findElement(By.css('.target-element'));
    const isInViewport = await mobileUtils.isElementInViewport(targetElement);
    
    if (!isInViewport) {
      await mobileUtils.scrollToElement(targetElement);
    }
    
    // 模拟捏合缩放
    await mobileUtils.pinchZoom(1.5);
    
    // 旋转设备
    await mobileUtils.rotateDevice();
    
    // 截图
    const screenshot = await driver.takeScreenshot();
    const fs = require('fs');
    fs.writeFileSync('mobile_test_screenshot.png', screenshot, 'base64');
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## 性能监控

### 1. 性能指标收集

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// 性能监控类
class PerformanceMonitor {
  private driver: WebDriver;
  private metrics: PerformanceMetrics[];
  
  constructor(driver: WebDriver) {
    this.driver = driver;
    this.metrics = [];
  }
  
  // 开始监控
  async startMonitoring(): Promise<void> {
    // 启用性能监控
    await this.driver.executeScript(`
      window.performanceObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          if (entry.entryType === 'navigation' || entry.entryType === 'resource') {
            window.performanceMetrics = window.performanceMetrics || [];
            window.performanceMetrics.push({
              name: entry.name,
              type: entry.entryType,
              startTime: entry.startTime,
              duration: entry.duration,
              timestamp: Date.now()
            });
          }
        });
      });
      
      window.performanceObserver.observe({ entryTypes: ['navigation', 'resource'] });
    `);
  }
  
  // 收集性能指标
  async collectMetrics(): Promise<PerformanceMetrics> {
    const navigationTiming = await this.driver.executeScript(`
      const timing = performance.timing;
      return {
        navigationStart: timing.navigationStart,
        loadEventEnd: timing.loadEventEnd,
        domContentLoadedEventEnd: timing.domContentLoadedEventEnd,
        responseEnd: timing.responseEnd,
        requestStart: timing.requestStart,
        loadTime: timing.loadEventEnd - timing.navigationStart,
        domReadyTime: timing.domContentLoadedEventEnd - timing.navigationStart,
        responseTime: timing.responseEnd - timing.requestStart
      };
    `);
    
    const resourceTiming = await this.driver.executeScript(`
      return performance.getEntriesByType('resource').map(entry => ({
        name: entry.name,
        duration: entry.duration,
        transferSize: entry.transferSize,
        decodedBodySize: entry.decodedBodySize
      }));
    `);
    
    const memoryInfo = await this.driver.executeScript(`
      if (performance.memory) {
        return {
          usedJSHeapSize: performance.memory.usedJSHeapSize,
          totalJSHeapSize: performance.memory.totalJSHeapSize,
          jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
        };
      }
      return null;
    `);
    
    const customMetrics = await this.driver.executeScript(`
      return window.performanceMetrics || [];
    `);
    
    const metrics: PerformanceMetrics = {
      timestamp: Date.now(),
      navigationTiming,
      resourceTiming,
      memoryInfo,
      customMetrics
    };
    
    this.metrics.push(metrics);
    return metrics;
  }
  
  // 获取所有收集的指标
  getAllMetrics(): PerformanceMetrics[] {
    return this.metrics;
  }
  
  // 生成性能报告
  generateReport(): PerformanceReport {
    if (this.metrics.length === 0) {
      throw new Error('No metrics collected');
    }
    
    const latestMetrics = this.metrics[this.metrics.length - 1];
    const navigationTiming = latestMetrics.navigationTiming;
    
    const totalResourceSize = latestMetrics.resourceTiming.reduce(
      (sum, resource) => sum + (resource.transferSize || 0), 0
    );
    
    const avgResourceLoadTime = latestMetrics.resourceTiming.length > 0
      ? latestMetrics.resourceTiming.reduce((sum, resource) => sum + resource.duration, 0) / latestMetrics.resourceTiming.length
      : 0;
    
    return {
      pageLoadTime: navigationTiming.loadTime,
      domReadyTime: navigationTiming.domReadyTime,
      responseTime: navigationTiming.responseTime,
      totalResources: latestMetrics.resourceTiming.length,
      totalResourceSize,
      avgResourceLoadTime,
      memoryUsage: latestMetrics.memoryInfo?.usedJSHeapSize || 0,
      memoryLimit: latestMetrics.memoryInfo?.jsHeapSizeLimit || 0,
      metrics: this.metrics
    };
  }
}

interface PerformanceMetrics {
  timestamp: number;
  navigationTiming: any;
  resourceTiming: any[];
  memoryInfo: any;
  customMetrics: any[];
}

interface PerformanceReport {
  pageLoadTime: number;
  domReadyTime: number;
  responseTime: number;
  totalResources: number;
  totalResourceSize: number;
  avgResourceLoadTime: number;
  memoryUsage: number;
  memoryLimit: number;
  metrics: PerformanceMetrics[];
}

// 使用性能监控
async function performanceMonitoringExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const monitor = new PerformanceMonitor(driver);
    
    // 开始监控
    await monitor.startMonitoring();
    
    // 导航到页面
    await driver.get('https://example.com');
    
    // 等待页面加载完成
    await driver.wait(until.titleIs(await driver.getTitle()), 10000);
    
    // 收集性能指标
    const metrics = await monitor.collectMetrics();
    console.log('性能指标:', metrics);
    
    // 生成报告
    const report = monitor.generateReport();
    console.log('性能报告:');
    console.log(`页面加载时间: ${report.pageLoadTime}ms`);
    console.log(`DOM准备时间: ${report.domReadyTime}ms`);
    console.log(`响应时间: ${report.responseTime}ms`);
    console.log(`资源数量: ${report.totalResources}`);
    console.log(`资源总大小: ${report.totalResourceSize} bytes`);
    console.log(`平均资源加载时间: ${report.avgResourceLoadTime.toFixed(2)}ms`);
    console.log(`内存使用: ${report.memoryUsage} bytes`);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

### 2. 性能基准测试

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// 性能基准测试类
class PerformanceBenchmark {
  private driver: WebDriver;
  private testResults: BenchmarkResult[];
  
  constructor(driver: WebDriver) {
    this.driver = driver;
    this.testResults = [];
  }
  
  // 运行基准测试
  async runBenchmark(testName: string, testFunction: () => Promise<void>, iterations: number = 5): Promise<BenchmarkResult> {
    const times: number[] = [];
    
    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();
      
      try {
        await testFunction();
        const endTime = performance.now();
        times.push(endTime - startTime);
      } catch (error) {
        console.error(`基准测试失败 (迭代 ${i + 1}):`, error);
      }
    }
    
    const result: BenchmarkResult = {
      testName,
      iterations,
      times,
      avgTime: times.reduce((sum, time) => sum + time, 0) / times.length,
      minTime: Math.min(...times),
      maxTime: Math.max(...times),
      medianTime: this.calculateMedian(times),
      standardDeviation: this.calculateStandardDeviation(times)
    };
    
    this.testResults.push(result);
    return result;
  }
  
  // 计算中位数
  private calculateMedian(numbers: number[]): number {
    const sorted = numbers.slice().sort((a, b) => a - b);
    const middle = Math.floor(sorted.length / 2);
    
    if (sorted.length % 2 === 0) {
      return (sorted[middle - 1] + sorted[middle]) / 2;
    }
    
    return sorted[middle];
  }
  
  // 计算标准差
  private calculateStandardDeviation(numbers: number[]): number {
    const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
    const squaredDifferences = numbers.map(num => Math.pow(num - mean, 2));
    const variance = squaredDifferences.reduce((sum, diff) => sum + diff, 0) / numbers.length;
    
    return Math.sqrt(variance);
  }
  
  // 生成基准测试报告
  generateReport(): BenchmarkReport {
    const totalTests = this.testResults.length;
    const avgTimes = this.testResults.map(r => r.avgTime);
    const totalAvgTime = avgTimes.reduce((sum, time) => sum + time, 0);
    
    return {
      totalTests,
      totalAvgTime,
      results: this.testResults,
      summary: {
        fastestTest: this.testResults.reduce((min, result) => 
          result.avgTime < min.avgTime ? result : min
        ),
        slowestTest: this.testResults.reduce((max, result) => 
          result.avgTime > max.avgTime ? result : max
        ),
        mostConsistentTest: this.testResults.reduce((most, result) => 
          result.standardDeviation < most.standardDeviation ? result : most
        )
      }
    };
  }
}

interface BenchmarkResult {
  testName: string;
  iterations: number;
  times: number[];
  avgTime: number;
  minTime: number;
  maxTime: number;
  medianTime: number;
  standardDeviation: number;
}

interface BenchmarkReport {
  totalTests: number;
  totalAvgTime: number;
  results: BenchmarkResult[];
  summary: {
    fastestTest: BenchmarkResult;
    slowestTest: BenchmarkResult;
    mostConsistentTest: BenchmarkResult;
  };
}

// 使用性能基准测试
async function performanceBenchmarkExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const benchmark = new PerformanceBenchmark(driver);
    
    // 测试页面加载性能
    await benchmark.runBenchmark('页面加载测试', async () => {
      await driver.get('https://example.com');
      await driver.wait(until.titleIs(await driver.getTitle()), 10000);
    });
    
    // 测试元素查找性能
    await benchmark.runBenchmark('元素查找测试', async () => {
      await driver.get('https://example.com');
      for (let i = 0; i < 10; i++) {
        await driver.findElement(By.css('.test-element'));
      }
    });
    
    // 测试JavaScript执行性能
    await benchmark.runBenchmark('JavaScript执行测试', async () => {
      await driver.get('https://example.com');
      for (let i = 0; i < 100; i++) {
        await driver.executeScript('return document.querySelectorAll("*").length;');
      }
    });
    
    // 生成报告
    const report = benchmark.generateReport();
    
    console.log('📊 性能基准测试报告');
    console.log('=' * 50);
    console.log(`总测试数: ${report.totalTests}`);
    console.log(`总平均时间: ${report.totalAvgTime.toFixed(2)}ms`);
    
    console.log('\n详细结果:');
    report.results.forEach(result => {
      console.log(`\n${result.testName}:`);
      console.log(`  平均时间: ${result.avgTime.toFixed(2)}ms`);
      console.log(`  最小时间: ${result.minTime.toFixed(2)}ms`);
      console.log(`  最大时间: ${result.maxTime.toFixed(2)}ms`);
      console.log(`  中位数: ${result.medianTime.toFixed(2)}ms`);
      console.log(`  标准差: ${result.standardDeviation.toFixed(2)}ms`);
    });
    
    console.log('\n总结:');
    console.log(`最快测试: ${report.summary.fastestTest.testName} (${report.summary.fastestTest.avgTime.toFixed(2)}ms)`);
    console.log(`最慢测试: ${report.summary.slowestTest.testName} (${report.summary.slowestTest.avgTime.toFixed(2)}ms)`);
    console.log(`最稳定测试: ${report.summary.mostConsistentTest.testName} (标准差: ${report.summary.mostConsistentTest.standardDeviation.toFixed(2)}ms)`);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## 安全测试

### 1. XSS检测

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// XSS测试类
class XSSTester {
  private driver: WebDriver;
  private testPayloads: string[];
  
  constructor(driver: WebDriver) {
    this.driver = driver;
    this.testPayloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '"><img src=x onerror=alert("XSS")>',
      '"><svg onload=alert("XSS")>',
      '"><iframe src="javascript:alert(\'XSS\')">',
      '"><body onload=alert("XSS")>',
      '"><input onfocus=alert("XSS") autofocus>',
      '"><textarea onfocus=alert("XSS") autofocus>',
      '"><select onfocus=alert("XSS") autofocus>'
    ];
  }
  
  // 测试输入框XSS漏洞
  async testInputXSS(url: string, inputSelectors: string[]): Promise<XSSResult[]> {
    const results: XSSResult[] = [];
    
    for (const selector of inputSelectors) {
      for (const payload of this.testPayloads) {
        try {
          await this.driver.get(url);
          
          const input = await this.driver.findElement(By.css(selector));
          await input.clear();
          await input.sendKeys(payload);
          
          // 尝试提交表单
          const submitButton = await this.driver.findElement(By.css('input[type="submit"], button[type="submit"], .submit-button'));
          await submitButton.click();
          
          // 检查是否有弹窗
          const alertPresent = await this.checkForAlert();
          
          if (alertPresent) {
            results.push({
              selector,
              payload,
              vulnerable: true,
              alertText: await this.getAlertText()
            });
            
            // 关闭弹窗
            await this.driver.switchTo().alert().accept();
          } else {
            results.push({
              selector,
              payload,
              vulnerable: false,
              alertText: null
            });
          }
          
        } catch (error) {
          results.push({
            selector,
            payload,
            vulnerable: false,
            alertText: null,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
    }
    
    return results;
  }
  
  // 测试URL参数XSS漏洞
  async testURLParameterXSS(baseUrl: string, parameters: string[]): Promise<XSSResult[]> {
    const results: XSSResult[] = [];
    
    for (const parameter of parameters) {
      for (const payload of this.testPayloads) {
        try {
          const testUrl = `${baseUrl}?${parameter}=${encodeURIComponent(payload)}`;
          await this.driver.get(testUrl);
          
          // 检查页面源码是否包含未转义的payload
          const pageSource = await this.driver.getPageSource();
          const vulnerable = pageSource.includes(payload) && !pageSource.includes(encodeURIComponent(payload));
          
          if (vulnerable) {
            results.push({
              selector: `URL Parameter: ${parameter}`,
              payload,
              vulnerable: true,
              alertText: null
            });
          } else {
            results.push({
              selector: `URL Parameter: ${parameter}`,
              payload,
              vulnerable: false,
              alertText: null
            });
          }
          
        } catch (error) {
          results.push({
            selector: `URL Parameter: ${parameter}`,
            payload,
            vulnerable: false,
            alertText: null,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
    }
    
    return results;
  }
  
  // 检查是否有弹窗
  private async checkForAlert(): Promise<boolean> {
    try {
      await this.driver.switchTo().alert();
      return true;
    } catch {
      return false;
    }
  }
  
  // 获取弹窗文本
  private async getAlertText(): Promise<string> {
    try {
      const alert = await this.driver.switchTo().alert();
      return await alert.getText();
    } catch {
      return '';
    }
  }
  
  // 生成XSS测试报告
  generateReport(results: XSSResult[]): XSSReport {
    const totalTests = results.length;
    const vulnerableTests = results.filter(r => r.vulnerable);
    const vulnerableSelectors = [...new Set(vulnerableTests.map(r => r.selector))];
    
    return {
      totalTests,
      vulnerableTests: vulnerableTests.length,
      vulnerableSelectors,
      vulnerabilityRate: (vulnerableTests.length / totalTests) * 100,
      results
    };
  }
}

interface XSSResult {
  selector: string;
  payload: string;
  vulnerable: boolean;
  alertText: string | null;
  error?: string;
}

interface XSSReport {
  totalTests: number;
  vulnerableTests: number;
  vulnerableSelectors: string[];
  vulnerabilityRate: number;
  results: XSSResult[];
}

// 使用XSS测试
async function xssTestExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const xssTester = new XSSTester(driver);
    
    // 测试输入框XSS
    const inputResults = await xssTester.testInputXSS('https://example.com/contact', [
      'input[name="name"]',
      'input[name="email"]',
      'textarea[name="message"]'
    ]);
    
    // 测试URL参数XSS
    const urlResults = await xssTester.testURLParameterXSS('https://example.com/search', [
      'q',
      'category',
      'sort'
    ]);
    
    // 合并结果
    const allResults = [...inputResults, ...urlResults];
    
    // 生成报告
    const report = xssTester.generateReport(allResults);
    
    console.log('🔒 XSS安全测试报告');
    console.log('=' * 50);
    console.log(`总测试数: ${report.totalTests}`);
    console.log(`发现漏洞: ${report.vulnerableTests}`);
    console.log(`漏洞率: ${report.vulnerabilityRate.toFixed(2)}%`);
    
    if (report.vulnerableSelectors.length > 0) {
      console.log('\n存在漏洞的选择器:');
      report.vulnerableSelectors.forEach(selector => {
        console.log(`  - ${selector}`);
      });
    }
    
    console.log('\n详细结果:');
    report.results.filter(r => r.vulnerable).forEach(result => {
      console.log(`\n选择器: ${result.selector}`);
      console.log(`Payload: ${result.payload}`);
      if (result.alertText) {
        console.log(`弹窗文本: ${result.alertText}`);
      }
    });
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

### 2. CSRF检测

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// CSRF测试类
class CSRFTester {
  private driver: WebDriver;
  
  constructor(driver: WebDriver) {
    this.driver = driver;
  }
  
  // 测试CSRF保护
  async testCSRFProtection(url: string, formSelectors: string[]): Promise<CSRFResult[]> {
    const results: CSRFResult[] = [];
    
    for (const selector of formSelectors) {
      try {
        await this.driver.get(url);
        
        // 查找表单
        const form = await this.driver.findElement(By.css(selector));
        
        // 检查是否有CSRF token
        const csrfToken = await this.findCSRFToken(form);
        
        if (csrfToken) {
          results.push({
            formSelector: selector,
            hasCSRFToken: true,
            tokenName: csrfToken.name,
            tokenValue: csrfToken.value,
            vulnerable: false
          });
        } else {
          // 尝试提交表单
          const submitButton = await form.findElement(By.css('input[type="submit"], button[type="submit"]'));
          await submitButton.click();
          
          // 检查是否成功提交（没有错误信息）
          const success = await this.checkFormSubmissionSuccess();
          
          results.push({
            formSelector: selector,
            hasCSRFToken: false,
            tokenName: null,
            tokenValue: null,
            vulnerable: !success
          });
        }
        
      } catch (error) {
        results.push({
          formSelector: selector,
          hasCSRFToken: false,
          tokenName: null,
          tokenValue: null,
          vulnerable: false,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    return results;
  }
  
  // 查找CSRF token
  private async findCSRFToken(form: any): Promise<{ name: string; value: string } | null> {
    try {
      // 常见的CSRF token字段名
      const tokenFieldNames = [
        'csrf_token',
        'csrf-token',
        '_token',
        'authenticity_token',
        'csrf',
        'token'
      ];
      
      for (const fieldName of tokenFieldNames) {
        try {
          const tokenField = await form.findElement(By.css(`input[name="${fieldName}"]`));
          const tokenValue = await tokenField.getAttribute('value');
          
          if (tokenValue && tokenValue.length > 0) {
            return { name: fieldName, value: tokenValue };
          }
        } catch {
          // 字段不存在，继续查找
        }
      }
      
      return null;
    } catch {
      return null;
    }
  }
  
  // 检查表单提交是否成功
  private async checkFormSubmissionSuccess(): Promise<boolean> {
    try {
      // 检查是否有错误信息
      const errorElements = await this.driver.findElements(By.css('.error, .alert, .message'));
      
      for (const element of errorElements) {
        const text = await element.getText();
        if (text.toLowerCase().includes('csrf') || text.toLowerCase().includes('token')) {
          return false; // 有CSRF相关错误
        }
      }
      
      // 检查URL是否改变（可能表示重定向）
      const currentUrl = await this.driver.getCurrentUrl();
      return !currentUrl.includes('error');
      
    } catch {
      return true; // 假设成功
    }
  }
  
  // 生成CSRF测试报告
  generateReport(results: CSRFResult[]): CSRFReport {
    const totalTests = results.length;
    const vulnerableTests = results.filter(r => r.vulnerable);
    const protectedTests = results.filter(r => r.hasCSRFToken);
    
    return {
      totalTests,
      vulnerableTests: vulnerableTests.length,
      protectedTests: protectedTests.length,
      vulnerabilityRate: (vulnerableTests.length / totalTests) * 100,
      protectionRate: (protectedTests.length / totalTests) * 100,
      results
    };
  }
}

interface CSRFResult {
  formSelector: string;
  hasCSRFToken: boolean;
  tokenName: string | null;
  tokenValue: string | null;
  vulnerable: boolean;
  error?: string;
}

interface CSRFReport {
  totalTests: number;
  vulnerableTests: number;
  protectedTests: number;
  vulnerabilityRate: number;
  protectionRate: number;
  results: CSRFResult[];
}

// 使用CSRF测试
async function csrfTestExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const csrfTester = new CSRFTester(driver);
    
    // 测试表单CSRF保护
    const results = await csrfTester.testCSRFProtection('https://example.com/forms', [
      'form[action*="submit"]',
      'form[action*="save"]',
      'form[action*="update"]'
    ]);
    
    // 生成报告
    const report = csrfTester.generateReport(results);
    
    console.log('🔒 CSRF安全测试报告');
    console.log('=' * 50);
    console.log(`总测试数: ${report.totalTests}`);
    console.log(`存在漏洞: ${report.vulnerableTests}`);
    console.log(`有保护措施: ${report.protectedTests}`);
    console.log(`漏洞率: ${report.vulnerabilityRate.toFixed(2)}%`);
    console.log(`保护率: ${report.protectionRate.toFixed(2)}%`);
    
    console.log('\n详细结果:');
    report.results.forEach(result => {
      console.log(`\n表单: ${result.formSelector}`);
      console.log(`有CSRF Token: ${result.hasCSRFToken ? '是' : '否'}`);
      if (result.hasCSRFToken) {
        console.log(`Token名称: ${result.tokenName}`);
        console.log(`Token值: ${result.tokenValue?.substring(0, 20)}...`);
      }
      console.log(`存在漏洞: ${result.vulnerable ? '是' : '否'}`);
    });
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## CI/CD集成

### 1. GitHub Actions集成

```yaml
# .github/workflows/selenium-tests.yml
name: Selenium Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [16.x, 18.x]
        browser: [chrome, firefox]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Install Chrome
      if: matrix.browser == 'chrome'
      run: |
        wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -
        echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
        apt-get update
        apt-get install -y google-chrome-stable
    
    - name: Install Firefox
      if: matrix.browser == 'firefox'
      run: |
        apt-get update
        apt-get install -y firefox
    
    - name: Run Selenium tests
      run: npm run test:selenium
      env:
        BROWSER: ${{ matrix.browser }}
        CI: true
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results-${{ matrix.browser }}-${{ matrix.node-version }}
        path: |
          test-results/
          screenshots/
          reports/
    
    - name: Generate test report
      if: always()
      run: npm run generate-report
    
    - name: Comment PR with test results
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const reportPath = './test-report.json';
          
          if (fs.existsSync(reportPath)) {
            const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
            
            const comment = `## 🧪 Selenium Test Results
            **Browser:** ${{ matrix.browser }}
            **Node.js:** ${{ matrix.node-version }}
            
            - ✅ **Passed:** ${report.passed}
            - ❌ **Failed:** ${report.failed}
            - ⏱️ **Duration:** ${report.duration}ms
            - 📊 **Success Rate:** ${report.successRate}%
            
            ${report.failed > 0 ? '### Failed Tests\n' + report.failedTests.map(test => `- ${test.name}: ${test.error}`).join('\n') : ''}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }
```

### 2. Jenkins集成

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    environment {
        NODE_VERSION = '18'
        BROWSER = 'chrome'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Setup Node.js') {
            steps {
                nodejs(nodeJSInstallationName: "NodeJS ${NODE_VERSION}") {
                    sh 'npm ci'
                }
            }
        }
        
        stage('Install Browser') {
            steps {
                script {
                    if (env.BROWSER == 'chrome') {
                        sh '''
                            wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -
                            echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
                            apt-get update
                            apt-get install -y google-chrome-stable
                        '''
                    } else if (env.BROWSER == 'firefox') {
                        sh '''
                            apt-get update
                            apt-get install -y firefox
                        '''
                    }
                }
            }
        }
        
        stage('Run Tests') {
            steps {
                nodejs(nodeJSInstallationName: "NodeJS ${NODE_VERSION}") {
                    sh 'npm run test:selenium'
                }
            }
            post {
                always {
                    // 收集测试结果
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'reports',
                        reportFiles: 'index.html',
                        reportName: 'Selenium Test Report'
                    ])
                    
                    // 收集截图
                    archiveArtifacts artifacts: 'screenshots/**/*', allowEmptyArchive: true
                    
                    // 收集测试结果文件
                    archiveArtifacts artifacts: 'test-results/**/*', allowEmptyArchive: true
                }
                success {
                    echo '✅ All tests passed!'
                }
                failure {
                    echo '❌ Some tests failed!'
                }
            }
        }
        
        stage('Generate Report') {
            steps {
                nodejs(nodeJSInstallationName: "NodeJS ${NODE_VERSION}") {
                    sh 'npm run generate-report'
                }
            }
        }
    }
    
    post {
        always {
            // 清理工作空间
            cleanWs()
        }
    }
}
```

### 3. Docker集成

```dockerfile
# Dockerfile
FROM node:18-alpine

# 安装Chrome依赖
RUN apk add --no-cache \
    chromium \
    nss \
    freetype \
    freetype-dev \
    harfbuzz \
    ca-certificates \
    ttf-freefont

# 设置Chrome环境变量
ENV CHROME_BIN=/usr/bin/chromium-browser \
    CHROME_PATH=/usr/lib/chromium/ \
    PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true

# 创建工作目录
WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S selenium -u 1001

# 更改文件所有权
RUN chown -R selenium:nodejs /app
USER selenium

# 暴露端口
EXPOSE 3000

# 启动命令
CMD ["npm", "start"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  selenium-hub:
    image: selenium/hub:4.10.0
    container_name: selenium-hub
    ports:
      - "4442:4442"
      - "4443:4443"
      - "4444:4444"
    environment:
      GRID_MAX_SESSION: 16
      GRID_BROWSER_TIMEOUT: 300
      GRID_TIMEOUT: 300

  chrome:
    image: selenium/node-chrome:4.10.0
    shm_size: 2gb
    depends_on:
      - selenium-hub
    environment:
      SE_EVENT_BUS_HOST: selenium-hub
      SE_EVENT_BUS_PUBLISH_PORT: 4442
      SE_EVENT_BUS_SUBSCRIBE_PORT: 4443
      SE_NODE_MAX_SESSIONS: 4
      SE_NODE_OVERRIDE_MAX_SESSIONS: true

  firefox:
    image: selenium/node-firefox:4.10.0
    shm_size: 2gb
    depends_on:
      - selenium-hub
    environment:
      SE_EVENT_BUS_HOST: selenium-hub
      SE_EVENT_BUS_PUBLISH_PORT: 4442
      SE_EVENT_BUS_SUBSCRIBE_PORT: 4443
      SE_NODE_MAX_SESSIONS: 4
      SE_NODE_OVERRIDE_MAX_SESSIONS: true

  app:
    build: .
    ports:
      - "3000:3000"
    depends_on:
      - selenium-hub
    environment:
      SELENIUM_HUB_URL: http://selenium-hub:4444
      NODE_ENV: production
    volumes:
      - ./test-results:/app/test-results
      - ./screenshots:/app/screenshots
      - ./reports:/app/reports
```

## 总结

本高级功能详解基于Steel-Browser项目的实际代码，深入介绍了Selenium WebDriver的高级特性和最佳实践。通过学习本教程，您应该能够：

1. **高级等待策略**: 掌握自定义等待条件和智能等待策略
2. **自定义WebDriver**: 学会扩展WebDriver功能和创建自定义元素类
3. **分布式测试**: 了解Selenium Grid配置和负载测试
4. **移动端测试**: 掌握移动端WebDriver配置和触摸操作
5. **性能监控**: 学会收集性能指标和进行基准测试
6. **安全测试**: 掌握XSS和CSRF漏洞检测方法
7. **CI/CD集成**: 了解与GitHub Actions、Jenkins和Docker的集成

这些高级功能将帮助您构建更加强大、稳定和高效的Web自动化测试解决方案，满足企业级应用的各种需求。