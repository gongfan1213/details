# Seleniumé«˜çº§åŠŸèƒ½è¯¦è§£ - åŸºäºSteel-Browseré¡¹ç›®å®æˆ˜

## ç›®å½•
1. [é«˜çº§ç­‰å¾…ç­–ç•¥](#é«˜çº§ç­‰å¾…ç­–ç•¥)
2. [è‡ªå®šä¹‰WebDriver](#è‡ªå®šä¹‰WebDriver)
3. [åˆ†å¸ƒå¼æµ‹è¯•](#åˆ†å¸ƒå¼æµ‹è¯•)
4. [ç§»åŠ¨ç«¯æµ‹è¯•](#ç§»åŠ¨ç«¯æµ‹è¯•)
5. [æ€§èƒ½ç›‘æ§](#æ€§èƒ½ç›‘æ§)
6. [å®‰å…¨æµ‹è¯•](#å®‰å…¨æµ‹è¯•)
7. [CI/CDé›†æˆ](#cicdé›†æˆ)

## é«˜çº§ç­‰å¾…ç­–ç•¥

### 1. è‡ªå®šä¹‰ç­‰å¾…æ¡ä»¶

```typescript
import { Builder, By, until, WebDriver, Condition } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// è‡ªå®šä¹‰ç­‰å¾…æ¡ä»¶
class CustomConditions {
  // ç­‰å¾…å…ƒç´ åŒ…å«ç‰¹å®šæ–‡æœ¬
  static elementTextContains(locator: By, text: string): Condition<boolean> {
    return new Condition(`element text contains "${text}"`, async (driver) => {
      try {
        const element = await driver.findElement(locator);
        const elementText = await element.getText();
        return elementText.includes(text);
      } catch {
        return false;
      }
    });
  }

  // ç­‰å¾…å…ƒç´ æ•°é‡è¾¾åˆ°æŒ‡å®šå€¼
  static elementCountIs(locator: By, count: number): Condition<boolean> {
    return new Condition(`element count is ${count}`, async (driver) => {
      const elements = await driver.findElements(locator);
      return elements.length === count;
    });
  }

  // ç­‰å¾…å…ƒç´ å¯è§ä¸”å¯ç‚¹å‡»
  static elementIsClickable(locator: By): Condition<boolean> {
    return new Condition('element is clickable', async (driver) => {
      try {
        const element = await driver.findElement(locator);
        const isDisplayed = await element.isDisplayed();
        const isEnabled = await element.isEnabled();
        return isDisplayed && isEnabled;
      } catch {
        return false;
      }
    });
  }

  // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
  static pageFullyLoaded(): Condition<boolean> {
    return new Condition('page fully loaded', async (driver) => {
      const readyState = await driver.executeScript('return document.readyState;');
      return readyState === 'complete';
    });
  }

  // ç­‰å¾…AJAXè¯·æ±‚å®Œæˆ
  static ajaxCompleted(): Condition<boolean> {
    return new Condition('ajax completed', async (driver) => {
      const activeRequests = await driver.executeScript(`
        return window.jQuery ? window.jQuery.active : 0;
      `);
      return activeRequests === 0;
    });
  }
}

// ä½¿ç”¨è‡ªå®šä¹‰ç­‰å¾…æ¡ä»¶
async function customWaitExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    await driver.get('https://example.com');
    
    // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
    await driver.wait(CustomConditions.pageFullyLoaded(), 30000);
    
    // ç­‰å¾…ç‰¹å®šæ–‡æœ¬å‡ºç°
    await driver.wait(
      CustomConditions.elementTextContains(By.css('.status'), 'Success'), 
      10000
    );
    
    // ç­‰å¾…å…ƒç´ æ•°é‡
    await driver.wait(
      CustomConditions.elementCountIs(By.css('.item'), 5), 
      10000
    );
    
    // ç­‰å¾…å…ƒç´ å¯ç‚¹å‡»
    await driver.wait(
      CustomConditions.elementIsClickable(By.css('.submit-button')), 
      10000
    );
    
    // ç­‰å¾…AJAXå®Œæˆ
    await driver.wait(CustomConditions.ajaxCompleted(), 10000);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

### 2. æ™ºèƒ½ç­‰å¾…ç­–ç•¥

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

class SmartWait {
  private driver: WebDriver;
  private defaultTimeout: number;
  
  constructor(driver: WebDriver, defaultTimeout: number = 10000) {
    this.driver = driver;
    this.defaultTimeout = defaultTimeout;
  }
  
  // æ™ºèƒ½ç­‰å¾…å…ƒç´ å‡ºç°
  async waitForElement(locator: By, timeout?: number): Promise<WebElement> {
    const waitTimeout = timeout || this.defaultTimeout;
    const startTime = Date.now();
    
    while (Date.now() - startTime < waitTimeout) {
      try {
        const element = await this.driver.findElement(locator);
        if (await element.isDisplayed()) {
          return element;
        }
      } catch (error) {
        // å…ƒç´ ä¸å­˜åœ¨æˆ–ä¸å¯è§ï¼Œç»§ç»­ç­‰å¾…
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    throw new Error(`Element not found within ${waitTimeout}ms`);
  }
  
  // ç­‰å¾…å…ƒç´ æ¶ˆå¤±
  async waitForElementToDisappear(locator: By, timeout?: number): Promise<void> {
    const waitTimeout = timeout || this.defaultTimeout;
    const startTime = Date.now();
    
    while (Date.now() - startTime < waitTimeout) {
      try {
        const element = await this.driver.findElement(locator);
        if (!(await element.isDisplayed())) {
          return;
        }
      } catch (error) {
        // å…ƒç´ ä¸å­˜åœ¨ï¼Œè®¤ä¸ºå·²æ¶ˆå¤±
        return;
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    throw new Error(`Element did not disappear within ${waitTimeout}ms`);
  }
  
  // ç­‰å¾…é¡µé¢ç¨³å®šï¼ˆæ— DOMå˜åŒ–ï¼‰
  async waitForPageStable(timeout?: number): Promise<void> {
    const waitTimeout = timeout || this.defaultTimeout;
    const startTime = Date.now();
    let lastDOMHash = '';
    
    while (Date.now() - startTime < waitTimeout) {
      const currentDOMHash = await this.driver.executeScript(`
        return document.body.innerHTML.length + '_' + 
               document.querySelectorAll('*').length;
      `);
      
      if (currentDOMHash === lastDOMHash) {
        return; // é¡µé¢ç¨³å®š
      }
      
      lastDOMHash = currentDOMHash;
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    throw new Error(`Page did not stabilize within ${waitTimeout}ms`);
  }
  
  // ç­‰å¾…ç½‘ç»œç©ºé—²
  async waitForNetworkIdle(timeout?: number): Promise<void> {
    const waitTimeout = timeout || this.defaultTimeout;
    const startTime = Date.now();
    let lastRequestCount = 0;
    
    while (Date.now() - startTime < waitTimeout) {
      const currentRequestCount = await this.driver.executeScript(`
        return window.performance.getEntriesByType('resource').length;
      `);
      
      if (currentRequestCount === lastRequestCount) {
        return; // ç½‘ç»œç©ºé—²
      }
      
      lastRequestCount = currentRequestCount;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    throw new Error(`Network did not become idle within ${waitTimeout}ms`);
  }
}

// ä½¿ç”¨æ™ºèƒ½ç­‰å¾…
async function smartWaitExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const smartWait = new SmartWait(driver, 15000);
    
    await driver.get('https://example.com');
    
    // ç­‰å¾…é¡µé¢ç¨³å®š
    await smartWait.waitForPageStable();
    
    // ç­‰å¾…å…ƒç´ å‡ºç°
    const element = await smartWait.waitForElement(By.css('.dynamic-content'));
    
    // ç­‰å¾…ç½‘ç»œç©ºé—²
    await smartWait.waitForNetworkIdle();
    
    // ç­‰å¾…å…ƒç´ æ¶ˆå¤±
    await smartWait.waitForElementToDisappear(By.css('.loading-spinner'));
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## è‡ªå®šä¹‰WebDriver

### 1. æ‰©å±•WebDriveråŠŸèƒ½

```typescript
import { Builder, By, until, WebDriver, WebElement } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// æ‰©å±•çš„WebDriverç±»
class ExtendedWebDriver extends WebDriver {
  private originalDriver: WebDriver;
  
  constructor(driver: WebDriver) {
    super();
    this.originalDriver = driver;
  }
  
  // è·å–åŸå§‹é©±åŠ¨
  getDriver(): WebDriver {
    return this.originalDriver;
  }
  
  // é«˜äº®å…ƒç´ 
  async highlightElement(element: WebElement, color: string = 'red'): Promise<void> {
    await this.executeScript(`
      arguments[0].style.border = '3px solid ${color}';
      arguments[0].style.backgroundColor = 'yellow';
    `, element);
  }
  
  // æ»šåŠ¨åˆ°å…ƒç´ 
  async scrollToElement(element: WebElement): Promise<void> {
    await this.executeScript('arguments[0].scrollIntoView({behavior: "smooth", block: "center"});', element);
  }
  
  // è·å–å…ƒç´ æˆªå›¾
  async takeElementScreenshot(element: WebElement): Promise<string> {
    return await element.takeScreenshot();
  }
  
  // æ‰§è¡ŒJavaScriptå¹¶ç­‰å¾…
  async executeScriptAndWait(script: string, ...args: any[]): Promise<any> {
    const result = await this.executeScript(script, ...args);
    await new Promise(resolve => setTimeout(resolve, 1000));
    return result;
  }
  
  // è·å–é¡µé¢æ€§èƒ½æŒ‡æ ‡
  async getPerformanceMetrics(): Promise<any> {
    return await this.executeScript(`
      const performance = window.performance;
      return {
        navigationStart: performance.timing.navigationStart,
        loadEventEnd: performance.timing.loadEventEnd,
        domContentLoadedEventEnd: performance.timing.domContentLoadedEventEnd,
        responseEnd: performance.timing.responseEnd,
        requestStart: performance.timing.requestStart,
        loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
        domReadyTime: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart
      };
    `);
  }
  
  // æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥
  async typeLikeHuman(element: WebElement, text: string): Promise<void> {
    for (const char of text) {
      await element.sendKeys(char);
      await new Promise(resolve => setTimeout(resolve, Math.random() * 100 + 50));
    }
  }
  
  // ç­‰å¾…å¹¶ç‚¹å‡»å…ƒç´ 
  async waitAndClick(locator: By, timeout: number = 10000): Promise<void> {
    const element = await this.wait(until.elementLocated(locator), timeout);
    await this.wait(until.elementIsVisible(element), timeout);
    await element.click();
  }
  
  // ç­‰å¾…å¹¶è¾“å…¥æ–‡æœ¬
  async waitAndType(locator: By, text: string, timeout: number = 10000): Promise<void> {
    const element = await this.wait(until.elementLocated(locator), timeout);
    await this.wait(until.elementIsVisible(element), timeout);
    await element.clear();
    await element.sendKeys(text);
  }
  
  // è·å–æ‰€æœ‰cookies
  async getAllCookies(): Promise<any[]> {
    return await this.manage().getCookies();
  }
  
  // è®¾ç½®cookie
  async setCookie(name: string, value: string, domain?: string): Promise<void> {
    const cookie = {
      name,
      value,
      domain: domain || await this.executeScript('return window.location.hostname;')
    };
    await this.manage().addCookie(cookie);
  }
  
  // æ¸…é™¤æ‰€æœ‰cookies
  async clearAllCookies(): Promise<void> {
    await this.manage().deleteAllCookies();
  }
  
  // è·å–æœ¬åœ°å­˜å‚¨
  async getLocalStorage(key: string): Promise<string | null> {
    return await this.executeScript(`return localStorage.getItem('${key}');`);
  }
  
  // è®¾ç½®æœ¬åœ°å­˜å‚¨
  async setLocalStorage(key: string, value: string): Promise<void> {
    await this.executeScript(`localStorage.setItem('${key}', '${value}');`);
  }
  
  // æ¸…é™¤æœ¬åœ°å­˜å‚¨
  async clearLocalStorage(): Promise<void> {
    await this.executeScript('localStorage.clear();');
  }
  
  // è·å–ä¼šè¯å­˜å‚¨
  async getSessionStorage(key: string): Promise<string | null> {
    return await this.executeScript(`return sessionStorage.getItem('${key}');`);
  }
  
  // è®¾ç½®ä¼šè¯å­˜å‚¨
  async setSessionStorage(key: string, value: string): Promise<void> {
    await this.executeScript(`sessionStorage.setItem('${key}', '${value}');`);
  }
  
  // æ¸…é™¤ä¼šè¯å­˜å‚¨
  async clearSessionStorage(): Promise<void> {
    await this.executeScript('sessionStorage.clear();');
  }
}

// åˆ›å»ºæ‰©å±•çš„WebDriver
async function createExtendedDriver(): Promise<ExtendedWebDriver> {
  const options = new chrome.Options();
  options.addArguments('--no-sandbox');
  
  const driver = await new Builder()
    .forBrowser('chrome')
    .setChromeOptions(options)
    .build();
  
  return new ExtendedWebDriver(driver);
}

// ä½¿ç”¨æ‰©å±•çš„WebDriver
async function extendedDriverExample() {
  let driver: ExtendedWebDriver;
  
  try {
    driver = await createExtendedDriver();
    
    await driver.get('https://example.com');
    
    // è·å–æ€§èƒ½æŒ‡æ ‡
    const metrics = await driver.getPerformanceMetrics();
    console.log('é¡µé¢åŠ è½½æ—¶é—´:', metrics.loadTime, 'ms');
    
    // ç­‰å¾…å¹¶ç‚¹å‡»å…ƒç´ 
    await driver.waitAndClick(By.css('.button'));
    
    // ç­‰å¾…å¹¶è¾“å…¥æ–‡æœ¬
    await driver.waitAndType(By.css('input[type="text"]'), 'Hello World');
    
    // é«˜äº®å…ƒç´ 
    const element = await driver.findElement(By.css('.target'));
    await driver.highlightElement(element, 'blue');
    
    // æ»šåŠ¨åˆ°å…ƒç´ 
    await driver.scrollToElement(element);
    
    // æ¨¡æ‹Ÿäººç±»è¾“å…¥
    const inputElement = await driver.findElement(By.css('input[type="text"]'));
    await driver.typeLikeHuman(inputElement, 'This is typed like a human');
    
    // è®¾ç½®cookie
    await driver.setCookie('test-cookie', 'test-value');
    
    // è®¾ç½®æœ¬åœ°å­˜å‚¨
    await driver.setLocalStorage('test-key', 'test-value');
    
    // è·å–å­˜å‚¨çš„å€¼
    const cookieValue = await driver.getAllCookies();
    const localStorageValue = await driver.getLocalStorage('test-key');
    
    console.log('Cookies:', cookieValue);
    console.log('LocalStorage:', localStorageValue);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

### 2. è‡ªå®šä¹‰å…ƒç´ ç±»

```typescript
import { WebElement, By, until } from 'selenium-webdriver';

// æ‰©å±•çš„WebElementç±»
class ExtendedWebElement extends WebElement {
  private driver: any;
  private element: WebElement;
  
  constructor(driver: any, element: WebElement) {
    super();
    this.driver = driver;
    this.element = element;
  }
  
  // è·å–åŸå§‹å…ƒç´ 
  getElement(): WebElement {
    return this.element;
  }
  
  // ç­‰å¾…å…ƒç´ å¯è§
  async waitForVisible(timeout: number = 10000): Promise<void> {
    await this.driver.wait(until.elementIsVisible(this.element), timeout);
  }
  
  // ç­‰å¾…å…ƒç´ å¯ç‚¹å‡»
  async waitForClickable(timeout: number = 10000): Promise<void> {
    await this.driver.wait(until.elementIsEnabled(this.element), timeout);
    await this.driver.wait(until.elementIsVisible(this.element), timeout);
  }
  
  // å®‰å…¨ç‚¹å‡»
  async safeClick(): Promise<void> {
    await this.waitForClickable();
    await this.driver.executeScript('arguments[0].click();', this.element);
  }
  
  // å®‰å…¨è¾“å…¥
  async safeType(text: string): Promise<void> {
    await this.waitForVisible();
    await this.element.clear();
    await this.element.sendKeys(text);
  }
  
  // è·å–æ–‡æœ¬å†…å®¹
  async getTextContent(): Promise<string> {
    return await this.driver.executeScript(
      'return arguments[0].textContent || arguments[0].innerText;', 
      this.element
    );
  }
  
  // è·å–å±æ€§å€¼
  async getAttributeValue(attribute: string): Promise<string> {
    return await this.element.getAttribute(attribute);
  }
  
  // æ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
  async isPresent(): Promise<boolean> {
    try {
      await this.element.isDisplayed();
      return true;
    } catch {
      return false;
    }
  }
  
  // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
  async isVisible(): Promise<boolean> {
    try {
      return await this.element.isDisplayed();
    } catch {
      return false;
    }
  }
  
  // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯ç”¨
  async isEnabled(): Promise<boolean> {
    try {
      return await this.element.isEnabled();
    } catch {
      return false;
    }
  }
  
  // è·å–å…ƒç´ ä½ç½®å’Œå¤§å°
  async getRect(): Promise<{ x: number; y: number; width: number; height: number }> {
    return await this.element.getRect();
  }
  
  // è·å–å…ƒç´ CSSå±æ€§
  async getCssValue(propertyName: string): Promise<string> {
    return await this.element.getCssValue(propertyName);
  }
  
  // æ‚¬åœå…ƒç´ 
  async hover(): Promise<void> {
    const actions = this.driver.actions({ async: true });
    await actions.move({ origin: this.element }).perform();
  }
  
  // åŒå‡»å…ƒç´ 
  async doubleClick(): Promise<void> {
    const actions = this.driver.actions({ async: true });
    await actions.doubleClick(this.element).perform();
  }
  
  // å³é”®ç‚¹å‡»å…ƒç´ 
  async rightClick(): Promise<void> {
    const actions = this.driver.actions({ async: true });
    await actions.contextClick(this.element).perform();
  }
  
  // æ‹–æ‹½å…ƒç´ 
  async dragTo(targetElement: ExtendedWebElement): Promise<void> {
    const actions = this.driver.actions({ async: true });
    await actions
      .dragAndDrop(this.element, targetElement.getElement())
      .perform();
  }
  
  // è·å–å­å…ƒç´ 
  async findChild(locator: By): Promise<ExtendedWebElement> {
    const childElement = await this.element.findElement(locator);
    return new ExtendedWebElement(this.driver, childElement);
  }
  
  // è·å–æ‰€æœ‰å­å…ƒç´ 
  async findChildren(locator: By): Promise<ExtendedWebElement[]> {
    const childElements = await this.element.findElements(locator);
    return childElements.map(element => new ExtendedWebElement(this.driver, element));
  }
  
  // è·å–çˆ¶å…ƒç´ 
  async getParent(): Promise<ExtendedWebElement> {
    const parentElement = await this.driver.executeScript(
      'return arguments[0].parentElement;', 
      this.element
    );
    return new ExtendedWebElement(this.driver, parentElement);
  }
  
  // è·å–å…„å¼Ÿå…ƒç´ 
  async getSiblings(): Promise<ExtendedWebElement[]> {
    const siblingElements = await this.driver.executeScript(`
      const siblings = [];
      let sibling = arguments[0].nextElementSibling;
      while (sibling) {
        siblings.push(sibling);
        sibling = sibling.nextElementSibling;
      }
      return siblings;
    `, this.element);
    
    return siblingElements.map((element: WebElement) => 
      new ExtendedWebElement(this.driver, element)
    );
  }
}

// ä½¿ç”¨æ‰©å±•çš„å…ƒç´ ç±»
async function extendedElementExample() {
  let driver: any;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    await driver.get('https://example.com');
    
    // åˆ›å»ºæ‰©å±•å…ƒç´ 
    const element = new ExtendedWebElement(driver, await driver.findElement(By.css('.target')));
    
    // ç­‰å¾…å…ƒç´ å¯è§
    await element.waitForVisible();
    
    // å®‰å…¨ç‚¹å‡»
    await element.safeClick();
    
    // è·å–æ–‡æœ¬å†…å®¹
    const text = await element.getTextContent();
    console.log('å…ƒç´ æ–‡æœ¬:', text);
    
    // è·å–å±æ€§
    const href = await element.getAttributeValue('href');
    console.log('é“¾æ¥åœ°å€:', href);
    
    // æ£€æŸ¥å…ƒç´ çŠ¶æ€
    console.log('å…ƒç´ å­˜åœ¨:', await element.isPresent());
    console.log('å…ƒç´ å¯è§:', await element.isVisible());
    console.log('å…ƒç´ å¯ç”¨:', await element.isEnabled());
    
    // è·å–å…ƒç´ ä½ç½®
    const rect = await element.getRect();
    console.log('å…ƒç´ ä½ç½®:', rect);
    
    // æ‚¬åœå…ƒç´ 
    await element.hover();
    
    // è·å–å­å…ƒç´ 
    const childElement = await element.findChild(By.css('.child'));
    await childElement.safeClick();
    
    // è·å–å…„å¼Ÿå…ƒç´ 
    const siblings = await element.getSiblings();
    console.log('å…„å¼Ÿå…ƒç´ æ•°é‡:', siblings.length);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## åˆ†å¸ƒå¼æµ‹è¯•

### 1. Selenium Gridé…ç½®

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// Selenium Gridé…ç½®
class SeleniumGridConfig {
  private hubUrl: string;
  private capabilities: any;
  
  constructor(hubUrl: string, capabilities: any) {
    this.hubUrl = hubUrl;
    this.capabilities = capabilities;
  }
  
  // åˆ›å»ºè¿æ¥åˆ°Gridçš„WebDriver
  async createDriver(): Promise<WebDriver> {
    return await new Builder()
      .usingServer(this.hubUrl)
      .forBrowser('chrome')
      .withCapabilities(this.capabilities)
      .build();
  }
  
  // è·å–å¯ç”¨èŠ‚ç‚¹ä¿¡æ¯
  async getAvailableNodes(): Promise<any[]> {
    const response = await fetch(`${this.hubUrl}/grid/api/hub`);
    const data = await response.json();
    return data.slots || [];
  }
  
  // è·å–èŠ‚ç‚¹çŠ¶æ€
  async getNodeStatus(nodeId: string): Promise<any> {
    const response = await fetch(`${this.hubUrl}/grid/api/proxy?id=${nodeId}`);
    return await response.json();
  }
}

// åˆ†å¸ƒå¼æµ‹è¯•ç®¡ç†å™¨
class DistributedTestManager {
  private gridConfigs: SeleniumGridConfig[];
  private testQueue: TestTask[];
  private runningTests: Map<string, TestTask>;
  
  constructor(gridConfigs: SeleniumGridConfig[]) {
    this.gridConfigs = gridConfigs;
    this.testQueue = [];
    this.runningTests = new Map();
  }
  
  // æ·»åŠ æµ‹è¯•ä»»åŠ¡
  addTestTask(task: TestTask): void {
    this.testQueue.push(task);
  }
  
  // æ‰§è¡Œæ‰€æœ‰æµ‹è¯•
  async runAllTests(): Promise<TestResult[]> {
    const results: TestResult[] = [];
    const maxConcurrentTests = this.gridConfigs.length;
    
    while (this.testQueue.length > 0 || this.runningTests.size > 0) {
      // å¯åŠ¨æ–°çš„æµ‹è¯•
      while (this.runningTests.size < maxConcurrentTests && this.testQueue.length > 0) {
        const task = this.testQueue.shift()!;
        const gridConfig = this.gridConfigs[this.runningTests.size];
        
        this.runningTests.set(task.id, task);
        this.runTestTask(task, gridConfig).then(result => {
          results.push(result);
          this.runningTests.delete(task.id);
        });
      }
      
      // ç­‰å¾…ä¸€æ®µæ—¶é—´
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    return results;
  }
  
  // æ‰§è¡Œå•ä¸ªæµ‹è¯•ä»»åŠ¡
  private async runTestTask(task: TestTask, gridConfig: SeleniumGridConfig): Promise<TestResult> {
    let driver: WebDriver | null = null;
    const startTime = Date.now();
    
    try {
      driver = await gridConfig.createDriver();
      
      // æ‰§è¡Œæµ‹è¯•
      await task.testFunction(driver);
      
      return {
        taskId: task.id,
        status: 'PASSED',
        duration: Date.now() - startTime,
        error: null
      };
      
    } catch (error) {
      return {
        taskId: task.id,
        status: 'FAILED',
        duration: Date.now() - startTime,
        error: error instanceof Error ? error.message : String(error)
      };
      
    } finally {
      if (driver) {
        await driver.quit();
      }
    }
  }
}

interface TestTask {
  id: string;
  name: string;
  testFunction: (driver: WebDriver) => Promise<void>;
}

interface TestResult {
  taskId: string;
  status: 'PASSED' | 'FAILED';
  duration: number;
  error: string | null;
}

// ä½¿ç”¨åˆ†å¸ƒå¼æµ‹è¯•
async function distributedTestExample() {
  // é…ç½®å¤šä¸ªGridèŠ‚ç‚¹
  const gridConfigs = [
    new SeleniumGridConfig('http://grid-hub-1:4444', {
      browserName: 'chrome',
      platform: 'WINDOWS'
    }),
    new SeleniumGridConfig('http://grid-hub-2:4444', {
      browserName: 'chrome',
      platform: 'LINUX'
    }),
    new SeleniumGridConfig('http://grid-hub-3:4444', {
      browserName: 'chrome',
      platform: 'MAC'
    })
  ];
  
  const testManager = new DistributedTestManager(gridConfigs);
  
  // æ·»åŠ æµ‹è¯•ä»»åŠ¡
  testManager.addTestTask({
    id: 'test-1',
    name: 'ç™¾åº¦æœç´¢æµ‹è¯•',
    testFunction: async (driver: WebDriver) => {
      await driver.get('https://www.baidu.com');
      await driver.findElement(By.id('kw')).sendKeys('Selenium');
      await driver.findElement(By.id('su')).click();
      await driver.wait(until.elementLocated(By.css('.result')), 10000);
    }
  });
  
  testManager.addTestTask({
    id: 'test-2',
    name: 'è¡¨å•å¡«å†™æµ‹è¯•',
    testFunction: async (driver: WebDriver) => {
      await driver.get('https://httpbin.org/forms/post');
      await driver.findElement(By.name('custname')).sendKeys('Test User');
      await driver.findElement(By.css('input[type="submit"]')).click();
      await driver.wait(until.elementLocated(By.tagName('pre')), 10000);
    }
  });
  
  // æ‰§è¡Œæ‰€æœ‰æµ‹è¯•
  const results = await testManager.runAllTests();
  
  // è¾“å‡ºç»“æœ
  console.log('æµ‹è¯•ç»“æœ:');
  results.forEach(result => {
    console.log(`${result.taskId}: ${result.status} (${result.duration}ms)`);
    if (result.error) {
      console.log(`  é”™è¯¯: ${result.error}`);
    }
  });
}
```

### 2. è´Ÿè½½æµ‹è¯•

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// è´Ÿè½½æµ‹è¯•ç®¡ç†å™¨
class LoadTestManager {
  private concurrentUsers: number;
  private testDuration: number;
  private rampUpTime: number;
  private testFunction: (driver: WebDriver) => Promise<void>;
  private results: LoadTestResult[];
  
  constructor(
    concurrentUsers: number,
    testDuration: number,
    rampUpTime: number,
    testFunction: (driver: WebDriver) => Promise<void>
  ) {
    this.concurrentUsers = concurrentUsers;
    this.testDuration = testDuration;
    this.rampUpTime = rampUpTime;
    this.testFunction = testFunction;
    this.results = [];
  }
  
  // æ‰§è¡Œè´Ÿè½½æµ‹è¯•
  async runLoadTest(): Promise<LoadTestReport> {
    const startTime = Date.now();
    const userPromises: Promise<void>[] = [];
    
    // åˆ›å»ºå¹¶å‘ç”¨æˆ·
    for (let i = 0; i < this.concurrentUsers; i++) {
      const userStartDelay = (i * this.rampUpTime) / this.concurrentUsers;
      
      const userPromise = this.runUserTest(i, userStartDelay);
      userPromises.push(userPromise);
    }
    
    // ç­‰å¾…æ‰€æœ‰ç”¨æˆ·å®Œæˆ
    await Promise.all(userPromises);
    
    const endTime = Date.now();
    const totalDuration = endTime - startTime;
    
    return this.generateReport(totalDuration);
  }
  
  // è¿è¡Œå•ä¸ªç”¨æˆ·æµ‹è¯•
  private async runUserTest(userId: number, startDelay: number): Promise<void> {
    // ç­‰å¾…å¯åŠ¨å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, startDelay));
    
    let driver: WebDriver | null = null;
    const userStartTime = Date.now();
    
    try {
      // åˆ›å»ºWebDriver
      const options = new chrome.Options();
      options.addArguments('--no-sandbox', '--headless');
      
      driver = await new Builder()
        .forBrowser('chrome')
        .setChromeOptions(options)
        .build();
      
      // æ‰§è¡Œæµ‹è¯•
      await this.testFunction(driver);
      
      const duration = Date.now() - userStartTime;
      
      this.results.push({
        userId,
        status: 'SUCCESS',
        duration,
        startTime: userStartTime,
        endTime: Date.now()
      });
      
    } catch (error) {
      const duration = Date.now() - userStartTime;
      
      this.results.push({
        userId,
        status: 'FAILED',
        duration,
        startTime: userStartTime,
        endTime: Date.now(),
        error: error instanceof Error ? error.message : String(error)
      });
      
    } finally {
      if (driver) {
        await driver.quit();
      }
    }
  }
  
  // ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
  private generateReport(totalDuration: number): LoadTestReport {
    const successfulTests = this.results.filter(r => r.status === 'SUCCESS');
    const failedTests = this.results.filter(r => r.status === 'FAILED');
    
    const avgResponseTime = successfulTests.length > 0 
      ? successfulTests.reduce((sum, r) => sum + r.duration, 0) / successfulTests.length 
      : 0;
    
    const minResponseTime = successfulTests.length > 0 
      ? Math.min(...successfulTests.map(r => r.duration)) 
      : 0;
    
    const maxResponseTime = successfulTests.length > 0 
      ? Math.max(...successfulTests.map(r => r.duration)) 
      : 0;
    
    const throughput = (successfulTests.length / totalDuration) * 1000; // è¯·æ±‚/ç§’
    
    return {
      totalTests: this.results.length,
      successfulTests: successfulTests.length,
      failedTests: failedTests.length,
      successRate: (successfulTests.length / this.results.length) * 100,
      avgResponseTime,
      minResponseTime,
      maxResponseTime,
      throughput,
      totalDuration,
      results: this.results
    };
  }
}

interface LoadTestResult {
  userId: number;
  status: 'SUCCESS' | 'FAILED';
  duration: number;
  startTime: number;
  endTime: number;
  error?: string;
}

interface LoadTestReport {
  totalTests: number;
  successfulTests: number;
  failedTests: number;
  successRate: number;
  avgResponseTime: number;
  minResponseTime: number;
  maxResponseTime: number;
  throughput: number;
  totalDuration: number;
  results: LoadTestResult[];
}

// ä½¿ç”¨è´Ÿè½½æµ‹è¯•
async function loadTestExample() {
  // å®šä¹‰æµ‹è¯•åœºæ™¯
  const testScenario = async (driver: WebDriver) => {
    await driver.get('https://example.com');
    await driver.findElement(By.css('.search-input')).sendKeys('test');
    await driver.findElement(By.css('.search-button')).click();
    await driver.wait(until.elementLocated(By.css('.search-results')), 10000);
  };
  
  // åˆ›å»ºè´Ÿè½½æµ‹è¯•ç®¡ç†å™¨
  const loadTest = new LoadTestManager(
    10,    // 10ä¸ªå¹¶å‘ç”¨æˆ·
    60000, // 60ç§’æµ‹è¯•æ—¶é—´
    10000, // 10ç§’çˆ¬å‡æ—¶é—´
    testScenario
  );
  
  // æ‰§è¡Œè´Ÿè½½æµ‹è¯•
  const report = await loadTest.runLoadTest();
  
  // è¾“å‡ºæŠ¥å‘Š
  console.log('ğŸ“Š è´Ÿè½½æµ‹è¯•æŠ¥å‘Š');
  console.log('=' * 50);
  console.log(`æ€»æµ‹è¯•æ•°: ${report.totalTests}`);
  console.log(`æˆåŠŸæµ‹è¯•: ${report.successfulTests}`);
  console.log(`å¤±è´¥æµ‹è¯•: ${report.failedTests}`);
  console.log(`æˆåŠŸç‡: ${report.successRate.toFixed(2)}%`);
  console.log(`å¹³å‡å“åº”æ—¶é—´: ${report.avgResponseTime.toFixed(2)}ms`);
  console.log(`æœ€å°å“åº”æ—¶é—´: ${report.minResponseTime}ms`);
  console.log(`æœ€å¤§å“åº”æ—¶é—´: ${report.maxResponseTime}ms`);
  console.log(`ååé‡: ${report.throughput.toFixed(2)} è¯·æ±‚/ç§’`);
  console.log(`æ€»æµ‹è¯•æ—¶é—´: ${report.totalDuration}ms`);
}
```

## ç§»åŠ¨ç«¯æµ‹è¯•

### 1. ç§»åŠ¨ç«¯WebDriveré…ç½®

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// ç§»åŠ¨ç«¯è®¾å¤‡é…ç½®
const mobileDevices = {
  iPhone: {
    deviceName: 'iPhone 12',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1',
    viewport: { width: 390, height: 844 }
  },
  iPad: {
    deviceName: 'iPad Pro',
    userAgent: 'Mozilla/5.0 (iPad; CPU OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1',
    viewport: { width: 1024, height: 1366 }
  },
  Android: {
    deviceName: 'Samsung Galaxy S21',
    userAgent: 'Mozilla/5.0 (Linux; Android 11; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
    viewport: { width: 360, height: 800 }
  }
};

// åˆ›å»ºç§»åŠ¨ç«¯WebDriver
async function createMobileDriver(deviceType: keyof typeof mobileDevices): Promise<WebDriver> {
  const device = mobileDevices[deviceType];
  
  const options = new chrome.Options();
  options.addArguments('--no-sandbox');
  options.addArguments('--disable-dev-shm-usage');
  
  // è®¾ç½®ç§»åŠ¨ç«¯å‚æ•°
  options.addArguments(`--user-agent=${device.userAgent}`);
  options.addArguments(`--window-size=${device.viewport.width},${device.viewport.height}`);
  
  // å¯ç”¨è§¦æ‘¸äº‹ä»¶
  options.addArguments('--enable-touch-drag-drop');
  options.addArguments('--enable-features=VizDisplayCompositor');
  
  const driver = await new Builder()
    .forBrowser('chrome')
    .setChromeOptions(options)
    .build();
  
  // è®¾ç½®è§†å£å¤§å°
  await driver.manage().window().setRect({
    width: device.viewport.width,
    height: device.viewport.height
  });
  
  return driver;
}

// ç§»åŠ¨ç«¯æµ‹è¯•å·¥å…·ç±»
class MobileTestUtils {
  private driver: WebDriver;
  
  constructor(driver: WebDriver) {
    this.driver = driver;
  }
  
  // æ¨¡æ‹Ÿè§¦æ‘¸ç‚¹å‡»
  async touchClick(element: any): Promise<void> {
    await this.driver.executeScript(`
      const element = arguments[0];
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      const touchEvent = new TouchEvent('touchstart', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [{
          identifier: 0,
          target: element,
          clientX: centerX,
          clientY: centerY,
          pageX: centerX,
          pageY: centerY
        }]
      });
      
      element.dispatchEvent(touchEvent);
    `, element);
  }
  
  // æ¨¡æ‹Ÿæ»‘åŠ¨
  async swipe(startX: number, startY: number, endX: number, endY: number, duration: number = 500): Promise<void> {
    await this.driver.executeScript(`
      const startX = arguments[0];
      const startY = arguments[1];
      const endX = arguments[2];
      const endY = arguments[3];
      const duration = arguments[4];
      
      const touchStartEvent = new TouchEvent('touchstart', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [{
          identifier: 0,
          target: document.body,
          clientX: startX,
          clientY: startY,
          pageX: startX,
          pageY: startY
        }]
      });
      
      const touchMoveEvent = new TouchEvent('touchmove', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [{
          identifier: 0,
          target: document.body,
          clientX: endX,
          clientY: endY,
          pageX: endX,
          pageY: endY
        }]
      });
      
      const touchEndEvent = new TouchEvent('touchend', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: []
      });
      
      document.body.dispatchEvent(touchStartEvent);
      setTimeout(() => {
        document.body.dispatchEvent(touchMoveEvent);
        setTimeout(() => {
          document.body.dispatchEvent(touchEndEvent);
        }, duration / 2);
      }, duration / 2);
    `, startX, startY, endX, endY, duration);
  }
  
  // æ¨¡æ‹Ÿæåˆç¼©æ”¾
  async pinchZoom(scale: number): Promise<void> {
    await this.driver.executeScript(`
      const scale = arguments[0];
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      
      const touchStartEvent = new TouchEvent('touchstart', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [
          {
            identifier: 0,
            target: document.body,
            clientX: centerX - 50,
            clientY: centerY - 50,
            pageX: centerX - 50,
            pageY: centerY - 50
          },
          {
            identifier: 1,
            target: document.body,
            clientX: centerX + 50,
            clientY: centerY + 50,
            pageX: centerX + 50,
            pageY: centerY + 50
          }
        ]
      });
      
      const touchMoveEvent = new TouchEvent('touchmove', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [
          {
            identifier: 0,
            target: document.body,
            clientX: centerX - 50 * scale,
            clientY: centerY - 50 * scale,
            pageX: centerX - 50 * scale,
            pageY: centerY - 50 * scale
          },
          {
            identifier: 1,
            target: document.body,
            clientX: centerX + 50 * scale,
            clientY: centerY + 50 * scale,
            pageX: centerX + 50 * scale,
            pageY: centerY + 50 * scale
          }
        ]
      });
      
      const touchEndEvent = new TouchEvent('touchend', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: []
      });
      
      document.body.dispatchEvent(touchStartEvent);
      setTimeout(() => {
        document.body.dispatchEvent(touchMoveEvent);
        setTimeout(() => {
          document.body.dispatchEvent(touchEndEvent);
        }, 200);
      }, 200);
    `, scale);
  }
  
  // æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨è§†å£å†…
  async isElementInViewport(element: any): Promise<boolean> {
    return await this.driver.executeScript(`
      const element = arguments[0];
      const rect = element.getBoundingClientRect();
      return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= window.innerHeight &&
        rect.right <= window.innerWidth
      );
    `, element);
  }
  
  // æ»šåŠ¨åˆ°å…ƒç´ 
  async scrollToElement(element: any): Promise<void> {
    await this.driver.executeScript(`
      const element = arguments[0];
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
    `, element);
  }
  
  // è·å–è®¾å¤‡æ–¹å‘
  async getOrientation(): Promise<string> {
    return await this.driver.executeScript(`
      return window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
    `);
  }
  
  // æ—‹è½¬è®¾å¤‡
  async rotateDevice(): Promise<void> {
    const currentOrientation = await this.getOrientation();
    const newWidth = currentOrientation === 'portrait' ? 844 : 390;
    const newHeight = currentOrientation === 'portrait' ? 390 : 844;
    
    await this.driver.manage().window().setRect({
      width: newWidth,
      height: newHeight
    });
  }
}

// ç§»åŠ¨ç«¯æµ‹è¯•ç¤ºä¾‹
async function mobileTestExample() {
  let driver: WebDriver;
  
  try {
    // åˆ›å»ºiPhoneè®¾å¤‡é©±åŠ¨
    driver = await createMobileDriver('iPhone');
    const mobileUtils = new MobileTestUtils(driver);
    
    await driver.get('https://example.com');
    
    // æ£€æŸ¥è®¾å¤‡æ–¹å‘
    const orientation = await mobileUtils.getOrientation();
    console.log('è®¾å¤‡æ–¹å‘:', orientation);
    
    // æŸ¥æ‰¾å¹¶ç‚¹å‡»ç§»åŠ¨ç«¯èœå•æŒ‰é’®
    const menuButton = await driver.findElement(By.css('.mobile-menu-button'));
    await mobileUtils.touchClick(menuButton);
    
    // ç­‰å¾…èœå•å±•å¼€
    await driver.wait(until.elementLocated(By.css('.mobile-menu')), 5000);
    
    // æ»‘åŠ¨é¡µé¢
    await mobileUtils.swipe(200, 400, 200, 100);
    
    // æŸ¥æ‰¾å…ƒç´ å¹¶æ»šåŠ¨åˆ°è§†å£å†…
    const targetElement = await driver.findElement(By.css('.target-element'));
    const isInViewport = await mobileUtils.isElementInViewport(targetElement);
    
    if (!isInViewport) {
      await mobileUtils.scrollToElement(targetElement);
    }
    
    // æ¨¡æ‹Ÿæåˆç¼©æ”¾
    await mobileUtils.pinchZoom(1.5);
    
    // æ—‹è½¬è®¾å¤‡
    await mobileUtils.rotateDevice();
    
    // æˆªå›¾
    const screenshot = await driver.takeScreenshot();
    const fs = require('fs');
    fs.writeFileSync('mobile_test_screenshot.png', screenshot, 'base64');
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## æ€§èƒ½ç›‘æ§

### 1. æ€§èƒ½æŒ‡æ ‡æ”¶é›†

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// æ€§èƒ½ç›‘æ§ç±»
class PerformanceMonitor {
  private driver: WebDriver;
  private metrics: PerformanceMetrics[];
  
  constructor(driver: WebDriver) {
    this.driver = driver;
    this.metrics = [];
  }
  
  // å¼€å§‹ç›‘æ§
  async startMonitoring(): Promise<void> {
    // å¯ç”¨æ€§èƒ½ç›‘æ§
    await this.driver.executeScript(`
      window.performanceObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          if (entry.entryType === 'navigation' || entry.entryType === 'resource') {
            window.performanceMetrics = window.performanceMetrics || [];
            window.performanceMetrics.push({
              name: entry.name,
              type: entry.entryType,
              startTime: entry.startTime,
              duration: entry.duration,
              timestamp: Date.now()
            });
          }
        });
      });
      
      window.performanceObserver.observe({ entryTypes: ['navigation', 'resource'] });
    `);
  }
  
  // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
  async collectMetrics(): Promise<PerformanceMetrics> {
    const navigationTiming = await this.driver.executeScript(`
      const timing = performance.timing;
      return {
        navigationStart: timing.navigationStart,
        loadEventEnd: timing.loadEventEnd,
        domContentLoadedEventEnd: timing.domContentLoadedEventEnd,
        responseEnd: timing.responseEnd,
        requestStart: timing.requestStart,
        loadTime: timing.loadEventEnd - timing.navigationStart,
        domReadyTime: timing.domContentLoadedEventEnd - timing.navigationStart,
        responseTime: timing.responseEnd - timing.requestStart
      };
    `);
    
    const resourceTiming = await this.driver.executeScript(`
      return performance.getEntriesByType('resource').map(entry => ({
        name: entry.name,
        duration: entry.duration,
        transferSize: entry.transferSize,
        decodedBodySize: entry.decodedBodySize
      }));
    `);
    
    const memoryInfo = await this.driver.executeScript(`
      if (performance.memory) {
        return {
          usedJSHeapSize: performance.memory.usedJSHeapSize,
          totalJSHeapSize: performance.memory.totalJSHeapSize,
          jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
        };
      }
      return null;
    `);
    
    const customMetrics = await this.driver.executeScript(`
      return window.performanceMetrics || [];
    `);
    
    const metrics: PerformanceMetrics = {
      timestamp: Date.now(),
      navigationTiming,
      resourceTiming,
      memoryInfo,
      customMetrics
    };
    
    this.metrics.push(metrics);
    return metrics;
  }
  
  // è·å–æ‰€æœ‰æ”¶é›†çš„æŒ‡æ ‡
  getAllMetrics(): PerformanceMetrics[] {
    return this.metrics;
  }
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  generateReport(): PerformanceReport {
    if (this.metrics.length === 0) {
      throw new Error('No metrics collected');
    }
    
    const latestMetrics = this.metrics[this.metrics.length - 1];
    const navigationTiming = latestMetrics.navigationTiming;
    
    const totalResourceSize = latestMetrics.resourceTiming.reduce(
      (sum, resource) => sum + (resource.transferSize || 0), 0
    );
    
    const avgResourceLoadTime = latestMetrics.resourceTiming.length > 0
      ? latestMetrics.resourceTiming.reduce((sum, resource) => sum + resource.duration, 0) / latestMetrics.resourceTiming.length
      : 0;
    
    return {
      pageLoadTime: navigationTiming.loadTime,
      domReadyTime: navigationTiming.domReadyTime,
      responseTime: navigationTiming.responseTime,
      totalResources: latestMetrics.resourceTiming.length,
      totalResourceSize,
      avgResourceLoadTime,
      memoryUsage: latestMetrics.memoryInfo?.usedJSHeapSize || 0,
      memoryLimit: latestMetrics.memoryInfo?.jsHeapSizeLimit || 0,
      metrics: this.metrics
    };
  }
}

interface PerformanceMetrics {
  timestamp: number;
  navigationTiming: any;
  resourceTiming: any[];
  memoryInfo: any;
  customMetrics: any[];
}

interface PerformanceReport {
  pageLoadTime: number;
  domReadyTime: number;
  responseTime: number;
  totalResources: number;
  totalResourceSize: number;
  avgResourceLoadTime: number;
  memoryUsage: number;
  memoryLimit: number;
  metrics: PerformanceMetrics[];
}

// ä½¿ç”¨æ€§èƒ½ç›‘æ§
async function performanceMonitoringExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const monitor = new PerformanceMonitor(driver);
    
    // å¼€å§‹ç›‘æ§
    await monitor.startMonitoring();
    
    // å¯¼èˆªåˆ°é¡µé¢
    await driver.get('https://example.com');
    
    // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
    await driver.wait(until.titleIs(await driver.getTitle()), 10000);
    
    // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
    const metrics = await monitor.collectMetrics();
    console.log('æ€§èƒ½æŒ‡æ ‡:', metrics);
    
    // ç”ŸæˆæŠ¥å‘Š
    const report = monitor.generateReport();
    console.log('æ€§èƒ½æŠ¥å‘Š:');
    console.log(`é¡µé¢åŠ è½½æ—¶é—´: ${report.pageLoadTime}ms`);
    console.log(`DOMå‡†å¤‡æ—¶é—´: ${report.domReadyTime}ms`);
    console.log(`å“åº”æ—¶é—´: ${report.responseTime}ms`);
    console.log(`èµ„æºæ•°é‡: ${report.totalResources}`);
    console.log(`èµ„æºæ€»å¤§å°: ${report.totalResourceSize} bytes`);
    console.log(`å¹³å‡èµ„æºåŠ è½½æ—¶é—´: ${report.avgResourceLoadTime.toFixed(2)}ms`);
    console.log(`å†…å­˜ä½¿ç”¨: ${report.memoryUsage} bytes`);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// æ€§èƒ½åŸºå‡†æµ‹è¯•ç±»
class PerformanceBenchmark {
  private driver: WebDriver;
  private testResults: BenchmarkResult[];
  
  constructor(driver: WebDriver) {
    this.driver = driver;
    this.testResults = [];
  }
  
  // è¿è¡ŒåŸºå‡†æµ‹è¯•
  async runBenchmark(testName: string, testFunction: () => Promise<void>, iterations: number = 5): Promise<BenchmarkResult> {
    const times: number[] = [];
    
    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();
      
      try {
        await testFunction();
        const endTime = performance.now();
        times.push(endTime - startTime);
      } catch (error) {
        console.error(`åŸºå‡†æµ‹è¯•å¤±è´¥ (è¿­ä»£ ${i + 1}):`, error);
      }
    }
    
    const result: BenchmarkResult = {
      testName,
      iterations,
      times,
      avgTime: times.reduce((sum, time) => sum + time, 0) / times.length,
      minTime: Math.min(...times),
      maxTime: Math.max(...times),
      medianTime: this.calculateMedian(times),
      standardDeviation: this.calculateStandardDeviation(times)
    };
    
    this.testResults.push(result);
    return result;
  }
  
  // è®¡ç®—ä¸­ä½æ•°
  private calculateMedian(numbers: number[]): number {
    const sorted = numbers.slice().sort((a, b) => a - b);
    const middle = Math.floor(sorted.length / 2);
    
    if (sorted.length % 2 === 0) {
      return (sorted[middle - 1] + sorted[middle]) / 2;
    }
    
    return sorted[middle];
  }
  
  // è®¡ç®—æ ‡å‡†å·®
  private calculateStandardDeviation(numbers: number[]): number {
    const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
    const squaredDifferences = numbers.map(num => Math.pow(num - mean, 2));
    const variance = squaredDifferences.reduce((sum, diff) => sum + diff, 0) / numbers.length;
    
    return Math.sqrt(variance);
  }
  
  // ç”ŸæˆåŸºå‡†æµ‹è¯•æŠ¥å‘Š
  generateReport(): BenchmarkReport {
    const totalTests = this.testResults.length;
    const avgTimes = this.testResults.map(r => r.avgTime);
    const totalAvgTime = avgTimes.reduce((sum, time) => sum + time, 0);
    
    return {
      totalTests,
      totalAvgTime,
      results: this.testResults,
      summary: {
        fastestTest: this.testResults.reduce((min, result) => 
          result.avgTime < min.avgTime ? result : min
        ),
        slowestTest: this.testResults.reduce((max, result) => 
          result.avgTime > max.avgTime ? result : max
        ),
        mostConsistentTest: this.testResults.reduce((most, result) => 
          result.standardDeviation < most.standardDeviation ? result : most
        )
      }
    };
  }
}

interface BenchmarkResult {
  testName: string;
  iterations: number;
  times: number[];
  avgTime: number;
  minTime: number;
  maxTime: number;
  medianTime: number;
  standardDeviation: number;
}

interface BenchmarkReport {
  totalTests: number;
  totalAvgTime: number;
  results: BenchmarkResult[];
  summary: {
    fastestTest: BenchmarkResult;
    slowestTest: BenchmarkResult;
    mostConsistentTest: BenchmarkResult;
  };
}

// ä½¿ç”¨æ€§èƒ½åŸºå‡†æµ‹è¯•
async function performanceBenchmarkExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const benchmark = new PerformanceBenchmark(driver);
    
    // æµ‹è¯•é¡µé¢åŠ è½½æ€§èƒ½
    await benchmark.runBenchmark('é¡µé¢åŠ è½½æµ‹è¯•', async () => {
      await driver.get('https://example.com');
      await driver.wait(until.titleIs(await driver.getTitle()), 10000);
    });
    
    // æµ‹è¯•å…ƒç´ æŸ¥æ‰¾æ€§èƒ½
    await benchmark.runBenchmark('å…ƒç´ æŸ¥æ‰¾æµ‹è¯•', async () => {
      await driver.get('https://example.com');
      for (let i = 0; i < 10; i++) {
        await driver.findElement(By.css('.test-element'));
      }
    });
    
    // æµ‹è¯•JavaScriptæ‰§è¡Œæ€§èƒ½
    await benchmark.runBenchmark('JavaScriptæ‰§è¡Œæµ‹è¯•', async () => {
      await driver.get('https://example.com');
      for (let i = 0; i < 100; i++) {
        await driver.executeScript('return document.querySelectorAll("*").length;');
      }
    });
    
    // ç”ŸæˆæŠ¥å‘Š
    const report = benchmark.generateReport();
    
    console.log('ğŸ“Š æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š');
    console.log('=' * 50);
    console.log(`æ€»æµ‹è¯•æ•°: ${report.totalTests}`);
    console.log(`æ€»å¹³å‡æ—¶é—´: ${report.totalAvgTime.toFixed(2)}ms`);
    
    console.log('\nè¯¦ç»†ç»“æœ:');
    report.results.forEach(result => {
      console.log(`\n${result.testName}:`);
      console.log(`  å¹³å‡æ—¶é—´: ${result.avgTime.toFixed(2)}ms`);
      console.log(`  æœ€å°æ—¶é—´: ${result.minTime.toFixed(2)}ms`);
      console.log(`  æœ€å¤§æ—¶é—´: ${result.maxTime.toFixed(2)}ms`);
      console.log(`  ä¸­ä½æ•°: ${result.medianTime.toFixed(2)}ms`);
      console.log(`  æ ‡å‡†å·®: ${result.standardDeviation.toFixed(2)}ms`);
    });
    
    console.log('\næ€»ç»“:');
    console.log(`æœ€å¿«æµ‹è¯•: ${report.summary.fastestTest.testName} (${report.summary.fastestTest.avgTime.toFixed(2)}ms)`);
    console.log(`æœ€æ…¢æµ‹è¯•: ${report.summary.slowestTest.testName} (${report.summary.slowestTest.avgTime.toFixed(2)}ms)`);
    console.log(`æœ€ç¨³å®šæµ‹è¯•: ${report.summary.mostConsistentTest.testName} (æ ‡å‡†å·®: ${report.summary.mostConsistentTest.standardDeviation.toFixed(2)}ms)`);
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## å®‰å…¨æµ‹è¯•

### 1. XSSæ£€æµ‹

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// XSSæµ‹è¯•ç±»
class XSSTester {
  private driver: WebDriver;
  private testPayloads: string[];
  
  constructor(driver: WebDriver) {
    this.driver = driver;
    this.testPayloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '"><img src=x onerror=alert("XSS")>',
      '"><svg onload=alert("XSS")>',
      '"><iframe src="javascript:alert(\'XSS\')">',
      '"><body onload=alert("XSS")>',
      '"><input onfocus=alert("XSS") autofocus>',
      '"><textarea onfocus=alert("XSS") autofocus>',
      '"><select onfocus=alert("XSS") autofocus>'
    ];
  }
  
  // æµ‹è¯•è¾“å…¥æ¡†XSSæ¼æ´
  async testInputXSS(url: string, inputSelectors: string[]): Promise<XSSResult[]> {
    const results: XSSResult[] = [];
    
    for (const selector of inputSelectors) {
      for (const payload of this.testPayloads) {
        try {
          await this.driver.get(url);
          
          const input = await this.driver.findElement(By.css(selector));
          await input.clear();
          await input.sendKeys(payload);
          
          // å°è¯•æäº¤è¡¨å•
          const submitButton = await this.driver.findElement(By.css('input[type="submit"], button[type="submit"], .submit-button'));
          await submitButton.click();
          
          // æ£€æŸ¥æ˜¯å¦æœ‰å¼¹çª—
          const alertPresent = await this.checkForAlert();
          
          if (alertPresent) {
            results.push({
              selector,
              payload,
              vulnerable: true,
              alertText: await this.getAlertText()
            });
            
            // å…³é—­å¼¹çª—
            await this.driver.switchTo().alert().accept();
          } else {
            results.push({
              selector,
              payload,
              vulnerable: false,
              alertText: null
            });
          }
          
        } catch (error) {
          results.push({
            selector,
            payload,
            vulnerable: false,
            alertText: null,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
    }
    
    return results;
  }
  
  // æµ‹è¯•URLå‚æ•°XSSæ¼æ´
  async testURLParameterXSS(baseUrl: string, parameters: string[]): Promise<XSSResult[]> {
    const results: XSSResult[] = [];
    
    for (const parameter of parameters) {
      for (const payload of this.testPayloads) {
        try {
          const testUrl = `${baseUrl}?${parameter}=${encodeURIComponent(payload)}`;
          await this.driver.get(testUrl);
          
          // æ£€æŸ¥é¡µé¢æºç æ˜¯å¦åŒ…å«æœªè½¬ä¹‰çš„payload
          const pageSource = await this.driver.getPageSource();
          const vulnerable = pageSource.includes(payload) && !pageSource.includes(encodeURIComponent(payload));
          
          if (vulnerable) {
            results.push({
              selector: `URL Parameter: ${parameter}`,
              payload,
              vulnerable: true,
              alertText: null
            });
          } else {
            results.push({
              selector: `URL Parameter: ${parameter}`,
              payload,
              vulnerable: false,
              alertText: null
            });
          }
          
        } catch (error) {
          results.push({
            selector: `URL Parameter: ${parameter}`,
            payload,
            vulnerable: false,
            alertText: null,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
    }
    
    return results;
  }
  
  // æ£€æŸ¥æ˜¯å¦æœ‰å¼¹çª—
  private async checkForAlert(): Promise<boolean> {
    try {
      await this.driver.switchTo().alert();
      return true;
    } catch {
      return false;
    }
  }
  
  // è·å–å¼¹çª—æ–‡æœ¬
  private async getAlertText(): Promise<string> {
    try {
      const alert = await this.driver.switchTo().alert();
      return await alert.getText();
    } catch {
      return '';
    }
  }
  
  // ç”ŸæˆXSSæµ‹è¯•æŠ¥å‘Š
  generateReport(results: XSSResult[]): XSSReport {
    const totalTests = results.length;
    const vulnerableTests = results.filter(r => r.vulnerable);
    const vulnerableSelectors = [...new Set(vulnerableTests.map(r => r.selector))];
    
    return {
      totalTests,
      vulnerableTests: vulnerableTests.length,
      vulnerableSelectors,
      vulnerabilityRate: (vulnerableTests.length / totalTests) * 100,
      results
    };
  }
}

interface XSSResult {
  selector: string;
  payload: string;
  vulnerable: boolean;
  alertText: string | null;
  error?: string;
}

interface XSSReport {
  totalTests: number;
  vulnerableTests: number;
  vulnerableSelectors: string[];
  vulnerabilityRate: number;
  results: XSSResult[];
}

// ä½¿ç”¨XSSæµ‹è¯•
async function xssTestExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const xssTester = new XSSTester(driver);
    
    // æµ‹è¯•è¾“å…¥æ¡†XSS
    const inputResults = await xssTester.testInputXSS('https://example.com/contact', [
      'input[name="name"]',
      'input[name="email"]',
      'textarea[name="message"]'
    ]);
    
    // æµ‹è¯•URLå‚æ•°XSS
    const urlResults = await xssTester.testURLParameterXSS('https://example.com/search', [
      'q',
      'category',
      'sort'
    ]);
    
    // åˆå¹¶ç»“æœ
    const allResults = [...inputResults, ...urlResults];
    
    // ç”ŸæˆæŠ¥å‘Š
    const report = xssTester.generateReport(allResults);
    
    console.log('ğŸ”’ XSSå®‰å…¨æµ‹è¯•æŠ¥å‘Š');
    console.log('=' * 50);
    console.log(`æ€»æµ‹è¯•æ•°: ${report.totalTests}`);
    console.log(`å‘ç°æ¼æ´: ${report.vulnerableTests}`);
    console.log(`æ¼æ´ç‡: ${report.vulnerabilityRate.toFixed(2)}%`);
    
    if (report.vulnerableSelectors.length > 0) {
      console.log('\nå­˜åœ¨æ¼æ´çš„é€‰æ‹©å™¨:');
      report.vulnerableSelectors.forEach(selector => {
        console.log(`  - ${selector}`);
      });
    }
    
    console.log('\nè¯¦ç»†ç»“æœ:');
    report.results.filter(r => r.vulnerable).forEach(result => {
      console.log(`\né€‰æ‹©å™¨: ${result.selector}`);
      console.log(`Payload: ${result.payload}`);
      if (result.alertText) {
        console.log(`å¼¹çª—æ–‡æœ¬: ${result.alertText}`);
      }
    });
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

### 2. CSRFæ£€æµ‹

```typescript
import { Builder, By, until, WebDriver } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome.js';

// CSRFæµ‹è¯•ç±»
class CSRFTester {
  private driver: WebDriver;
  
  constructor(driver: WebDriver) {
    this.driver = driver;
  }
  
  // æµ‹è¯•CSRFä¿æŠ¤
  async testCSRFProtection(url: string, formSelectors: string[]): Promise<CSRFResult[]> {
    const results: CSRFResult[] = [];
    
    for (const selector of formSelectors) {
      try {
        await this.driver.get(url);
        
        // æŸ¥æ‰¾è¡¨å•
        const form = await this.driver.findElement(By.css(selector));
        
        // æ£€æŸ¥æ˜¯å¦æœ‰CSRF token
        const csrfToken = await this.findCSRFToken(form);
        
        if (csrfToken) {
          results.push({
            formSelector: selector,
            hasCSRFToken: true,
            tokenName: csrfToken.name,
            tokenValue: csrfToken.value,
            vulnerable: false
          });
        } else {
          // å°è¯•æäº¤è¡¨å•
          const submitButton = await form.findElement(By.css('input[type="submit"], button[type="submit"]'));
          await submitButton.click();
          
          // æ£€æŸ¥æ˜¯å¦æˆåŠŸæäº¤ï¼ˆæ²¡æœ‰é”™è¯¯ä¿¡æ¯ï¼‰
          const success = await this.checkFormSubmissionSuccess();
          
          results.push({
            formSelector: selector,
            hasCSRFToken: false,
            tokenName: null,
            tokenValue: null,
            vulnerable: !success
          });
        }
        
      } catch (error) {
        results.push({
          formSelector: selector,
          hasCSRFToken: false,
          tokenName: null,
          tokenValue: null,
          vulnerable: false,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
    
    return results;
  }
  
  // æŸ¥æ‰¾CSRF token
  private async findCSRFToken(form: any): Promise<{ name: string; value: string } | null> {
    try {
      // å¸¸è§çš„CSRF tokenå­—æ®µå
      const tokenFieldNames = [
        'csrf_token',
        'csrf-token',
        '_token',
        'authenticity_token',
        'csrf',
        'token'
      ];
      
      for (const fieldName of tokenFieldNames) {
        try {
          const tokenField = await form.findElement(By.css(`input[name="${fieldName}"]`));
          const tokenValue = await tokenField.getAttribute('value');
          
          if (tokenValue && tokenValue.length > 0) {
            return { name: fieldName, value: tokenValue };
          }
        } catch {
          // å­—æ®µä¸å­˜åœ¨ï¼Œç»§ç»­æŸ¥æ‰¾
        }
      }
      
      return null;
    } catch {
      return null;
    }
  }
  
  // æ£€æŸ¥è¡¨å•æäº¤æ˜¯å¦æˆåŠŸ
  private async checkFormSubmissionSuccess(): Promise<boolean> {
    try {
      // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯ä¿¡æ¯
      const errorElements = await this.driver.findElements(By.css('.error, .alert, .message'));
      
      for (const element of errorElements) {
        const text = await element.getText();
        if (text.toLowerCase().includes('csrf') || text.toLowerCase().includes('token')) {
          return false; // æœ‰CSRFç›¸å…³é”™è¯¯
        }
      }
      
      // æ£€æŸ¥URLæ˜¯å¦æ”¹å˜ï¼ˆå¯èƒ½è¡¨ç¤ºé‡å®šå‘ï¼‰
      const currentUrl = await this.driver.getCurrentUrl();
      return !currentUrl.includes('error');
      
    } catch {
      return true; // å‡è®¾æˆåŠŸ
    }
  }
  
  // ç”ŸæˆCSRFæµ‹è¯•æŠ¥å‘Š
  generateReport(results: CSRFResult[]): CSRFReport {
    const totalTests = results.length;
    const vulnerableTests = results.filter(r => r.vulnerable);
    const protectedTests = results.filter(r => r.hasCSRFToken);
    
    return {
      totalTests,
      vulnerableTests: vulnerableTests.length,
      protectedTests: protectedTests.length,
      vulnerabilityRate: (vulnerableTests.length / totalTests) * 100,
      protectionRate: (protectedTests.length / totalTests) * 100,
      results
    };
  }
}

interface CSRFResult {
  formSelector: string;
  hasCSRFToken: boolean;
  tokenName: string | null;
  tokenValue: string | null;
  vulnerable: boolean;
  error?: string;
}

interface CSRFReport {
  totalTests: number;
  vulnerableTests: number;
  protectedTests: number;
  vulnerabilityRate: number;
  protectionRate: number;
  results: CSRFResult[];
}

// ä½¿ç”¨CSRFæµ‹è¯•
async function csrfTestExample() {
  let driver: WebDriver;
  
  try {
    const options = new chrome.Options();
    options.addArguments('--no-sandbox');
    
    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
    
    const csrfTester = new CSRFTester(driver);
    
    // æµ‹è¯•è¡¨å•CSRFä¿æŠ¤
    const results = await csrfTester.testCSRFProtection('https://example.com/forms', [
      'form[action*="submit"]',
      'form[action*="save"]',
      'form[action*="update"]'
    ]);
    
    // ç”ŸæˆæŠ¥å‘Š
    const report = csrfTester.generateReport(results);
    
    console.log('ğŸ”’ CSRFå®‰å…¨æµ‹è¯•æŠ¥å‘Š');
    console.log('=' * 50);
    console.log(`æ€»æµ‹è¯•æ•°: ${report.totalTests}`);
    console.log(`å­˜åœ¨æ¼æ´: ${report.vulnerableTests}`);
    console.log(`æœ‰ä¿æŠ¤æªæ–½: ${report.protectedTests}`);
    console.log(`æ¼æ´ç‡: ${report.vulnerabilityRate.toFixed(2)}%`);
    console.log(`ä¿æŠ¤ç‡: ${report.protectionRate.toFixed(2)}%`);
    
    console.log('\nè¯¦ç»†ç»“æœ:');
    report.results.forEach(result => {
      console.log(`\nè¡¨å•: ${result.formSelector}`);
      console.log(`æœ‰CSRF Token: ${result.hasCSRFToken ? 'æ˜¯' : 'å¦'}`);
      if (result.hasCSRFToken) {
        console.log(`Tokenåç§°: ${result.tokenName}`);
        console.log(`Tokenå€¼: ${result.tokenValue?.substring(0, 20)}...`);
      }
      console.log(`å­˜åœ¨æ¼æ´: ${result.vulnerable ? 'æ˜¯' : 'å¦'}`);
    });
    
  } finally {
    if (driver) {
      await driver.quit();
    }
  }
}
```

## CI/CDé›†æˆ

### 1. GitHub Actionsé›†æˆ

```yaml
# .github/workflows/selenium-tests.yml
name: Selenium Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [16.x, 18.x]
        browser: [chrome, firefox]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Install Chrome
      if: matrix.browser == 'chrome'
      run: |
        wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -
        echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
        apt-get update
        apt-get install -y google-chrome-stable
    
    - name: Install Firefox
      if: matrix.browser == 'firefox'
      run: |
        apt-get update
        apt-get install -y firefox
    
    - name: Run Selenium tests
      run: npm run test:selenium
      env:
        BROWSER: ${{ matrix.browser }}
        CI: true
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results-${{ matrix.browser }}-${{ matrix.node-version }}
        path: |
          test-results/
          screenshots/
          reports/
    
    - name: Generate test report
      if: always()
      run: npm run generate-report
    
    - name: Comment PR with test results
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const reportPath = './test-report.json';
          
          if (fs.existsSync(reportPath)) {
            const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
            
            const comment = `## ğŸ§ª Selenium Test Results
            **Browser:** ${{ matrix.browser }}
            **Node.js:** ${{ matrix.node-version }}
            
            - âœ… **Passed:** ${report.passed}
            - âŒ **Failed:** ${report.failed}
            - â±ï¸ **Duration:** ${report.duration}ms
            - ğŸ“Š **Success Rate:** ${report.successRate}%
            
            ${report.failed > 0 ? '### Failed Tests\n' + report.failedTests.map(test => `- ${test.name}: ${test.error}`).join('\n') : ''}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }
```

### 2. Jenkinsé›†æˆ

```groovy
// Jenkinsfile
pipeline {
    agent any
    
    environment {
        NODE_VERSION = '18'
        BROWSER = 'chrome'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Setup Node.js') {
            steps {
                nodejs(nodeJSInstallationName: "NodeJS ${NODE_VERSION}") {
                    sh 'npm ci'
                }
            }
        }
        
        stage('Install Browser') {
            steps {
                script {
                    if (env.BROWSER == 'chrome') {
                        sh '''
                            wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | apt-key add -
                            echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
                            apt-get update
                            apt-get install -y google-chrome-stable
                        '''
                    } else if (env.BROWSER == 'firefox') {
                        sh '''
                            apt-get update
                            apt-get install -y firefox
                        '''
                    }
                }
            }
        }
        
        stage('Run Tests') {
            steps {
                nodejs(nodeJSInstallationName: "NodeJS ${NODE_VERSION}") {
                    sh 'npm run test:selenium'
                }
            }
            post {
                always {
                    // æ”¶é›†æµ‹è¯•ç»“æœ
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'reports',
                        reportFiles: 'index.html',
                        reportName: 'Selenium Test Report'
                    ])
                    
                    // æ”¶é›†æˆªå›¾
                    archiveArtifacts artifacts: 'screenshots/**/*', allowEmptyArchive: true
                    
                    // æ”¶é›†æµ‹è¯•ç»“æœæ–‡ä»¶
                    archiveArtifacts artifacts: 'test-results/**/*', allowEmptyArchive: true
                }
                success {
                    echo 'âœ… All tests passed!'
                }
                failure {
                    echo 'âŒ Some tests failed!'
                }
            }
        }
        
        stage('Generate Report') {
            steps {
                nodejs(nodeJSInstallationName: "NodeJS ${NODE_VERSION}") {
                    sh 'npm run generate-report'
                }
            }
        }
    }
    
    post {
        always {
            // æ¸…ç†å·¥ä½œç©ºé—´
            cleanWs()
        }
    }
}
```

### 3. Dockeré›†æˆ

```dockerfile
# Dockerfile
FROM node:18-alpine

# å®‰è£…Chromeä¾èµ–
RUN apk add --no-cache \
    chromium \
    nss \
    freetype \
    freetype-dev \
    harfbuzz \
    ca-certificates \
    ttf-freefont

# è®¾ç½®Chromeç¯å¢ƒå˜é‡
ENV CHROME_BIN=/usr/bin/chromium-browser \
    CHROME_PATH=/usr/lib/chromium/ \
    PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true

# åˆ›å»ºå·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶packageæ–‡ä»¶
COPY package*.json ./

# å®‰è£…ä¾èµ–
RUN npm ci --only=production

# å¤åˆ¶æºä»£ç 
COPY . .

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1001 -S nodejs
RUN adduser -S selenium -u 1001

# æ›´æ”¹æ–‡ä»¶æ‰€æœ‰æƒ
RUN chown -R selenium:nodejs /app
USER selenium

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¯åŠ¨å‘½ä»¤
CMD ["npm", "start"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  selenium-hub:
    image: selenium/hub:4.10.0
    container_name: selenium-hub
    ports:
      - "4442:4442"
      - "4443:4443"
      - "4444:4444"
    environment:
      GRID_MAX_SESSION: 16
      GRID_BROWSER_TIMEOUT: 300
      GRID_TIMEOUT: 300

  chrome:
    image: selenium/node-chrome:4.10.0
    shm_size: 2gb
    depends_on:
      - selenium-hub
    environment:
      SE_EVENT_BUS_HOST: selenium-hub
      SE_EVENT_BUS_PUBLISH_PORT: 4442
      SE_EVENT_BUS_SUBSCRIBE_PORT: 4443
      SE_NODE_MAX_SESSIONS: 4
      SE_NODE_OVERRIDE_MAX_SESSIONS: true

  firefox:
    image: selenium/node-firefox:4.10.0
    shm_size: 2gb
    depends_on:
      - selenium-hub
    environment:
      SE_EVENT_BUS_HOST: selenium-hub
      SE_EVENT_BUS_PUBLISH_PORT: 4442
      SE_EVENT_BUS_SUBSCRIBE_PORT: 4443
      SE_NODE_MAX_SESSIONS: 4
      SE_NODE_OVERRIDE_MAX_SESSIONS: true

  app:
    build: .
    ports:
      - "3000:3000"
    depends_on:
      - selenium-hub
    environment:
      SELENIUM_HUB_URL: http://selenium-hub:4444
      NODE_ENV: production
    volumes:
      - ./test-results:/app/test-results
      - ./screenshots:/app/screenshots
      - ./reports:/app/reports
```

## æ€»ç»“

æœ¬é«˜çº§åŠŸèƒ½è¯¦è§£åŸºäºSteel-Browseré¡¹ç›®çš„å®é™…ä»£ç ï¼Œæ·±å…¥ä»‹ç»äº†Selenium WebDriverçš„é«˜çº§ç‰¹æ€§å’Œæœ€ä½³å®è·µã€‚é€šè¿‡å­¦ä¹ æœ¬æ•™ç¨‹ï¼Œæ‚¨åº”è¯¥èƒ½å¤Ÿï¼š

1. **é«˜çº§ç­‰å¾…ç­–ç•¥**: æŒæ¡è‡ªå®šä¹‰ç­‰å¾…æ¡ä»¶å’Œæ™ºèƒ½ç­‰å¾…ç­–ç•¥
2. **è‡ªå®šä¹‰WebDriver**: å­¦ä¼šæ‰©å±•WebDriveråŠŸèƒ½å’Œåˆ›å»ºè‡ªå®šä¹‰å…ƒç´ ç±»
3. **åˆ†å¸ƒå¼æµ‹è¯•**: äº†è§£Selenium Gridé…ç½®å’Œè´Ÿè½½æµ‹è¯•
4. **ç§»åŠ¨ç«¯æµ‹è¯•**: æŒæ¡ç§»åŠ¨ç«¯WebDriveré…ç½®å’Œè§¦æ‘¸æ“ä½œ
5. **æ€§èƒ½ç›‘æ§**: å­¦ä¼šæ”¶é›†æ€§èƒ½æŒ‡æ ‡å’Œè¿›è¡ŒåŸºå‡†æµ‹è¯•
6. **å®‰å…¨æµ‹è¯•**: æŒæ¡XSSå’ŒCSRFæ¼æ´æ£€æµ‹æ–¹æ³•
7. **CI/CDé›†æˆ**: äº†è§£ä¸GitHub Actionsã€Jenkinså’ŒDockerçš„é›†æˆ

è¿™äº›é«˜çº§åŠŸèƒ½å°†å¸®åŠ©æ‚¨æ„å»ºæ›´åŠ å¼ºå¤§ã€ç¨³å®šå’Œé«˜æ•ˆçš„Webè‡ªåŠ¨åŒ–æµ‹è¯•è§£å†³æ–¹æ¡ˆï¼Œæ»¡è¶³ä¼ä¸šçº§åº”ç”¨çš„å„ç§éœ€æ±‚ã€‚