# 浏览器Agent开发详解 - 第二部分：开发指南与源码分析

## 目录
1. [开发指南](#开发指南)
2. [源码分析](#源码分析)
3. [最佳实践](#最佳实践)
4. [实战案例](#实战案例)

## 开发指南

### 1. 环境准备

#### 基础依赖安装
```bash
# 创建conda虚拟环境
conda create -n browser-agent python=3.11
conda activate browser-agent

# 安装核心依赖
pip install browser-use
pip install lmnr-index
pip install playwright
playwright install chromium

# 安装开发工具
pip install pytest
pip install black
pip install mypy
```

#### 环境配置
```bash
# 创建.env文件配置API密钥
cat > .env << EOF
OPENAI_API_KEY=your_openai_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key
GEMINI_API_KEY=your_gemini_api_key
EOF
```

### 2. 基础Agent开发

#### 使用Browser-Use开发简单Agent
```python
import asyncio
from browser_use import Agent
from browser_use.llm import ChatOpenAI

async def basic_agent_example():
    """基础Agent示例"""
    # 创建Agent实例
    agent = Agent(
        task="访问百度首页并搜索'Python教程'",
        llm=ChatOpenAI(model="gpt-4o", temperature=0.1),
    )
    
    # 运行Agent
    history = await agent.run()
    
    # 输出结果
    print(f"任务完成，共执行{len(history.steps)}步")
    print(f"最终URL: {history.final_url}")
    print(f"最终内容: {history.final_content[:200]}...")

if __name__ == "__main__":
    asyncio.run(basic_agent_example())
```

#### 使用Index开发结构化输出Agent
```python
import asyncio
from index import Agent, GeminiProvider
from pydantic import BaseModel
from typing import List

class SearchResult(BaseModel):
    title: str
    url: str
    description: str

class SearchResults(BaseModel):
    results: List[SearchResult]
    total_count: int

async def structured_output_example():
    """结构化输出示例"""
    # 创建LLM提供者
    llm = GeminiProvider(model="gemini-2.5-pro")
    
    # 创建Agent
    agent = Agent(llm=llm)
    
    # 执行任务并获取结构化输出
    output = await agent.run(
        prompt="访问百度首页，搜索'Python教程'，提取前3个搜索结果的标题、URL和描述",
        output_model=SearchResults
    )
    
    # 解析结果
    results = SearchResults.model_validate(output.result.content)
    
    print(f"找到 {results.total_count} 个结果:")
    for i, result in enumerate(results.results, 1):
        print(f"{i}. {result.title}")
        print(f"   URL: {result.url}")
        print(f"   描述: {result.description}")
        print()

if __name__ == "__main__":
    asyncio.run(structured_output_example())
```

### 3. 自定义动作开发

#### Browser-Use自定义动作
```python
from browser_use.controller import Controller
from browser_use.core.views import ActionResult
from playwright.async_api import Page
import asyncio

# 创建控制器
controller = Controller()

@controller.registry.action("自定义搜索动作")
async def custom_search(query: str, page: Page):
    """在指定网站执行搜索"""
    try:
        # 导航到搜索页面
        await page.goto("https://www.example.com/search")
        
        # 等待搜索框加载
        await page.wait_for_selector("#search-input", timeout=10000)
        
        # 填写搜索框
        await page.fill("#search-input", query)
        
        # 点击搜索按钮
        await page.click("#search-button")
        
        # 等待结果加载
        await page.wait_for_selector(".search-results", timeout=10000)
        
        # 提取搜索结果
        results = await page.query_selector_all(".result-item")
        extracted_data = []
        
        for result in results[:5]:  # 取前5个结果
            title_elem = await result.query_selector(".title")
            title_text = await title_elem.text_content() if title_elem else ""
            
            link_elem = await result.query_selector("a")
            link_href = await link_elem.get_attribute("href") if link_elem else ""
            
            desc_elem = await result.query_selector(".description")
            desc_text = await desc_elem.text_content() if desc_elem else ""
            
            extracted_data.append({
                "title": title_text.strip(),
                "url": link_href,
                "description": desc_text.strip()
            })
        
        return ActionResult(
            extracted_content=extracted_data,
            include_in_memory=True,
            success=True
        )
        
    except Exception as e:
        return ActionResult(
            success=False,
            error=str(e),
            include_in_memory=True
        )

# 使用自定义动作
async def use_custom_action():
    from browser_use import Agent
    from browser_use.llm import ChatOpenAI
    
    agent = Agent(
        task="使用自定义搜索功能搜索'机器学习教程'",
        llm=ChatOpenAI(model="gpt-4o"),
        controller=controller
    )
    
    history = await agent.run()
    return history

if __name__ == "__main__":
    asyncio.run(use_custom_action())
```

#### 高级自定义动作 - 表单处理
```python
@controller.registry.action("智能表单填写")
async def smart_form_fill(form_data: dict, page: Page):
    """智能填写表单"""
    try:
        # 等待表单加载
        await page.wait_for_selector("form", timeout=10000)
        
        # 获取所有表单字段
        form_fields = await page.query_selector_all("input, select, textarea")
        
        filled_fields = []
        
        for field in form_fields:
            field_type = await field.get_attribute("type") or "text"
            field_name = await field.get_attribute("name") or await field.get_attribute("id") or ""
            
            # 根据字段名匹配数据
            if field_name in form_data:
                value = form_data[field_name]
                
                if field_type == "select":
                    # 处理下拉选择框
                    await field.select_option(value=value)
                elif field_type == "checkbox":
                    # 处理复选框
                    if value:
                        await field.check()
                    else:
                        await field.uncheck()
                elif field_type == "radio":
                    # 处理单选按钮
                    radio_selector = f'input[type="radio"][name="{field_name}"][value="{value}"]'
                    await page.click(radio_selector)
                else:
                    # 处理文本输入
                    await field.fill(str(value))
                
                filled_fields.append({
                    "field": field_name,
                    "type": field_type,
                    "value": value
                })
        
        return ActionResult(
            extracted_content={
                "filled_fields": filled_fields,
                "total_fields": len(form_fields)
            },
            include_in_memory=True,
            success=True
        )
        
    except Exception as e:
        return ActionResult(
            success=False,
            error=str(e),
            include_in_memory=True
        )
```

### 4. 错误处理和重试机制

#### 基础重试机制
```python
import asyncio
from typing import Callable, Any, Optional
from functools import wraps

class RetryManager:
    def __init__(self, max_retries: int = 3, base_delay: float = 1.0):
        self.max_retries = max_retries
        self.base_delay = base_delay
    
    async def retry_with_backoff(
        self, 
        func: Callable, 
        *args, 
        **kwargs
    ) -> Any:
        """指数退避重试机制"""
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                if asyncio.iscoroutinefunction(func):
                    result = await func(*args, **kwargs)
                else:
                    result = func(*args, **kwargs)
                return result
                
            except Exception as e:
                last_exception = e
                print(f"尝试 {attempt + 1}/{self.max_retries} 失败: {e}")
                
                if attempt < self.max_retries - 1:
                    delay = self.base_delay * (2 ** attempt)
                    print(f"等待 {delay} 秒后重试...")
                    await asyncio.sleep(delay)
        
        raise last_exception

# 装饰器版本
def retry_on_failure(max_retries: int = 3, base_delay: float = 1.0):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            retry_manager = RetryManager(max_retries, base_delay)
            return await retry_manager.retry_with_backoff(func, *args, **kwargs)
        return wrapper
    return decorator

# 使用示例
@retry_on_failure(max_retries=3, base_delay=1.0)
async def unreliable_operation():
    """模拟不可靠的操作"""
    import random
    if random.random() < 0.7:  # 70%概率失败
        raise Exception("操作失败")
    return "操作成功"
```

#### 智能错误处理
```python
class SmartErrorHandler:
    def __init__(self):
        self.error_patterns = {
            "element_not_found": [
                "Element not found",
                "Timeout waiting for selector",
                "No element found"
            ],
            "network_error": [
                "net::ERR_",
                "Network error",
                "Connection refused"
            ],
            "permission_error": [
                "Permission denied",
                "Access denied",
                "Forbidden"
            ]
        }
    
    def classify_error(self, error: Exception) -> str:
        """分类错误类型"""
        error_str = str(error).lower()
        
        for error_type, patterns in self.error_patterns.items():
            for pattern in patterns:
                if pattern.lower() in error_str:
                    return error_type
        
        return "unknown"
    
    async def handle_error(self, error: Exception, context: dict) -> dict:
        """处理错误并返回恢复策略"""
        error_type = self.classify_error(error)
        
        strategies = {
            "element_not_found": {
                "action": "retry_with_different_selector",
                "delay": 2,
                "max_attempts": 3
            },
            "network_error": {
                "action": "retry_with_backoff",
                "delay": 5,
                "max_attempts": 5
            },
            "permission_error": {
                "action": "skip_and_continue",
                "delay": 0,
                "max_attempts": 1
            },
            "unknown": {
                "action": "retry_once",
                "delay": 1,
                "max_attempts": 1
            }
        }
        
        return strategies.get(error_type, strategies["unknown"])

# 使用智能错误处理
async def robust_operation(operation_func, *args, **kwargs):
    """带智能错误处理的操作"""
    error_handler = SmartErrorHandler()
    max_attempts = 5
    
    for attempt in range(max_attempts):
        try:
            return await operation_func(*args, **kwargs)
        except Exception as e:
            strategy = await error_handler.handle_error(e, {"attempt": attempt})
            
            if strategy["action"] == "skip_and_continue":
                print(f"跳过操作: {e}")
                return None
            
            if attempt < strategy["max_attempts"] - 1:
                print(f"错误处理策略: {strategy['action']}")
                await asyncio.sleep(strategy["delay"])
            else:
                raise e
```

### 5. 性能优化

#### 并发处理
```python
import asyncio
from typing import List, Dict, Any
from concurrent.futures import ThreadPoolExecutor

class ConcurrentAgent:
    def __init__(self, max_concurrent: int = 3):
        self.max_concurrent = max_concurrent
        self.semaphore = asyncio.Semaphore(max_concurrent)
    
    async def process_multiple_tasks(self, tasks: List[Dict[str, Any]]) -> List[Any]:
        """并发处理多个任务"""
        async def process_single_task(task: Dict[str, Any]):
            async with self.semaphore:
                agent = Agent(
                    task=task["prompt"],
                    llm=ChatOpenAI(model=task.get("model", "gpt-4o"))
                )
                return await agent.run()
        
        # 并发执行所有任务
        results = await asyncio.gather(
            *[process_single_task(task) for task in tasks],
            return_exceptions=True
        )
        
        return results
    
    async def batch_process_urls(self, urls: List[str], operation: str) -> List[Any]:
        """批量处理URL列表"""
        tasks = [
            {
                "prompt": f"访问 {url} 并{operation}",
                "model": "gpt-4o"
            }
            for url in urls
        ]
        
        return await self.process_multiple_tasks(tasks)

# 使用示例
async def concurrent_example():
    agent = ConcurrentAgent(max_concurrent=3)
    
    urls = [
        "https://example1.com",
        "https://example2.com",
        "https://example3.com",
        "https://example4.com",
        "https://example5.com"
    ]
    
    results = await agent.batch_process_urls(urls, "提取页面标题")
    
    for url, result in zip(urls, results):
        if isinstance(result, Exception):
            print(f"处理 {url} 时出错: {result}")
        else:
            print(f"成功处理 {url}: {result.final_content[:100]}...")
```

#### 缓存机制
```python
import hashlib
import json
import pickle
from datetime import datetime, timedelta
from typing import Optional, Any

class CacheManager:
    def __init__(self, cache_dir: str = ".cache", ttl_hours: int = 24):
        self.cache_dir = cache_dir
        self.ttl_hours = ttl_hours
        self.cache = {}
        
        # 创建缓存目录
        import os
        os.makedirs(cache_dir, exist_ok=True)
    
    def _generate_cache_key(self, task: str, url: str, params: dict = None) -> str:
        """生成缓存键"""
        content = f"{task}:{url}:{json.dumps(params or {}, sort_keys=True)}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def _get_cache_file_path(self, cache_key: str) -> str:
        """获取缓存文件路径"""
        return f"{self.cache_dir}/{cache_key}.pkl"
    
    def get_cached_result(self, cache_key: str) -> Optional[Any]:
        """获取缓存结果"""
        # 先检查内存缓存
        if cache_key in self.cache:
            cached_data = self.cache[cache_key]
            if datetime.now() < cached_data["expires_at"]:
                return cached_data["data"]
            else:
                del self.cache[cache_key]
        
        # 检查文件缓存
        cache_file = self._get_cache_file_path(cache_key)
        try:
            with open(cache_file, "rb") as f:
                cached_data = pickle.load(f)
                if datetime.now() < cached_data["expires_at"]:
                    # 加载到内存缓存
                    self.cache[cache_key] = cached_data
                    return cached_data["data"]
        except (FileNotFoundError, pickle.PickleError):
            pass
        
        return None
    
    def set_cached_result(self, cache_key: str, data: Any):
        """设置缓存结果"""
        expires_at = datetime.now() + timedelta(hours=self.ttl_hours)
        cached_data = {
            "data": data,
            "expires_at": expires_at,
            "created_at": datetime.now()
        }
        
        # 保存到内存缓存
        self.cache[cache_key] = cached_data
        
        # 保存到文件缓存
        cache_file = self._get_cache_file_path(cache_key)
        try:
            with open(cache_file, "wb") as f:
                pickle.dump(cached_data, f)
        except Exception as e:
            print(f"保存缓存失败: {e}")

# 使用缓存的Agent
class CachedAgent:
    def __init__(self, cache_manager: CacheManager):
        self.cache_manager = cache_manager
    
    async def execute_with_cache(self, task: str, url: str, params: dict = None):
        """带缓存的执行"""
        cache_key = self.cache_manager._generate_cache_key(task, url, params)
        
        # 检查缓存
        cached_result = self.cache_manager.get_cached_result(cache_key)
        if cached_result:
            print(f"使用缓存结果: {cache_key}")
            return cached_result
        
        # 执行任务
        agent = Agent(task=task, llm=ChatOpenAI(model="gpt-4o"))
        result = await agent.run()
        
        # 保存到缓存
        self.cache_manager.set_cached_result(cache_key, result)
        print(f"保存结果到缓存: {cache_key}")
        
        return result
```

## 源码分析

### 1. Browser-Use核心源码分析

#### Agent服务类核心逻辑
```python
# browser_use/agent/service.py 核心部分分析

class AgentService:
    def __init__(self, task: str, llm: BaseChatModel, controller: Controller):
        self.task = task
        self.llm = llm
        self.controller = controller
        self.browser = BrowserSession()
        self.message_manager = MessageManager()
        self.history = []
    
    async def run(self) -> AgentHistory:
        """执行Agent任务的主循环"""
        try:
            # 初始化浏览器
            await self.browser.start()
            
            step_count = 0
            max_steps = 50  # 防止无限循环
            
            while step_count < max_steps:
                step_count += 1
                
                # 1. 获取当前浏览器状态
                state = await self.browser.get_state()
                
                # 2. 构建消息历史
                messages = self.message_manager.build_messages(
                    task=self.task,
                    browser_state=state,
                    action_history=self.history
                )
                
                # 3. 调用LLM获取下一步动作
                llm_response = await self.llm.generate_action(messages)
                
                # 4. 解析动作
                action = self._parse_action(llm_response)
                
                # 5. 执行动作
                result = await self.controller.execute(action, self.browser)
                
                # 6. 记录历史
                self.history.append({
                    "step": step_count,
                    "action": action,
                    "result": result,
                    "state": state
                })
                
                # 7. 检查是否完成
                if result.is_done or result.success is False:
                    break
            
            return AgentHistory(
                steps=self.history,
                final_url=state.url,
                final_content=state.content,
                success=result.success
            )
            
        finally:
            await self.browser.close()
    
    def _parse_action(self, llm_response: str) -> Action:
        """解析LLM响应为具体动作"""
        try:
            # 尝试JSON解析
            action_data = json.loads(llm_response)
            return Action(
                name=action_data["action"],
                parameters=action_data.get("parameters", {})
            )
        except json.JSONDecodeError:
            # 回退到文本解析
            return self._parse_text_action(llm_response)
```

#### 消息管理器实现
```python
# browser_use/agent/message_manager/service.py 核心部分

class MessageManager:
    def __init__(self, action_descriptions: List[str]):
        self.action_descriptions = action_descriptions
        self.system_prompt = self._load_system_prompt()
    
    def build_messages(self, task: str, browser_state: BrowserState, action_history: List[dict]) -> List[BaseMessage]:
        """构建发送给LLM的消息列表"""
        messages = []
        
        # 1. 系统提示
        messages.append(SystemMessage(content=self.system_prompt))
        
        # 2. 任务描述
        messages.append(UserMessage(content=f"任务: {task}"))
        
        # 3. 可用动作描述
        actions_text = "\n".join(self.action_descriptions)
        messages.append(SystemMessage(content=f"可用动作:\n{actions_text}"))
        
        # 4. 历史动作
        for history_item in action_history[-5:]:  # 只保留最近5步
            action_msg = f"步骤 {history_item['step']}: {history_item['action']}"
            if history_item['result'].success:
                action_msg += f" -> 成功: {history_item['result'].content}"
            else:
                action_msg += f" -> 失败: {history_item['result'].error}"
            messages.append(ActionMessage(content=action_msg))
        
        # 5. 当前状态
        state_message = self._format_browser_state(browser_state)
        messages.append(UserMessage(content=state_message))
        
        return messages
    
    def _format_browser_state(self, state: BrowserState) -> str:
        """格式化浏览器状态为文本"""
        state_text = f"""
当前页面信息:
- URL: {state.url}
- 标题: {state.title}
- 可见元素数量: {len(state.visible_elements)}

可见的交互元素:
"""
        
        for i, element in enumerate(state.visible_elements[:10], 1):  # 只显示前10个
            state_text += f"{i}. {element.tag_name}: {element.text} (选择器: {element.selector})\n"
        
        if len(state.visible_elements) > 10:
            state_text += f"... 还有 {len(state.visible_elements) - 10} 个元素\n"
        
        return state_text
```

### 2. Index核心源码分析

#### Agent类实现
```python
# index/index/agent/agent.py 核心部分

class Agent:
    def __init__(self, llm: BaseLLMProvider, browser_config: BrowserConfig = None):
        self.llm = llm
        self.controller = Controller()
        self.browser = Browser(config=browser_config if browser_config else BrowserConfig())
        
        # 获取动作描述
        action_descriptions = self.controller.get_action_descriptions()
        
        # 初始化消息管理器
        self.message_manager = MessageManager(action_descriptions=action_descriptions)
        
        # 初始化状态
        self.state = AgentState(messages=[])
    
    async def step(self, step: int, previous_result: ActionResult = None) -> tuple[ActionResult, str]:
        """执行单个步骤"""
        # 1. 更新浏览器状态
        state = await self.browser.update_state()
        
        # 2. 添加状态消息
        if previous_result:
            self.message_manager.add_current_state_message(state, previous_result)
        
        # 3. 获取输入消息
        input_messages = self.message_manager.get_messages()
        
        try:
            # 4. 生成动作
            model_output = await self._generate_action(input_messages)
        except Exception as e:
            # 模型调用失败，移除最后的状态消息并重试
            self.message_manager.remove_last_message()
            raise e
        
        if previous_result:
            # 移除之前添加的状态消息，因为我们要用不同格式重新添加
            self.message_manager.remove_last_message()
        
        # 5. 添加模型输出消息
        self.message_manager.add_message_from_model_output(
            step, previous_result, model_output, state.screenshot
        )
        
        try:
            # 6. 执行动作
            result: ActionResult = await self.controller.execute_action(
                model_output.action, self.browser
            )
            
            if result.is_done:
                logger.info(f'任务完成: {result.content}')
                self.final_output = result.content
            
            return result, model_output.summary
            
        except Exception as e:
            raise e
    
    async def _generate_action(self, messages: List[Message]) -> AgentLLMOutput:
        """生成动作"""
        response = await self.llm.generate(messages)
        
        # 验证JSON响应
        validated_response = validate_json(response.content)
        
        return AgentLLMOutput(
            action=validated_response["action"],
            summary=validated_response.get("summary", ""),
            thinking=validated_response.get("thinking", "")
        )
    
    async def run(self, prompt: str, output_model: Optional[Type[BaseModel]] = None) -> AgentOutput:
        """运行Agent"""
        step = 1
        previous_result = None
        
        while True:
            try:
                result, summary = await self.step(step, previous_result)
                
                if result.is_done:
                    break
                
                previous_result = result
                step += 1
                
                # 防止无限循环
                if step > 50:
                    break
                    
            except Exception as e:
                logger.error(f"步骤 {step} 执行失败: {e}")
                break
        
        # 处理输出模型
        if output_model and hasattr(self, 'final_output'):
            try:
                validated_output = output_model.model_validate(self.final_output)
                return AgentOutput(result=validated_output)
            except Exception as e:
                logger.error(f"输出模型验证失败: {e}")
                return AgentOutput(result=self.final_output)
        
        return AgentOutput(result=self.final_output)
```

### 3. Steel Browser核心源码分析

#### API服务架构
```typescript
// steel-browser/api/src/index.ts

export const server = fastify({
  logger: loggingConfig[process.env.NODE_ENV ?? "development"] ?? true,
  trustProxy: true,
  bodyLimit: 100 * MB,
  disableRequestLogging: true,
});

const setupServer = async () => {
  await server.register(fastifySensible);
  await server.register(fastifyCors, { origin: true });
  await server.register(steelBrowserPlugin, {
    fileStorage: {
      maxSizePerSession: 100 * MB,
    },
  });
};

const startServer = async () => {
  try {
    await setupServer();
    await server.listen({ port: PORT, host: HOST });
  } catch (err) {
    server.log.error(err);
    process.exit(1);
  }
};
```

#### 浏览器会话管理
```typescript
// steel-browser/api/src/services/session.service.ts

export class SessionService {
  private sessions = new Map<string, BrowserSession>();
  
  async createSession(options: SessionOptions): Promise<Session> {
    const sessionId = uuid();
    
    // 创建浏览器实例
    const browser = await this.launchBrowser(options);
    
    // 创建会话
    const session = new BrowserSession(sessionId, browser, options);
    
    // 存储会话
    this.sessions.set(sessionId, session);
    
    return {
      id: sessionId,
      status: 'ready',
      createdAt: new Date().toISOString()
    };
  }
  
  async getSession(sessionId: string): Promise<BrowserSession | null> {
    return this.sessions.get(sessionId) || null;
  }
  
  async closeSession(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (session) {
      await session.close();
      this.sessions.delete(sessionId);
    }
  }
  
  private async launchBrowser(options: SessionOptions): Promise<Browser> {
    const launchOptions = {
      headless: options.headless ?? true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--no-first-run',
        '--no-zygote',
        '--disable-gpu'
      ]
    };
    
    if (options.proxy) {
      launchOptions.args.push(`--proxy-server=${options.proxy}`);
    }
    
    return await puppeteer.launch(launchOptions);
  }
}
```

## 最佳实践

### 1. 错误处理最佳实践

#### 分层错误处理
```python
class LayeredErrorHandler:
    def __init__(self):
        self.handlers = {
            "network": NetworkErrorHandler(),
            "browser": BrowserErrorHandler(),
            "llm": LLMErrorHandler(),
            "parsing": ParsingErrorHandler()
        }
    
    async def handle_error(self, error: Exception, context: dict) -> dict:
        """分层处理错误"""
        error_type = self._classify_error(error)
        
        if error_type in self.handlers:
            return await self.handlers[error_type].handle(error, context)
        else:
            return await self._default_handler(error, context)
    
    def _classify_error(self, error: Exception) -> str:
        """分类错误"""
        error_str = str(error).lower()
        
        if any(keyword in error_str for keyword in ["network", "connection", "timeout"]):
            return "network"
        elif any(keyword in error_str for keyword in ["browser", "page", "element"]):
            return "browser"
        elif any(keyword in error_str for keyword in ["llm", "api", "model"]):
            return "llm"
        elif any(keyword in error_str for keyword in ["json", "parse", "format"]):
            return "parsing"
        else:
            return "unknown"

class NetworkErrorHandler:
    async def handle(self, error: Exception, context: dict) -> dict:
        return {
            "action": "retry_with_backoff",
            "delay": 5,
            "max_attempts": 3,
            "message": "网络错误，正在重试..."
        }

class BrowserErrorHandler:
    async def handle(self, error: Exception, context: dict) -> dict:
        return {
            "action": "refresh_page",
            "delay": 2,
            "max_attempts": 2,
            "message": "浏览器错误，正在刷新页面..."
        }
```

### 2. 性能优化最佳实践

#### 资源管理
```python
import asyncio
from contextlib import asynccontextmanager
from typing import AsyncGenerator

class ResourceManager:
    def __init__(self, max_browsers: int = 5):
        self.max_browsers = max_browsers
        self.active_browsers = 0
        self.semaphore = asyncio.Semaphore(max_browsers)
    
    @asynccontextmanager
    async def get_browser(self) -> AsyncGenerator[Browser, None]:
        """获取浏览器实例"""
        async with self.semaphore:
            self.active_browsers += 1
            try:
                browser = await self._create_browser()
                yield browser
            finally:
                await browser.close()
                self.active_browsers -= 1
    
    async def _create_browser(self) -> Browser:
        """创建浏览器实例"""
        return await playwright.chromium.launch(
            headless=True,
            args=[
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-accelerated-2d-canvas',
                '--no-first-run',
                '--no-zygote',
                '--disable-gpu'
            ]
        )

# 使用资源管理器
async def optimized_agent():
    resource_manager = ResourceManager(max_browsers=3)
    
    async with resource_manager.get_browser() as browser:
        page = await browser.new_page()
        
        # 执行任务
        await page.goto("https://example.com")
        content = await page.content()
        
        return content
```

#### 内存优化
```python
import gc
import weakref
from typing import Dict, Any

class MemoryOptimizedAgent:
    def __init__(self):
        self._cache = weakref.WeakValueDictionary()
        self._large_objects = []
    
    def optimize_memory(self):
        """优化内存使用"""
        # 清理缓存
        self._cache.clear()
        
        # 清理大对象
        self._large_objects.clear()
        
        # 强制垃圾回收
        gc.collect()
    
    def add_to_cache(self, key: str, value: Any):
        """添加到弱引用缓存"""
        self._cache[key] = value
    
    def get_from_cache(self, key: str) -> Any:
        """从缓存获取"""
        return self._cache.get(key)
    
    async def run_with_memory_optimization(self, task: str):
        """带内存优化的运行"""
        try:
            # 执行任务
            result = await self._execute_task(task)
            return result
        finally:
            # 任务完成后优化内存
            self.optimize_memory()
```

### 3. 监控和日志最佳实践

#### 结构化日志
```python
import logging
import json
from datetime import datetime
from typing import Dict, Any

class StructuredLogger:
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.metrics = {
            "total_actions": 0,
            "successful_actions": 0,
            "failed_actions": 0,
            "total_duration": 0,
            "average_duration": 0
        }
    
    def log_action(self, action: str, duration: float, success: bool, details: Dict[str, Any] = None):
        """记录动作日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "duration": duration,
            "success": success,
            "details": details or {}
        }
        
        # 更新指标
        self.metrics["total_actions"] += 1
        self.metrics["total_duration"] += duration
        
        if success:
            self.metrics["successful_actions"] += 1
            self.logger.info("动作执行成功", extra=log_entry)
        else:
            self.metrics["failed_actions"] += 1
            self.logger.error("动作执行失败", extra=log_entry)
        
        # 更新平均时长
        self.metrics["average_duration"] = (
            self.metrics["total_duration"] / self.metrics["total_actions"]
        )
    
    def get_metrics(self) -> Dict[str, Any]:
        """获取监控指标"""
        return {
            **self.metrics,
            "success_rate": (
                self.metrics["successful_actions"] / 
                max(self.metrics["total_actions"], 1)
            )
        }
    
    def export_metrics(self, filepath: str):
        """导出指标到文件"""
        with open(filepath, 'w') as f:
            json.dump(self.get_metrics(), f, indent=2)

# 使用结构化日志
logger = StructuredLogger("browser_agent")

async def monitored_operation():
    start_time = datetime.now()
    
    try:
        # 执行操作
        result = await some_operation()
        
        duration = (datetime.now() - start_time).total_seconds()
        logger.log_action(
            action="some_operation",
            duration=duration,
            success=True,
            details={"result": str(result)}
        )
        
        return result
        
    except Exception as e:
        duration = (datetime.now() - start_time).total_seconds()
        logger.log_action(
            action="some_operation",
            duration=duration,
            success=False,
            details={"error": str(e)}
        )
        raise
```

## 实战案例

### 1. 电商数据采集Agent

```python
import asyncio
from typing import List, Dict, Any
from pydantic import BaseModel

class ProductInfo(BaseModel):
    title: str
    price: str
    rating: str
    reviews_count: str
    url: str

class EcommerceScraperAgent:
    def __init__(self):
        self.controller = Controller()
        self._register_ecommerce_actions()
    
    def _register_ecommerce_actions(self):
        @self.controller.registry.action("搜索商品")
        async def search_products(query: str, page: Page):
            """搜索商品"""
            await page.goto("https://www.amazon.com")
            await page.fill("#twotabsearchtextbox", query)
            await page.click("#nav-search-submit-button")
            await page.wait_for_selector("[data-component-type='s-search-result']")
            
            return ActionResult(success=True, content="搜索完成")
        
        @self.controller.registry.action("提取商品信息")
        async def extract_products(page: Page):
            """提取商品信息"""
            products = await page.query_selector_all("[data-component-type='s-search-result']")
            product_list = []
            
            for product in products[:10]:  # 取前10个商品
                try:
                    title_elem = await product.query_selector("h2 a span")
                    title = await title_elem.text_content() if title_elem else ""
                    
                    price_elem = await product.query_selector(".a-price-whole")
                    price = await price_elem.text_content() if price_elem else ""
                    
                    rating_elem = await product.query_selector(".a-icon-alt")
                    rating = await rating_elem.text_content() if rating_elem else ""
                    
                    reviews_elem = await product.query_selector(".a-size-base")
                    reviews = await reviews_elem.text_content() if reviews_elem else ""
                    
                    link_elem = await product.query_selector("h2 a")
                    url = await link_elem.get_attribute("href") if link_elem else ""
                    
                    product_list.append(ProductInfo(
                        title=title.strip(),
                        price=price.strip(),
                        rating=rating.strip(),
                        reviews_count=reviews.strip(),
                        url=f"https://www.amazon.com{url}" if url else ""
                    ))
                except Exception as e:
                    print(f"提取商品信息失败: {e}")
                    continue
            
            return ActionResult(
                success=True,
                extracted_content=product_list,
                include_in_memory=True
            )
    
    async def scrape_products(self, search_query: str) -> List[ProductInfo]:
        """采集商品信息"""
        agent = Agent(
            task=f"在亚马逊搜索'{search_query}'并提取前10个商品的信息",
            llm=ChatOpenAI(model="gpt-4o"),
            controller=self.controller
        )
        
        history = await agent.run()
        
        # 从历史中提取商品信息
        for step in history.steps:
            if step.result.extracted_content:
                return step.result.extracted_content
        
        return []

# 使用示例
async def main():
    scraper = EcommerceScraperAgent()
    products = await scraper.scrape_products("laptop")
    
    for i, product in enumerate(products, 1):
        print(f"{i}. {product.title}")
        print(f"   价格: {product.price}")
        print(f"   评分: {product.rating}")
        print(f"   评论数: {product.reviews_count}")
        print(f"   链接: {product.url}")
        print()

if __name__ == "__main__":
    asyncio.run(main())
```

### 2. 表单自动化Agent

```python
class FormAutomationAgent:
    def __init__(self):
        self.controller = Controller()
        self._register_form_actions()
    
    def _register_form_actions(self):
        @self.controller.registry.action("智能表单填写")
        async def smart_form_fill(form_data: dict, page: Page):
            """智能填写表单"""
            try:
                # 等待表单加载
                await page.wait_for_selector("form", timeout=10000)
                
                # 获取所有表单字段
                form_fields = await page.query_selector_all("input, select, textarea")
                
                filled_fields = []
                
                for field in form_fields:
                    field_type = await field.get_attribute("type") or "text"
                    field_name = await field.get_attribute("name") or await field.get_attribute("id") or ""
                    field_placeholder = await field.get_attribute("placeholder") or ""
                    
                    # 根据字段名、placeholder或类型匹配数据
                    matched_value = self._match_field_value(
                        field_name, field_placeholder, field_type, form_data
                    )
                    
                    if matched_value is not None:
                        await self._fill_field(field, field_type, matched_value)
                        filled_fields.append({
                            "field": field_name,
                            "type": field_type,
                            "value": matched_value
                        })
                
                return ActionResult(
                    success=True,
                    extracted_content={
                        "filled_fields": filled_fields,
                        "total_fields": len(form_fields)
                    },
                    include_in_memory=True
                )
                
            except Exception as e:
                return ActionResult(
                    success=False,
                    error=str(e),
                    include_in_memory=True
                )
    
    def _match_field_value(self, field_name: str, placeholder: str, field_type: str, form_data: dict) -> Any:
        """匹配字段值"""
        # 直接匹配字段名
        if field_name in form_data:
            return form_data[field_name]
        
        # 根据placeholder匹配
        if placeholder:
            for key, value in form_data.items():
                if key.lower() in placeholder.lower() or placeholder.lower() in key.lower():
                    return value
        
        # 根据字段类型匹配
        type_mapping = {
            "email": form_data.get("email"),
            "tel": form_data.get("phone"),
            "password": form_data.get("password"),
            "date": form_data.get("birth_date"),
        }
        
        return type_mapping.get(field_type)
    
    async def _fill_field(self, field, field_type: str, value: Any):
        """填写字段"""
        if field_type == "select":
            await field.select_option(value=str(value))
        elif field_type == "checkbox":
            if value:
                await field.check()
            else:
                await field.uncheck()
        elif field_type == "radio":
            radio_selector = f'input[type="radio"][name="{await field.get_attribute("name")}"][value="{value}"]'
            await field.page.click(radio_selector)
        else:
            await field.fill(str(value))
    
    async def fill_form(self, form_url: str, form_data: dict) -> bool:
        """填写表单"""
        agent = Agent(
            task=f"访问 {form_url} 并填写表单",
            llm=ChatOpenAI(model="gpt-4o"),
            controller=self.controller
        )
        
        # 添加表单数据到任务描述
        agent.task += f"\n表单数据: {json.dumps(form_data, ensure_ascii=False)}"
        
        history = await agent.run()
        
        # 检查是否成功
        for step in history.steps:
            if step.result.success and step.result.extracted_content:
                filled_fields = step.result.extracted_content.get("filled_fields", [])
                if filled_fields:
                    return True
        
        return False

# 使用示例
async def form_example():
    agent = FormAutomationAgent()
    
    form_data = {
        "name": "张三",
        "email": "zhangsan@example.com",
        "phone": "13800138000",
        "company": "示例公司",
        "message": "这是一条测试消息"
    }
    
    success = await agent.fill_form(
        "https://example.com/contact",
        form_data
    )
    
    if success:
        print("表单填写成功！")
    else:
        print("表单填写失败！")

if __name__ == "__main__":
    asyncio.run(form_example())
```

## 总结

通过深入分析浏览器Agent的开发原理、源码实现和最佳实践，我们可以看到：

1. **核心技术栈**：LLM + 浏览器自动化 + 计算机视觉
2. **架构模式**：感知-决策-执行循环
3. **开发工具**：Playwright/Puppeteer + 大语言模型API
4. **最佳实践**：错误处理、性能优化、监控日志

浏览器Agent开发是一个快速发展的领域，通过掌握这些核心技术，你可以构建出功能强大、稳定可靠的自动化应用。随着技术的不断进步，浏览器Agent将在更多场景中发挥重要作用。
